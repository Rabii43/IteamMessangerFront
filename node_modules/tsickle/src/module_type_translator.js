/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/module_type_translator", ["require", "exports", "typescript", "tsickle/src/googmodule", "tsickle/src/jsdoc", "tsickle/src/transformer_util", "tsickle/src/type_translator"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @fileoverview module_type_translator builds on top of type_translator, adding functionality to
     * translate types within the scope of a single module. The main entry point is
     * ModuleTypeTranslator.
     */
    const ts = require("typescript");
    const googmodule = require("tsickle/src/googmodule");
    const jsdoc = require("tsickle/src/jsdoc");
    const transformer_util_1 = require("tsickle/src/transformer_util");
    const typeTranslator = require("tsickle/src/type_translator");
    /**
     * MutableJSDoc encapsulates a (potential) JSDoc comment on a specific node, and allows code to
     * modify (including delete) it.
     */
    class MutableJSDoc {
        constructor(node, sourceComment, tags) {
            this.node = node;
            this.sourceComment = sourceComment;
            this.tags = tags;
        }
        updateComment(escapeExtraTags) {
            const text = jsdoc.toStringWithoutStartEnd(this.tags, escapeExtraTags);
            if (this.sourceComment) {
                if (!text) {
                    // Delete the (now empty) comment.
                    const comments = ts.getSyntheticLeadingComments(this.node);
                    const idx = comments.indexOf(this.sourceComment);
                    comments.splice(idx, 1);
                    this.sourceComment = null;
                    return;
                }
                this.sourceComment.text = text;
                return;
            }
            // Don't add an empty comment.
            if (!text)
                return;
            const comment = {
                kind: ts.SyntaxKind.MultiLineCommentTrivia,
                text,
                hasTrailingNewLine: true,
                pos: -1,
                end: -1,
            };
            const comments = ts.getSyntheticLeadingComments(this.node) || [];
            comments.push(comment);
            ts.setSyntheticLeadingComments(this.node, comments);
        }
    }
    exports.MutableJSDoc = MutableJSDoc;
    /** Returns the Closure name of a function parameter, special-casing destructuring. */
    function getParameterName(param, index) {
        switch (param.name.kind) {
            case ts.SyntaxKind.Identifier:
                let name = transformer_util_1.getIdentifierText(param.name);
                // TypeScript allows parameters named "arguments", but Closure
                // disallows this, even in externs.
                if (name === 'arguments')
                    name = 'tsickle_arguments';
                return name;
            case ts.SyntaxKind.ArrayBindingPattern:
            case ts.SyntaxKind.ObjectBindingPattern:
                // Closure crashes if you put a binding pattern in the externs.
                // Avoid this by just generating an unused name; the name is
                // ignored anyway.
                return `__${index}`;
            default:
                // The above list of kinds is exhaustive.  param.name is 'never' at this point.
                const paramName = param.name;
                throw new Error(`unhandled function parameter kind: ${ts.SyntaxKind[paramName.kind]}`);
        }
    }
    /**
     * ModuleTypeTranslator encapsulates knowledge and helper functions to translate types in the scope
     * of a specific module. This includes managing Closure requireType statements and any symbol
     * aliases in scope for a whole file.
     */
    class ModuleTypeTranslator {
        constructor(sourceFile, typeChecker, host, diagnostics, isForExterns) {
            this.sourceFile = sourceFile;
            this.typeChecker = typeChecker;
            this.host = host;
            this.diagnostics = diagnostics;
            this.isForExterns = isForExterns;
            /**
             * A mapping of aliases for symbols in the current file, used when emitting types. TypeScript
             * emits imported symbols with unpredictable prefixes. To generate correct type annotations,
             * tsickle creates its own aliases for types, and registers them in this map (see
             * `emitImportDeclaration` and `requireType()` below). The aliases are then used when emitting
             * types.
             */
            this.symbolsToAliasedNames = new Map();
            /**
             * The set of module symbols requireTyped in the local namespace.  This tracks which imported
             * modules we've already added to additionalImports below.
             */
            this.requireTypeModules = new Set();
            /**
             * The list of generated goog.requireType statements for this module. These are inserted into
             * the module's body statements after translation.
             */
            this.additionalImports = [];
        }
        debugWarn(context, messageText) {
            transformer_util_1.reportDebugWarning(this.host, context, messageText);
        }
        error(node, messageText) {
            transformer_util_1.reportDiagnostic(this.diagnostics, node, messageText);
        }
        /**
         * Convert a TypeScript ts.Type into the equivalent Closure type.
         *
         * @param context The ts.Node containing the type reference; used for resolving symbols
         *     in context.
         * @param type The type to translate; if not provided, the Node's type will be used.
         * @param resolveAlias If true, do not emit aliases as their symbol, but rather as the resolved
         *     type underlying the alias. This should be true only when emitting the typedef itself.
         */
        typeToClosure(context, type) {
            if (this.host.untyped) {
                return '?';
            }
            const typeChecker = this.typeChecker;
            if (!type) {
                type = typeChecker.getTypeAtLocation(context);
            }
            return this.newTypeTranslator(context).translate(type);
        }
        newTypeTranslator(context) {
            // In externs, there is no local scope, so all types must be relative to the file level scope.
            const translationContext = this.isForExterns ? this.sourceFile : context;
            const translator = new typeTranslator.TypeTranslator(this.host, this.typeChecker, translationContext, this.host.typeBlackListPaths, this.symbolsToAliasedNames, (sym) => this.ensureSymbolDeclared(sym));
            translator.isForExterns = this.isForExterns;
            translator.warn = msg => this.debugWarn(context, msg);
            return translator;
        }
        isBlackListed(context) {
            const type = this.typeChecker.getTypeAtLocation(context);
            let sym = type.symbol;
            if (!sym)
                return false;
            if (sym.flags & ts.SymbolFlags.Alias) {
                sym = this.typeChecker.getAliasedSymbol(sym);
            }
            return this.newTypeTranslator(context).isBlackListed(sym);
        }
        /**
         * Get the ts.Symbol at a location or throw.
         * The TypeScript API can return undefined when fetching a symbol, but in many contexts we know it
         * won't (e.g. our input is already type-checked).
         */
        mustGetSymbolAtLocation(node) {
            const sym = this.typeChecker.getSymbolAtLocation(node);
            if (!sym)
                throw new Error('no symbol');
            return sym;
        }
        /** Finds an exported (i.e. not global) declaration for the given symbol. */
        findExportedDeclaration(sym) {
            // TODO(martinprobst): it's unclear when a symbol wouldn't have a declaration, maybe just for
            // some builtins (e.g. Symbol)?
            if (!sym.declarations || sym.declarations.length === 0)
                return undefined;
            // A symbol declared in this file does not need to be imported.
            if (sym.declarations.some(d => d.getSourceFile() === this.sourceFile))
                return undefined;
            // Find an exported declaration.
            // Because tsickle runs with the --declaration flag, all types referenced from exported types
            // must be exported, too, so there must either be some declaration that is exported, or the
            // symbol is actually a global declaration (declared in a script file, not a module).
            const decl = sym.declarations.find(d => {
                // Check for Export | Default (default being a default export).
                if (!transformer_util_1.hasModifierFlag(d, ts.ModifierFlags.ExportDefault))
                    return false;
                // Exclude symbols declared in `declare global {...}` blocks, they are global and don't need
                // imports.
                let current = d;
                while (current) {
                    if (current.flags & ts.NodeFlags.GlobalAugmentation)
                        return false;
                    current = current.parent;
                }
                return true;
            });
            return decl;
        }
        /**
         * Generates a somewhat human-readable module prefix for the given import context, to make
         * debugging the emitted Closure types a bit easier.
         */
        generateModulePrefix(importPath) {
            const modulePrefix = importPath.replace(/(\/index)?(\.d)?\.[tj]sx?$/, '')
                .replace(/^.*[/.](.+?)/, '$1')
                .replace(/\W/g, '_');
            return `tsickle_${modulePrefix || 'reqType'}_`;
        }
        /**
         * Records that we we want a `const x = goog.requireType...` import of the given `importPath`,
         * which will be inserted when we emit.
         * This also registers aliases for symbols from the module that map to this requireType.
         *
         * @param isDefaultImport True if the import statement is a default import, e.g.
         *     `import Foo from ...;`, which matters for adjusting whether we emit a `.default`.
         */
        requireType(importPath, moduleSymbol, isDefaultImport = false) {
            if (this.host.untyped)
                return;
            // Already imported? Do not emit a duplicate requireType.
            if (this.requireTypeModules.has(moduleSymbol))
                return;
            if (typeTranslator.isBlacklisted(this.host.typeBlackListPaths, moduleSymbol)) {
                return; // Do not emit goog.requireType for blacklisted paths.
            }
            const nsImport = googmodule.extractGoogNamespaceImport(importPath);
            const requireTypePrefix = this.generateModulePrefix(importPath) + String(this.requireTypeModules.size + 1);
            const moduleNamespace = nsImport !== null ?
                nsImport :
                this.host.pathToModuleName(this.sourceFile.fileName, importPath);
            // In TypeScript, importing a module for use in a type annotation does not cause a runtime load.
            // In Closure Compiler, goog.require'ing a module causes a runtime load, so emitting requires
            // here would cause a change in load order, which is observable (and can lead to errors).
            // Instead, goog.requireType types, which allows using them in type annotations without
            // causing a load.
            //   const requireTypePrefix = goog.requireType(moduleNamespace)
            this.additionalImports.push(ts.createVariableStatement(undefined, ts.createVariableDeclarationList([ts.createVariableDeclaration(requireTypePrefix, undefined, ts.createCall(ts.createPropertyAccess(ts.createIdentifier('goog'), 'requireType'), undefined, [ts.createLiteral(moduleNamespace)]))], ts.NodeFlags.Const)));
            this.requireTypeModules.add(moduleSymbol);
            for (let sym of this.typeChecker.getExportsOfModule(moduleSymbol)) {
                if (sym.flags & ts.SymbolFlags.Alias) {
                    sym = this.typeChecker.getAliasedSymbol(sym);
                }
                // goog: imports don't actually use the .default property that TS thinks they have.
                const qualifiedName = nsImport && isDefaultImport ? requireTypePrefix : requireTypePrefix + '.' + sym.name;
                this.symbolsToAliasedNames.set(sym, qualifiedName);
            }
        }
        ensureSymbolDeclared(sym) {
            const decl = this.findExportedDeclaration(sym);
            if (!decl)
                return;
            if (this.isForExterns) {
                this.error(decl, `declaration from module used in ambient type: ${sym.name}`);
                return;
            }
            // Actually import the symbol.
            const sourceFile = decl.getSourceFile();
            if (sourceFile === ts.getOriginalNode(this.sourceFile))
                return;
            const moduleSymbol = this.typeChecker.getSymbolAtLocation(sourceFile);
            // A source file might not have a symbol if it's not a module (no ES6 im/exports).
            if (!moduleSymbol)
                return;
            // TODO(martinprobst): this should possibly use fileNameToModuleId.
            this.requireType(sourceFile.fileName, moduleSymbol);
        }
        insertAdditionalImports(sourceFile) {
            let insertion = 0;
            // Skip over a leading file comment holder.
            if (sourceFile.statements.length &&
                sourceFile.statements[0].kind === ts.SyntaxKind.NotEmittedStatement) {
                insertion++;
            }
            return ts.updateSourceFileNode(sourceFile, [
                ...sourceFile.statements.slice(0, insertion),
                ...this.additionalImports,
                ...sourceFile.statements.slice(insertion),
            ]);
        }
        /**
         * Parses and synthesizes comments on node, and returns the JSDoc from it, if any.
         * @param reportWarnings if true, will report warnings from parsing the JSDoc. Set to false if
         *     this is not the "main" location dealing with a node to avoid duplicated warnings.
         */
        getJSDoc(node, reportWarnings) {
            const [tags,] = this.parseJSDoc(node, reportWarnings);
            return tags;
        }
        getMutableJSDoc(node) {
            const [tags, comment] = this.parseJSDoc(node, /* reportWarnings */ true);
            return new MutableJSDoc(node, comment, tags);
        }
        parseJSDoc(node, reportWarnings) {
            // synthesizeLeadingComments below changes text locations for node, so extract the location here
            // in case it is needed later to report diagnostics.
            const start = node.getFullStart();
            const length = node.getLeadingTriviaWidth(this.sourceFile);
            const comments = jsdoc.synthesizeLeadingComments(node);
            if (!comments || comments.length === 0)
                return [[], null];
            for (let i = comments.length - 1; i >= 0; i--) {
                const comment = comments[i];
                const parsed = jsdoc.parse(comment);
                if (parsed) {
                    if (reportWarnings && parsed.warnings) {
                        const range = comment.originalRange || { pos: start, end: start + length };
                        transformer_util_1.reportDiagnostic(this.diagnostics, node, parsed.warnings.join('\n'), range, ts.DiagnosticCategory.Warning);
                    }
                    return [parsed.tags, comment];
                }
            }
            return [[], null];
        }
        /**
         * Creates the jsdoc for methods, including overloads.
         * If overloaded, merges the signatures in the list of SignatureDeclarations into a single jsdoc.
         * - Total number of parameters will be the maximum count found across all variants.
         * - Different names at the same parameter index will be joined with "_or_"
         * - Variable args (...type[] in TypeScript) will be output as "...type",
         *    except if found at the same index as another argument.
         * @param fnDecls Pass > 1 declaration for overloads of same name
         * @return The list of parameter names that should be used to emit the actual
         *    function statement; for overloads, name will have been merged.
         */
        getFunctionTypeJSDoc(fnDecls, extraTags = []) {
            const typeChecker = this.typeChecker;
            // De-duplicate tags and docs found for the fnDecls.
            const tagsByName = new Map();
            function addTag(tag) {
                const existing = tagsByName.get(tag.tagName);
                tagsByName.set(tag.tagName, existing ? jsdoc.merge([existing, tag]) : tag);
            }
            for (const extraTag of extraTags)
                addTag(extraTag);
            const isConstructor = fnDecls.find(d => d.kind === ts.SyntaxKind.Constructor) !== undefined;
            // For each parameter index i, paramTags[i] is an array of parameters
            // that can be found at index i.  E.g.
            //    function foo(x: string)
            //    function foo(y: number, z: string)
            // then paramTags[0] = [info about x, info about y].
            const paramTags = [];
            const returnTags = [];
            const thisTags = [];
            const typeParameterNames = new Set();
            const argCounts = [];
            let thisReturnType = null;
            for (const fnDecl of fnDecls) {
                // Construct the JSDoc comment by reading the existing JSDoc, if
                // any, and merging it with the known types of the function
                // parameters and return type.
                const tags = this.getJSDoc(fnDecl, /* reportWarnings */ false);
                // Copy all the tags other than @param/@return into the new
                // JSDoc without any change; @param/@return are handled specially.
                // TODO: there may be problems if an annotation doesn't apply to all overloads;
                // is it worth checking for this and erroring?
                for (const tag of tags) {
                    if (tag.tagName === 'param' || tag.tagName === 'return')
                        continue;
                    addTag(tag);
                }
                const flags = ts.getCombinedModifierFlags(fnDecl);
                // Add @abstract on "abstract" declarations.
                if (flags & ts.ModifierFlags.Abstract) {
                    addTag({ tagName: 'abstract' });
                }
                // Add @protected/@private if present.
                if (flags & ts.ModifierFlags.Protected) {
                    addTag({ tagName: 'protected' });
                }
                else if (flags & ts.ModifierFlags.Private) {
                    addTag({ tagName: 'private' });
                }
                // Add any @template tags.
                // Multiple declarations with the same template variable names should work:
                // the declarations get turned into union types, and Closure Compiler will need
                // to find a union where all type arguments are satisfied.
                if (fnDecl.typeParameters) {
                    for (const tp of fnDecl.typeParameters) {
                        typeParameterNames.add(transformer_util_1.getIdentifierText(tp.name));
                    }
                }
                // Merge the parameters into a single list of merged names and list of types
                const sig = typeChecker.getSignatureFromDeclaration(fnDecl);
                if (!sig || !sig.declaration)
                    throw new Error(`invalid signature ${fnDecl.name}`);
                if (sig.declaration.kind === ts.SyntaxKind.JSDocSignature) {
                    throw new Error(`JSDoc signature ${fnDecl.name}`);
                }
                let hasThisParam = false;
                for (let i = 0; i < sig.declaration.parameters.length; i++) {
                    const paramNode = sig.declaration.parameters[i];
                    const name = getParameterName(paramNode, i);
                    const isThisParam = name === 'this';
                    if (isThisParam)
                        hasThisParam = true;
                    const newTag = {
                        tagName: isThisParam ? 'this' : 'param',
                        optional: paramNode.initializer !== undefined || paramNode.questionToken !== undefined,
                        parameterName: isThisParam ? undefined : name,
                    };
                    let type = typeChecker.getTypeAtLocation(paramNode);
                    if (paramNode.dotDotDotToken !== undefined) {
                        newTag.restParam = true;
                        // In TypeScript you write "...x: number[]", but in Closure
                        // you don't write the array: "@param {...number} x".  Unwrap
                        // the Array<> wrapper.
                        if ((type.flags & ts.TypeFlags.Object) === 0 && type.flags & ts.TypeFlags.TypeParameter) {
                            // function f<T extends string[]>(...ts: T) has the Array type on the type parameter
                            // constraint, not on the parameter itself. Resolve it.
                            const baseConstraint = typeChecker.getBaseConstraintOfType(type);
                            if (baseConstraint)
                                type = baseConstraint;
                        }
                        if (type.flags & ts.TypeFlags.Object &&
                            type.objectFlags & ts.ObjectFlags.Reference) {
                            const typeRef = type;
                            if (!typeRef.typeArguments) {
                                throw new Error('rest parameter does not resolve to a reference type');
                            }
                            type = typeRef.typeArguments[0];
                        }
                    }
                    newTag.type = this.typeToClosure(fnDecl, type);
                    for (const { tagName, parameterName, text } of tags) {
                        if (tagName === 'param' && parameterName === newTag.parameterName) {
                            newTag.text = text;
                            break;
                        }
                    }
                    if (!isThisParam) {
                        const paramIdx = hasThisParam ? i - 1 : i;
                        if (!paramTags[paramIdx])
                            paramTags.push([]);
                        paramTags[paramIdx].push(newTag);
                    }
                    else {
                        thisTags.push(newTag);
                    }
                }
                argCounts.push(hasThisParam ? sig.declaration.parameters.length - 1 : sig.declaration.parameters.length);
                // Return type.
                if (!isConstructor) {
                    const returnTag = {
                        tagName: 'return',
                    };
                    const retType = typeChecker.getReturnTypeOfSignature(sig);
                    // Generate a templated `@this` tag for TypeScript `foo(): this` return type specification.
                    // Make sure not to do that if the function already has used `@this` due to a this
                    // parameter. It's not clear how to resolve the two conflicting this types best, the current
                    // solution prefers the explicitly given `this` parameter.
                    // tslint:disable-next-line:no-any accessing TS internal field.
                    if (retType.isThisType && !hasThisParam) {
                        // foo(): this
                        thisReturnType = retType;
                        addTag({ tagName: 'template', text: 'THIS' });
                        addTag({ tagName: 'this', type: 'THIS' });
                        returnTag.type = 'THIS';
                    }
                    else {
                        returnTag.type = this.typeToClosure(fnDecl, retType);
                        for (const { tagName, text } of tags) {
                            if (tagName === 'return') {
                                returnTag.text = text;
                                break;
                            }
                        }
                    }
                    returnTags.push(returnTag);
                }
            }
            if (typeParameterNames.size > 0) {
                addTag({ tagName: 'template', text: Array.from(typeParameterNames.values()).join(', ') });
            }
            const newDoc = Array.from(tagsByName.values());
            if (thisTags.length > 0) {
                newDoc.push(jsdoc.merge(thisTags));
            }
            const minArgsCount = Math.min(...argCounts);
            const maxArgsCount = Math.max(...argCounts);
            // Merge the JSDoc tags for each overloaded parameter.
            // Ensure each parameter has a unique name; the merging process can otherwise
            // accidentally generate the same parameter name twice.
            const paramNames = new Set();
            let foundOptional = false;
            for (let i = 0; i < maxArgsCount; i++) {
                const paramTag = jsdoc.merge(paramTags[i]);
                if (paramTag.parameterName) {
                    if (paramNames.has(paramTag.parameterName)) {
                        paramTag.parameterName += i.toString();
                    }
                    paramNames.add(paramTag.parameterName);
                }
                // If the tag is optional, mark parameters following optional as optional,
                // even if they are not, since Closure restricts this, see
                // https://github.com/google/closure-compiler/issues/2314
                if (!paramTag.restParam && (paramTag.optional || foundOptional || i >= minArgsCount)) {
                    foundOptional = true;
                    paramTag.optional = true;
                }
                newDoc.push(paramTag);
                if (paramTag.restParam) {
                    // Cannot have any parameters after a rest param.
                    // Just dump the remaining parameters.
                    break;
                }
            }
            // Merge the JSDoc tags for each overloaded return.
            if (!isConstructor) {
                newDoc.push(jsdoc.merge(returnTags));
            }
            return {
                tags: newDoc,
                parameterNames: newDoc.filter(t => t.tagName === 'param').map(t => t.parameterName),
                thisReturnType,
            };
        }
    }
    exports.ModuleTypeTranslator = ModuleTypeTranslator;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kdWxlX3R5cGVfdHJhbnNsYXRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9tb2R1bGVfdHlwZV90cmFuc2xhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRzs7Ozs7Ozs7Ozs7O0lBRUg7Ozs7T0FJRztJQUVILGlDQUFpQztJQUdqQyxxREFBMkM7SUFDM0MsMkNBQWlDO0lBQ2pDLG1FQUE0RztJQUM1Ryw4REFBb0Q7SUFFcEQ7OztPQUdHO0lBQ0gsTUFBYSxZQUFZO1FBQ3ZCLFlBQ1ksSUFBYSxFQUFVLGFBQXlDLEVBQ2pFLElBQWlCO1lBRGhCLFNBQUksR0FBSixJQUFJLENBQVM7WUFBVSxrQkFBYSxHQUFiLGFBQWEsQ0FBNEI7WUFDakUsU0FBSSxHQUFKLElBQUksQ0FBYTtRQUFHLENBQUM7UUFFaEMsYUFBYSxDQUFDLGVBQTZCO1lBQ3pDLE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLGVBQWUsQ0FBQyxDQUFDO1lBQ3ZFLElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRTtnQkFDdEIsSUFBSSxDQUFDLElBQUksRUFBRTtvQkFDVCxrQ0FBa0M7b0JBQ2xDLE1BQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQywyQkFBMkIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFFLENBQUM7b0JBQzVELE1BQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO29CQUNqRCxRQUFRLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQztvQkFDeEIsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUM7b0JBQzFCLE9BQU87aUJBQ1I7Z0JBQ0QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO2dCQUMvQixPQUFPO2FBQ1I7WUFFRCw4QkFBOEI7WUFDOUIsSUFB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QUUsQ0FBQyxDQUFDLENBQUMsYUFBYyxDQUFDO2dCQUNwRixjQUFjO2FBQ2YsQ0FBQztRQUNKLENBQUM7S0FDRjtJQWpkRCxvREFpZEMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBtb2R1bGVfdHlwZV90cmFuc2xhdG9yIGJ1aWxkcyBvbiB0b3Agb2YgdHlwZV90cmFuc2xhdG9yLCBhZGRpbmcgZnVuY3Rpb25hbGl0eSB0b1xuICogdHJhbnNsYXRlIHR5cGVzIHdpdGhpbiB0aGUgc2NvcGUgb2YgYSBzaW5nbGUgbW9kdWxlLiBUaGUgbWFpbiBlbnRyeSBwb2ludCBpc1xuICogTW9kdWxlVHlwZVRyYW5zbGF0b3IuXG4gKi9cblxuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7QW5ub3RhdG9ySG9zdH0gZnJvbSAnLi9hbm5vdGF0b3JfaG9zdCc7XG5pbXBvcnQgKiBhcyBnb29nbW9kdWxlIGZyb20gJy4vZ29vZ21vZHVsZSc7XG5pbXBvcnQgKiBhcyBqc2RvYyBmcm9tICcuL2pzZG9jJztcbmltcG9ydCB7Z2V0SWRlbnRpZmllclRleHQsIGhhc01vZGlmaWVyRmxhZywgcmVwb3J0RGVidWdXYXJuaW5nLCByZXBvcnREaWFnbm9zdGljfSBmcm9tICcuL3RyYW5zZm9ybWVyX3V0aWwnO1xuaW1wb3J0ICogYXMgdHlwZVRyYW5zbGF0b3IgZnJvbSAnLi90eXBlX3RyYW5zbGF0b3InO1xuXG4vKipcbiAqIE11dGFibGVKU0RvYyBlbmNhcHN1bGF0ZXMgYSAocG90ZW50aWFsKSBKU0RvYyBjb21tZW50IG9uIGEgc3BlY2lmaWMgbm9kZSwgYW5kIGFsbG93cyBjb2RlIHRvXG4gKiBtb2RpZnkgKGluY2x1ZGluZyBkZWxldGUpIGl0LlxuICovXG5leHBvcnQgY2xhc3MgTXV0YWJsZUpTRG9jIHtcbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIG5vZGU6IHRzLk5vZGUsIHByaXZhdGUgc291cmNlQ29tbWVudDogdHMuU3ludGhlc2l6ZWRDb21tZW50fG51bGwsXG4gICAgICBwdWJsaWMgdGFnczoganNkb2MuVGFnW10pIHt9XG5cbiAgdXBkYXRlQ29tbWVudChlc2NhcGVFeHRyYVRhZ3M/OiBTZXQ8c3RyaW5nPikge1xuICAgIGNvbnN0IHRleHQgPSBqc2RvYy50b1N0cmluZ1dpdGhvdXRTdGFydEVuZCh0aGlzLnRhZ3MsIGVzY2FwZUV4dHJhVGFncyk7XG4gICAgaWYgKHRoaXMuc291cmNlQ29tbWVudCkge1xuICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgIC8vIERlbGV0ZSB0aGUgKG5vdyBlbXB0eSkgY29tbWVudC5cbiAgICAgICAgY29uc3QgY29tbWVudHMgPSB0cy5nZXRTeW50aGV0aWNMZWFkaW5nQ29tbWVudHModGhpcy5ub2RlKSE7XG4gICAgICAgIGNvbnN0IGlkeCA9IGNvbW1lbnRzLmluZGV4T2YodGhpcy5zb3VyY2VDb21tZW50KTtcbiAgICAgICAgY29tbWVudHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIHRoaXMuc291cmNlQ29tbWVudCA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc291cmNlQ29tbWVudC50ZXh0ID0gdGV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEb24ndCBhZGQgYW4gZW1wdHkgY29tbWVudC5cbiAgICBpZiAoIXRleHQpIHJldHVybjtcblxuICAgIGNvbnN0IGNvbW1lbnQ6IHRzLlN5bnRoZXNpemVkQ29tbWVudCA9IHtcbiAgICAgIGtpbmQ6IHRzLlN5bnRheEtpbmQuTXVsdGlMaW5lQ29tbWVudFRyaXZpYSxcbiAgICAgIHRleHQsXG4gICAgICBoYXNUcmFpbGluZ05ld0xpbmU6IHRydWUsXG4gICAgICBwb3M6IC0xLFxuICAgICAgZW5kOiAtMSxcbiAgICB9O1xuICAgIGNvbnN0IGNvbW1lbnRzID0gdHMuZ2V0U3ludGhldGljTGVhZGluZ0NvbW1lbnRzKHRoaXMubm9kZSkgfHwgW107XG4gICAgY29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICB0cy5zZXRTeW50aGV0aWNMZWFkaW5nQ29tbWVudHModGhpcy5ub2RlLCBjb21tZW50cyk7XG4gIH1cbn1cblxuLyoqIFJldHVybnMgdGhlIENsb3N1cmUgbmFtZSBvZiBhIGZ1bmN0aW9uIHBhcmFtZXRlciwgc3BlY2lhbC1jYXNpbmcgZGVzdHJ1Y3R1cmluZy4gKi9cbmZ1bmN0aW9uIGdldFBhcmFtZXRlck5hbWUocGFyYW06IHRzLlBhcmFtZXRlckRlY2xhcmF0aW9uLCBpbmRleDogbnVtYmVyKTogc3RyaW5nIHtcbiAgc3dpdGNoIChwYXJhbS5uYW1lLmtpbmQpIHtcbiAgICBjYXNlIHRzLlN5bnRheEtpbmQuSWRlbnRpZmllcjpcbiAgICAgIGxldCBuYW1lID0gZ2V0SWRlbnRpZmllclRleHQocGFyYW0ubmFtZSBhcyB0cy5JZGVudGlmaWVyKTtcbiAgICAgIC8vIFR5cGVTY3JpcHQgYWxsb3dzIHBhcmFtZXRlcnMgbmFtZWQgXCJhcmd1bWVudHNcIiwgYnV0IENsb3N1cmVcbiAgICAgIC8vIGRpc2FsbG93cyB0aGlzLCBldmVuIGluIGV4dGVybnMuXG4gICAgICBpZiAobmFtZSA9PT0gJ2FyZ3VtZW50cycpIG5hbWUgPSAndHNpY2tsZV9hcmd1bWVudHMnO1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgY2FzZSB0cy5TeW50YXhLaW5kLkFycmF5QmluZGluZ1BhdHRlcm46XG4gICAgY2FzZSB0cy5TeW50YXhLaW5kLk9iamVjdEJpbmRpbmdQYXR0ZXJuOlxuICAgICAgLy8gQ2xvc3VyZSBjcmFzaGVzIGlmIHlvdSBwdXQgYSBiaW5kaW5nIHBhdHRlcm4gaW4gdGhlIGV4dGVybnMuXG4gICAgICAvLyBBdm9pZCB0aGlzIGJ5IGp1c3QgZ2VuZXJhdGluZyBhbiB1bnVzZWQgbmFtZTsgdGhlIG5hbWUgaXNcbiAgICAgIC8vIGlnbm9yZWQgYW55d2F5LlxuICAgICAgcmV0dXJuIGBfXyR7aW5kZXh9YDtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gVGhlIGFib3ZlIGxpc3Qgb2Yga2luZHMgaXMgZXhoYXVzdGl2ZS4gIHBhcmFtLm5hbWUgaXMgJ25ldmVyJyBhdCB0aGlzIHBvaW50LlxuICAgICAgY29uc3QgcGFyYW1OYW1lID0gcGFyYW0ubmFtZSBhcyB0cy5Ob2RlO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgZnVuY3Rpb24gcGFyYW1ldGVyIGtpbmQ6ICR7dHMuU3ludGF4S2luZFtwYXJhbU5hbWUua2luZF19YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBNb2R1bGVUeXBlVHJhbnNsYXRvciBlbmNhcHN1bGF0ZXMga25vd2xlZGdlIGFuZCBoZWxwZXIgZnVuY3Rpb25zIHRvIHRyYW5zbGF0ZSB0eXBlcyBpbiB0aGUgc2NvcGVcbiAqIG9mIGEgc3BlY2lmaWMgbW9kdWxlLiBUaGlzIGluY2x1ZGVzIG1hbmFnaW5nIENsb3N1cmUgcmVxdWlyZVR5cGUgc3RhdGVtZW50cyBhbmQgYW55IHN5bWJvbFxuICogYWxpYXNlcyBpbiBzY29wZSBmb3IgYSB3aG9sZSBmaWxlLlxuICovXG5leHBvcnQgY2xhc3MgTW9kdWxlVHlwZVRyYW5zbGF0b3Ige1xuICAvKipcbiAgICogQSBtYXBwaW5nIG9mIGFsaWFzZXMgZm9yIHN5bWJvbHMgaW4gdGhlIGN1cnJlbnQgZmlsZSwgdXNlZCB3aGVuIGVtaXR0aW5nIHR5cGVzLiBUeXBlU2NyaXB0XG4gICAqIGVtaXRzIGltcG9ydGVkIHN5bWJvbHMgd2l0aCB1bnByZWRpY3RhYmxlIHByZWZpeGVzLiBUbyBnZW5lcmF0ZSBjb3JyZWN0IHR5cGUgYW5ub3RhdGlvbnMsXG4gICAqIHRzaWNrbGUgY3JlYXRlcyBpdHMgb3duIGFsaWFzZXMgZm9yIHR5cGVzLCBhbmQgcmVnaXN0ZXJzIHRoZW0gaW4gdGhpcyBtYXAgKHNlZVxuICAgKiBgZW1pdEltcG9ydERlY2xhcmF0aW9uYCBhbmQgYHJlcXVpcmVUeXBlKClgIGJlbG93KS4gVGhlIGFsaWFzZXMgYXJlIHRoZW4gdXNlZCB3aGVuIGVtaXR0aW5nXG4gICAqIHR5cGVzLlxuICAgKi9cbiAgc3ltYm9sc1RvQWxpYXNlZE5hbWVzID0gbmV3IE1hcDx0cy5TeW1ib2wsIHN0cmluZz4oKTtcblxuICAvKipcbiAgICogVGhlIHNldCBvZiBtb2R1bGUgc3ltYm9scyByZXF1aXJlVHlwZWQgaW4gdGhlIGxvY2FsIG5hbWVzcGFjZS4gIFRoaXMgdHJhY2tzIHdoaWNoIGltcG9ydGVkXG4gICAqIG1vZHVsZXMgd2UndmUgYWxyZWFkeSBhZGRlZCB0byBhZGRpdGlvbmFsSW1wb3J0cyBiZWxvdy5cbiAgICovXG4gIHByaXZhdGUgcmVxdWlyZVR5cGVNb2R1bGVzID0gbmV3IFNldDx0cy5TeW1ib2w+KCk7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIGdlbmVyYXRlZCBnb29nLnJlcXVpcmVUeXBlIHN0YXRlbWVudHMgZm9yIHRoaXMgbW9kdWxlLiBUaGVzZSBhcmUgaW5zZXJ0ZWQgaW50b1xuICAgKiB0aGUgbW9kdWxlJ3MgYm9keSBzdGF0ZW1lbnRzIGFmdGVyIHRyYW5zbGF0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSBhZGRpdGlvbmFsSW1wb3J0czogdHMuU3RhdGVtZW50W10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyBzb3VyY2VGaWxlOiB0cy5Tb3VyY2VGaWxlLFxuICAgICAgcHVibGljIHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlcixcbiAgICAgIHByaXZhdGUgaG9zdDogQW5ub3RhdG9ySG9zdCxcbiAgICAgIHByaXZhdGUgZGlhZ25vc3RpY3M6IHRzLkRpYWdub3N0aWNbXSxcbiAgICAgIHByaXZhdGUgaXNGb3JFeHRlcm5zOiBib29sZWFuLFxuICApIHt9XG5cbiAgZGVidWdXYXJuKGNvbnRleHQ6IHRzLk5vZGUsIG1lc3NhZ2VUZXh0OiBzdHJpbmcpIHtcbiAgICByZXBvcnREZWJ1Z1dhcm5pbmcodGhpcy5ob3N0LCBjb250ZXh0LCBtZXNzYWdlVGV4dCk7XG4gIH1cblxuICBlcnJvcihub2RlOiB0cy5Ob2RlLCBtZXNzYWdlVGV4dDogc3RyaW5nKSB7XG4gICAgcmVwb3J0RGlhZ25vc3RpYyh0aGlzLmRpYWdub3N0aWNzLCBub2RlLCBtZXNzYWdlVGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIFR5cGVTY3JpcHQgdHMuVHlwZSBpbnRvIHRoZSBlcXVpdmFsZW50IENsb3N1cmUgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIGNvbnRleHQgVGhlIHRzLk5vZGUgY29udGFpbmluZyB0aGUgdHlwZSByZWZlcmVuY2U7IHVzZWQgZm9yIHJlc29sdmluZyBzeW1ib2xzXG4gICAqICAgICBpbiBjb250ZXh0LlxuICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSB0byB0cmFuc2xhdGU7IGlmIG5vdCBwcm92aWRlZCwgdGhlIE5vZGUncyB0eXBlIHdpbGwgYmUgdXNlZC5cbiAgICogQHBhcmFtIHJlc29sdmVBbGlhcyBJZiB0cnVlLCBkbyBub3QgZW1pdCBhbGlhc2VzIGFzIHRoZWlyIHN5bWJvbCwgYnV0IHJhdGhlciBhcyB0aGUgcmVzb2x2ZWRcbiAgICogICAgIHR5cGUgdW5kZXJseWluZyB0aGUgYWxpYXMuIFRoaXMgc2hvdWxkIGJlIHRydWUgb25seSB3aGVuIGVtaXR0aW5nIHRoZSB0eXBlZGVmIGl0c2VsZi5cbiAgICovXG4gIHR5cGVUb0Nsb3N1cmUoY29udGV4dDogdHMuTm9kZSwgdHlwZT86IHRzLlR5cGUpOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLmhvc3QudW50eXBlZCkge1xuICAgICAgcmV0dXJuICc/JztcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlQ2hlY2tlciA9IHRoaXMudHlwZUNoZWNrZXI7XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0eXBlID0gdHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24oY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm5ld1R5cGVUcmFuc2xhdG9yKGNvbnRleHQpLnRyYW5zbGF0ZSh0eXBlKTtcbiAgfVxuXG4gIG5ld1R5cGVUcmFuc2xhdG9yKGNvbnRleHQ6IHRzLk5vZGUpIHtcbiAgICAvLyBJbiBleHRlcm5zLCB0aGVyZSBpcyBubyBsb2NhbCBzY29wZSwgc28gYWxsIHR5cGVzIG11c3QgYmUgcmVsYXRpdmUgdG8gdGhlIGZpbGUgbGV2ZWwgc2NvcGUuXG4gICAgY29uc3QgdHJhbnNsYXRpb25Db250ZXh0ID0gdGhpcy5pc0ZvckV4dGVybnMgPyB0aGlzLnNvdXJjZUZpbGUgOiBjb250ZXh0O1xuXG4gICAgY29uc3QgdHJhbnNsYXRvciA9IG5ldyB0eXBlVHJhbnNsYXRvci5UeXBlVHJhbnNsYXRvcihcbiAgICAgICAgdGhpcy5ob3N0LCB0aGlzLnR5cGVDaGVja2VyLCB0cmFuc2xhdGlvbkNvbnRleHQsIHRoaXMuaG9zdC50eXBlQmxhY2tMaXN0UGF0aHMsXG4gICAgICAgIHRoaXMuc3ltYm9sc1RvQWxpYXNlZE5hbWVzLCAoc3ltOiB0cy5TeW1ib2wpID0+IHRoaXMuZW5zdXJlU3ltYm9sRGVjbGFyZWQoc3ltKSk7XG4gICAgdHJhbnNsYXRvci5pc0ZvckV4dGVybnMgPSB0aGlzLmlzRm9yRXh0ZXJucztcbiAgICB0cmFuc2xhdG9yLndhcm4gPSBtc2cgPT4gdGhpcy5kZWJ1Z1dhcm4oY29udGV4dCwgbXNnKTtcbiAgICByZXR1cm4gdHJhbnNsYXRvcjtcbiAgfVxuXG4gIGlzQmxhY2tMaXN0ZWQoY29udGV4dDogdHMuTm9kZSkge1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnR5cGVDaGVja2VyLmdldFR5cGVBdExvY2F0aW9uKGNvbnRleHQpO1xuICAgIGxldCBzeW0gPSB0eXBlLnN5bWJvbDtcbiAgICBpZiAoIXN5bSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChzeW0uZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5BbGlhcykge1xuICAgICAgc3ltID0gdGhpcy50eXBlQ2hlY2tlci5nZXRBbGlhc2VkU3ltYm9sKHN5bSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm5ld1R5cGVUcmFuc2xhdG9yKGNvbnRleHQpLmlzQmxhY2tMaXN0ZWQoc3ltKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRzLlN5bWJvbCBhdCBhIGxvY2F0aW9uIG9yIHRocm93LlxuICAgKiBUaGUgVHlwZVNjcmlwdCBBUEkgY2FuIHJldHVybiB1bmRlZmluZWQgd2hlbiBmZXRjaGluZyBhIHN5bWJvbCwgYnV0IGluIG1hbnkgY29udGV4dHMgd2Uga25vdyBpdFxuICAgKiB3b24ndCAoZS5nLiBvdXIgaW5wdXQgaXMgYWxyZWFkeSB0eXBlLWNoZWNrZWQpLlxuICAgKi9cbiAgbXVzdEdldFN5bWJvbEF0TG9jYXRpb24obm9kZTogdHMuTm9kZSk6IHRzLlN5bWJvbCB7XG4gICAgY29uc3Qgc3ltID0gdGhpcy50eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKG5vZGUpO1xuICAgIGlmICghc3ltKSB0aHJvdyBuZXcgRXJyb3IoJ25vIHN5bWJvbCcpO1xuICAgIHJldHVybiBzeW07XG4gIH1cblxuICAvKiogRmluZHMgYW4gZXhwb3J0ZWQgKGkuZS4gbm90IGdsb2JhbCkgZGVjbGFyYXRpb24gZm9yIHRoZSBnaXZlbiBzeW1ib2wuICovXG4gIHByb3RlY3RlZCBmaW5kRXhwb3J0ZWREZWNsYXJhdGlvbihzeW06IHRzLlN5bWJvbCk6IHRzLkRlY2xhcmF0aW9ufHVuZGVmaW5lZCB7XG4gICAgLy8gVE9ETyhtYXJ0aW5wcm9ic3QpOiBpdCdzIHVuY2xlYXIgd2hlbiBhIHN5bWJvbCB3b3VsZG4ndCBoYXZlIGEgZGVjbGFyYXRpb24sIG1heWJlIGp1c3QgZm9yXG4gICAgLy8gc29tZSBidWlsdGlucyAoZS5nLiBTeW1ib2wpP1xuICAgIGlmICghc3ltLmRlY2xhcmF0aW9ucyB8fCBzeW0uZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAvLyBBIHN5bWJvbCBkZWNsYXJlZCBpbiB0aGlzIGZpbGUgZG9lcyBub3QgbmVlZCB0byBiZSBpbXBvcnRlZC5cbiAgICBpZiAoc3ltLmRlY2xhcmF0aW9ucy5zb21lKGQgPT4gZC5nZXRTb3VyY2VGaWxlKCkgPT09IHRoaXMuc291cmNlRmlsZSkpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAvLyBGaW5kIGFuIGV4cG9ydGVkIGRlY2xhcmF0aW9uLlxuICAgIC8vIEJlY2F1c2UgdHNpY2tsZSBydW5zIHdpdGggdGhlIC0tZGVjbGFyYXRpb24gZmxhZywgYWxsIHR5cGVzIHJlZmVyZW5jZWQgZnJvbSBleHBvcnRlZCB0eXBlc1xuICAgIC8vIG11c3QgYmUgZXhwb3J0ZWQsIHRvbywgc28gdGhlcmUgbXVzdCBlaXRoZXIgYmUgc29tZSBkZWNsYXJhdGlvbiB0aGF0IGlzIGV4cG9ydGVkLCBvciB0aGVcbiAgICAvLyBzeW1ib2wgaXMgYWN0dWFsbHkgYSBnbG9iYWwgZGVjbGFyYXRpb24gKGRlY2xhcmVkIGluIGEgc2NyaXB0IGZpbGUsIG5vdCBhIG1vZHVsZSkuXG4gICAgY29uc3QgZGVjbCA9IHN5bS5kZWNsYXJhdGlvbnMuZmluZChkID0+IHtcbiAgICAgIC8vIENoZWNrIGZvciBFeHBvcnQgfCBEZWZhdWx0IChkZWZhdWx0IGJlaW5nIGEgZGVmYXVsdCBleHBvcnQpLlxuICAgICAgaWYgKCFoYXNNb2RpZmllckZsYWcoZCwgdHMuTW9kaWZpZXJGbGFncy5FeHBvcnREZWZhdWx0KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRXhjbHVkZSBzeW1ib2xzIGRlY2xhcmVkIGluIGBkZWNsYXJlIGdsb2JhbCB7Li4ufWAgYmxvY2tzLCB0aGV5IGFyZSBnbG9iYWwgYW5kIGRvbid0IG5lZWRcbiAgICAgIC8vIGltcG9ydHMuXG4gICAgICBsZXQgY3VycmVudDogdHMuTm9kZXx1bmRlZmluZWQgPSBkO1xuICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQuZmxhZ3MgJiB0cy5Ob2RlRmxhZ3MuR2xvYmFsQXVnbWVudGF0aW9uKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWNsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIHNvbWV3aGF0IGh1bWFuLXJlYWRhYmxlIG1vZHVsZSBwcmVmaXggZm9yIHRoZSBnaXZlbiBpbXBvcnQgY29udGV4dCwgdG8gbWFrZVxuICAgKiBkZWJ1Z2dpbmcgdGhlIGVtaXR0ZWQgQ2xvc3VyZSB0eXBlcyBhIGJpdCBlYXNpZXIuXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlTW9kdWxlUHJlZml4KGltcG9ydFBhdGg6IHN0cmluZykge1xuICAgIGNvbnN0IG1vZHVsZVByZWZpeCA9IGltcG9ydFBhdGgucmVwbGFjZSgvKFxcL2luZGV4KT8oXFwuZCk/XFwuW3RqXXN4PyQvLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL14uKlsvLl0oLis/KS8sICckMScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFcvZywgJ18nKTtcbiAgICByZXR1cm4gYHRzaWNrbGVfJHttb2R1bGVQcmVmaXggfHwgJ3JlcVR5cGUnfV9gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY29yZHMgdGhhdCB3ZSB3ZSB3YW50IGEgYGNvbnN0IHggPSBnb29nLnJlcXVpcmVUeXBlLi4uYCBpbXBvcnQgb2YgdGhlIGdpdmVuIGBpbXBvcnRQYXRoYCxcbiAgICogd2hpY2ggd2lsbCBiZSBpbnNlcnRlZCB3aGVuIHdlIGVtaXQuXG4gICAqIFRoaXMgYWxzbyByZWdpc3RlcnMgYWxpYXNlcyBmb3Igc3ltYm9scyBmcm9tIHRoZSBtb2R1bGUgdGhhdCBtYXAgdG8gdGhpcyByZXF1aXJlVHlwZS5cbiAgICpcbiAgICogQHBhcmFtIGlzRGVmYXVsdEltcG9ydCBUcnVlIGlmIHRoZSBpbXBvcnQgc3RhdGVtZW50IGlzIGEgZGVmYXVsdCBpbXBvcnQsIGUuZy5cbiAgICogICAgIGBpbXBvcnQgRm9vIGZyb20gLi4uO2AsIHdoaWNoIG1hdHRlcnMgZm9yIGFkanVzdGluZyB3aGV0aGVyIHdlIGVtaXQgYSBgLmRlZmF1bHRgLlxuICAgKi9cbiAgcmVxdWlyZVR5cGUoaW1wb3J0UGF0aDogc3RyaW5nLCBtb2R1bGVTeW1ib2w6IHRzLlN5bWJvbCwgaXNEZWZhdWx0SW1wb3J0ID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5ob3N0LnVudHlwZWQpIHJldHVybjtcbiAgICAvLyBBbHJlYWR5IGltcG9ydGVkPyBEbyBub3QgZW1pdCBhIGR1cGxpY2F0ZSByZXF1aXJlVHlwZS5cbiAgICBpZiAodGhpcy5yZXF1aXJlVHlwZU1vZHVsZXMuaGFzKG1vZHVsZVN5bWJvbCkpIHJldHVybjtcbiAgICBpZiAodHlwZVRyYW5zbGF0b3IuaXNCbGFja2xpc3RlZCh0aGlzLmhvc3QudHlwZUJsYWNrTGlzdFBhdGhzLCBtb2R1bGVTeW1ib2wpKSB7XG4gICAgICByZXR1cm47ICAvLyBEbyBub3QgZW1pdCBnb29nLnJlcXVpcmVUeXBlIGZvciBibGFja2xpc3RlZCBwYXRocy5cbiAgICB9XG4gICAgY29uc3QgbnNJbXBvcnQgPSBnb29nbW9kdWxlLmV4dHJhY3RHb29nTmFtZXNwYWNlSW1wb3J0KGltcG9ydFBhdGgpO1xuICAgIGNvbnN0IHJlcXVpcmVUeXBlUHJlZml4ID1cbiAgICAgICAgdGhpcy5nZW5lcmF0ZU1vZHVsZVByZWZpeChpbXBvcnRQYXRoKSArIFN0cmluZyh0aGlzLnJlcXVpcmVUeXBlTW9kdWxlcy5zaXplICsgMSk7XG4gICAgY29uc3QgbW9kdWxlTmFtZXNwYWNlID0gbnNJbXBvcnQgIT09IG51bGwgP1xuICAgICAgICBuc0ltcG9ydCA6XG4gICAgICAgIHRoaXMuaG9zdC5wYXRoVG9Nb2R1bGVOYW1lKHRoaXMuc291cmNlRmlsZS5maWxlTmFtZSwgaW1wb3J0UGF0aCk7XG5cbiAgICAvLyBJbiBUeXBlU2NyaXB0LCBpbXBvcnRpbmcgYSBtb2R1bGUgZm9yIHVzZSBpbiBhIHR5cGUgYW5ub3RhdGlvbiBkb2VzIG5vdCBjYXVzZSBhIHJ1bnRpbWUgbG9hZC5cbiAgICAvLyBJbiBDbG9zdXJlIENvbXBpbGVyLCBnb29nLnJlcXVpcmUnaW5nIGEgbW9kdWxlIGNhdXNlcyBhIHJ1bnRpbWUgbG9hZCwgc28gZW1pdHRpbmcgcmVxdWlyZXNcbiAgICAvLyBoZXJlIHdvdWxkIGNhdXNlIGEgY2hhbmdlIGluIGxvYWQgb3JkZXIsIHdoaWNoIGlzIG9ic2VydmFibGUgKGFuZCBjYW4gbGVhZCB0byBlcnJvcnMpLlxuICAgIC8vIEluc3RlYWQsIGdvb2cucmVxdWlyZVR5cGUgdHlwZXMsIHdoaWNoIGFsbG93cyB1c2luZyB0aGVtIGluIHR5cGUgYW5ub3RhdGlvbnMgd2l0aG91dFxuICAgIC8vIGNhdXNpbmcgYSBsb2FkLlxuICAgIC8vICAgY29uc3QgcmVxdWlyZVR5cGVQcmVmaXggPSBnb29nLnJlcXVpcmVUeXBlKG1vZHVsZU5hbWVzcGFjZSlcbiAgICB0aGlzLmFkZGl0aW9uYWxJbXBvcnRzLnB1c2godHMuY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQoXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdHMuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoXG4gICAgICAgICAgICBbdHMuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbihcbiAgICAgICAgICAgICAgICByZXF1aXJlVHlwZVByZWZpeCwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHRzLmNyZWF0ZUNhbGwoXG4gICAgICAgICAgICAgICAgICAgIHRzLmNyZWF0ZVByb3BlcnR5QWNjZXNzKHRzLmNyZWF0ZUlkZW50aWZpZXIoJ2dvb2cnKSwgJ3JlcXVpcmVUeXBlJyksIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgW3RzLmNyZWF0ZUxpdGVyYWwobW9kdWxlTmFtZXNwYWNlKV0pKV0sXG4gICAgICAgICAgICB0cy5Ob2RlRmxhZ3MuQ29uc3QpKSk7XG4gICAgdGhpcy5yZXF1aXJlVHlwZU1vZHVsZXMuYWRkKG1vZHVsZVN5bWJvbCk7XG4gICAgZm9yIChsZXQgc3ltIG9mIHRoaXMudHlwZUNoZWNrZXIuZ2V0RXhwb3J0c09mTW9kdWxlKG1vZHVsZVN5bWJvbCkpIHtcbiAgICAgIGlmIChzeW0uZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5BbGlhcykge1xuICAgICAgICBzeW0gPSB0aGlzLnR5cGVDaGVja2VyLmdldEFsaWFzZWRTeW1ib2woc3ltKTtcbiAgICAgIH1cbiAgICAgIC8vIGdvb2c6IGltcG9ydHMgZG9uJ3QgYWN0dWFsbHkgdXNlIHRoZSAuZGVmYXVsdCBwcm9wZXJ0eSB0aGF0IFRTIHRoaW5rcyB0aGV5IGhhdmUuXG4gICAgICBjb25zdCBxdWFsaWZpZWROYW1lID1cbiAgICAgICAgICBuc0ltcG9ydCAmJiBpc0RlZmF1bHRJbXBvcnQgPyByZXF1aXJlVHlwZVByZWZpeCA6IHJlcXVpcmVUeXBlUHJlZml4ICsgJy4nICsgc3ltLm5hbWU7XG4gICAgICB0aGlzLnN5bWJvbHNUb0FsaWFzZWROYW1lcy5zZXQoc3ltLCBxdWFsaWZpZWROYW1lKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgZW5zdXJlU3ltYm9sRGVjbGFyZWQoc3ltOiB0cy5TeW1ib2wpIHtcbiAgICBjb25zdCBkZWNsID0gdGhpcy5maW5kRXhwb3J0ZWREZWNsYXJhdGlvbihzeW0pO1xuICAgIGlmICghZGVjbCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLmlzRm9yRXh0ZXJucykge1xuICAgICAgdGhpcy5lcnJvcihkZWNsLCBgZGVjbGFyYXRpb24gZnJvbSBtb2R1bGUgdXNlZCBpbiBhbWJpZW50IHR5cGU6ICR7c3ltLm5hbWV9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEFjdHVhbGx5IGltcG9ydCB0aGUgc3ltYm9sLlxuICAgIGNvbnN0IHNvdXJjZUZpbGUgPSBkZWNsLmdldFNvdXJjZUZpbGUoKTtcbiAgICBpZiAoc291cmNlRmlsZSA9PT0gdHMuZ2V0T3JpZ2luYWxOb2RlKHRoaXMuc291cmNlRmlsZSkpIHJldHVybjtcbiAgICBjb25zdCBtb2R1bGVTeW1ib2wgPSB0aGlzLnR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24oc291cmNlRmlsZSk7XG4gICAgLy8gQSBzb3VyY2UgZmlsZSBtaWdodCBub3QgaGF2ZSBhIHN5bWJvbCBpZiBpdCdzIG5vdCBhIG1vZHVsZSAobm8gRVM2IGltL2V4cG9ydHMpLlxuICAgIGlmICghbW9kdWxlU3ltYm9sKSByZXR1cm47XG4gICAgLy8gVE9ETyhtYXJ0aW5wcm9ic3QpOiB0aGlzIHNob3VsZCBwb3NzaWJseSB1c2UgZmlsZU5hbWVUb01vZHVsZUlkLlxuICAgIHRoaXMucmVxdWlyZVR5cGUoc291cmNlRmlsZS5maWxlTmFtZSwgbW9kdWxlU3ltYm9sKTtcbiAgfVxuXG4gIGluc2VydEFkZGl0aW9uYWxJbXBvcnRzKHNvdXJjZUZpbGU6IHRzLlNvdXJjZUZpbGUpIHtcbiAgICBsZXQgaW5zZXJ0aW9uID0gMDtcbiAgICAvLyBTa2lwIG92ZXIgYSBsZWFkaW5nIGZpbGUgY29tbWVudCBob2xkZXIuXG4gICAgaWYgKHNvdXJjZUZpbGUuc3RhdGVtZW50cy5sZW5ndGggJiZcbiAgICAgICAgc291cmNlRmlsZS5zdGF0ZW1lbnRzWzBdLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuTm90RW1pdHRlZFN0YXRlbWVudCkge1xuICAgICAgaW5zZXJ0aW9uKys7XG4gICAgfVxuICAgIHJldHVybiB0cy51cGRhdGVTb3VyY2VGaWxlTm9kZShzb3VyY2VGaWxlLCBbXG4gICAgICAuLi5zb3VyY2VGaWxlLnN0YXRlbWVudHMuc2xpY2UoMCwgaW5zZXJ0aW9uKSxcbiAgICAgIC4uLnRoaXMuYWRkaXRpb25hbEltcG9ydHMsXG4gICAgICAuLi5zb3VyY2VGaWxlLnN0YXRlbWVudHMuc2xpY2UoaW5zZXJ0aW9uKSxcbiAgICBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW5kIHN5bnRoZXNpemVzIGNvbW1lbnRzIG9uIG5vZGUsIGFuZCByZXR1cm5zIHRoZSBKU0RvYyBmcm9tIGl0LCBpZiBhbnkuXG4gICAqIEBwYXJhbSByZXBvcnRXYXJuaW5ncyBpZiB0cnVlLCB3aWxsIHJlcG9ydCB3YXJuaW5ncyBmcm9tIHBhcnNpbmcgdGhlIEpTRG9jLiBTZXQgdG8gZmFsc2UgaWZcbiAgICogICAgIHRoaXMgaXMgbm90IHRoZSBcIm1haW5cIiBsb2NhdGlvbiBkZWFsaW5nIHdpdGggYSBub2RlIHRvIGF2b2lkIGR1cGxpY2F0ZWQgd2FybmluZ3MuXG4gICAqL1xuICBnZXRKU0RvYyhub2RlOiB0cy5Ob2RlLCByZXBvcnRXYXJuaW5nczogYm9vbGVhbik6IGpzZG9jLlRhZ1tdIHtcbiAgICBjb25zdCBbdGFncywgXSA9IHRoaXMucGFyc2VKU0RvYyhub2RlLCByZXBvcnRXYXJuaW5ncyk7XG4gICAgcmV0dXJuIHRhZ3M7XG4gIH1cblxuICBnZXRNdXRhYmxlSlNEb2Mobm9kZTogdHMuTm9kZSk6IE11dGFibGVKU0RvYyB7XG4gICAgY29uc3QgW3RhZ3MsIGNvbW1lbnRdID0gdGhpcy5wYXJzZUpTRG9jKG5vZGUsIC8qIHJlcG9ydFdhcm5pbmdzICovIHRydWUpO1xuICAgIHJldHVybiBuZXcgTXV0YWJsZUpTRG9jKG5vZGUsIGNvbW1lbnQsIHRhZ3MpO1xuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZUpTRG9jKG5vZGU6IHRzLk5vZGUsIHJlcG9ydFdhcm5pbmdzOiBib29sZWFuKTpcbiAgICAgIFtqc2RvYy5UYWdbXSwgdHMuU3ludGhlc2l6ZWRDb21tZW50fG51bGxdIHtcbiAgICAvLyBzeW50aGVzaXplTGVhZGluZ0NvbW1lbnRzIGJlbG93IGNoYW5nZXMgdGV4dCBsb2NhdGlvbnMgZm9yIG5vZGUsIHNvIGV4dHJhY3QgdGhlIGxvY2F0aW9uIGhlcmVcbiAgICAvLyBpbiBjYXNlIGl0IGlzIG5lZWRlZCBsYXRlciB0byByZXBvcnQgZGlhZ25vc3RpY3MuXG4gICAgY29uc3Qgc3RhcnQgPSBub2RlLmdldEZ1bGxTdGFydCgpO1xuICAgIGNvbnN0IGxlbmd0aCA9IG5vZGUuZ2V0TGVhZGluZ1RyaXZpYVdpZHRoKHRoaXMuc291cmNlRmlsZSk7XG5cbiAgICBjb25zdCBjb21tZW50cyA9IGpzZG9jLnN5bnRoZXNpemVMZWFkaW5nQ29tbWVudHMobm9kZSk7XG4gICAgaWYgKCFjb21tZW50cyB8fCBjb21tZW50cy5sZW5ndGggPT09IDApIHJldHVybiBbW10sIG51bGxdO1xuXG4gICAgZm9yIChsZXQgaSA9IGNvbW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBjb21tZW50ID0gY29tbWVudHNbaV07XG4gICAgICBjb25zdCBwYXJzZWQgPSBqc2RvYy5wYXJzZShjb21tZW50KTtcbiAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgaWYgKHJlcG9ydFdhcm5pbmdzICYmIHBhcnNlZC53YXJuaW5ncykge1xuICAgICAgICAgIGNvbnN0IHJhbmdlID0gY29tbWVudC5vcmlnaW5hbFJhbmdlIHx8IHtwb3M6IHN0YXJ0LCBlbmQ6IHN0YXJ0ICsgbGVuZ3RofTtcbiAgICAgICAgICByZXBvcnREaWFnbm9zdGljKFxuICAgICAgICAgICAgICB0aGlzLmRpYWdub3N0aWNzLCBub2RlLCBwYXJzZWQud2FybmluZ3Muam9pbignXFxuJyksIHJhbmdlLFxuICAgICAgICAgICAgICB0cy5EaWFnbm9zdGljQ2F0ZWdvcnkuV2FybmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtwYXJzZWQudGFncywgY29tbWVudF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbW10sIG51bGxdO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIGpzZG9jIGZvciBtZXRob2RzLCBpbmNsdWRpbmcgb3ZlcmxvYWRzLlxuICAgKiBJZiBvdmVybG9hZGVkLCBtZXJnZXMgdGhlIHNpZ25hdHVyZXMgaW4gdGhlIGxpc3Qgb2YgU2lnbmF0dXJlRGVjbGFyYXRpb25zIGludG8gYSBzaW5nbGUganNkb2MuXG4gICAqIC0gVG90YWwgbnVtYmVyIG9mIHBhcmFtZXRlcnMgd2lsbCBiZSB0aGUgbWF4aW11bSBjb3VudCBmb3VuZCBhY3Jvc3MgYWxsIHZhcmlhbnRzLlxuICAgKiAtIERpZmZlcmVudCBuYW1lcyBhdCB0aGUgc2FtZSBwYXJhbWV0ZXIgaW5kZXggd2lsbCBiZSBqb2luZWQgd2l0aCBcIl9vcl9cIlxuICAgKiAtIFZhcmlhYmxlIGFyZ3MgKC4uLnR5cGVbXSBpbiBUeXBlU2NyaXB0KSB3aWxsIGJlIG91dHB1dCBhcyBcIi4uLnR5cGVcIixcbiAgICogICAgZXhjZXB0IGlmIGZvdW5kIGF0IHRoZSBzYW1lIGluZGV4IGFzIGFub3RoZXIgYXJndW1lbnQuXG4gICAqIEBwYXJhbSBmbkRlY2xzIFBhc3MgPiAxIGRlY2xhcmF0aW9uIGZvciBvdmVybG9hZHMgb2Ygc2FtZSBuYW1lXG4gICAqIEByZXR1cm4gVGhlIGxpc3Qgb2YgcGFyYW1ldGVyIG5hbWVzIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZW1pdCB0aGUgYWN0dWFsXG4gICAqICAgIGZ1bmN0aW9uIHN0YXRlbWVudDsgZm9yIG92ZXJsb2FkcywgbmFtZSB3aWxsIGhhdmUgYmVlbiBtZXJnZWQuXG4gICAqL1xuICBnZXRGdW5jdGlvblR5cGVKU0RvYyhmbkRlY2xzOiB0cy5TaWduYXR1cmVEZWNsYXJhdGlvbltdLCBleHRyYVRhZ3M6IGpzZG9jLlRhZ1tdID0gW10pOlxuICAgICAge3RhZ3M6IGpzZG9jLlRhZ1tdLCBwYXJhbWV0ZXJOYW1lczogc3RyaW5nW10sIHRoaXNSZXR1cm5UeXBlOiB0cy5UeXBlfG51bGx9IHtcbiAgICBjb25zdCB0eXBlQ2hlY2tlciA9IHRoaXMudHlwZUNoZWNrZXI7XG5cbiAgICAvLyBEZS1kdXBsaWNhdGUgdGFncyBhbmQgZG9jcyBmb3VuZCBmb3IgdGhlIGZuRGVjbHMuXG4gICAgY29uc3QgdGFnc0J5TmFtZSA9IG5ldyBNYXA8c3RyaW5nLCBqc2RvYy5UYWc+KCk7XG4gICAgZnVuY3Rpb24gYWRkVGFnKHRhZzoganNkb2MuVGFnKSB7XG4gICAgICBjb25zdCBleGlzdGluZyA9IHRhZ3NCeU5hbWUuZ2V0KHRhZy50YWdOYW1lKTtcbiAgICAgIHRhZ3NCeU5hbWUuc2V0KHRhZy50YWdOYW1lLCBleGlzdGluZyA/IGpzZG9jLm1lcmdlKFtleGlzdGluZywgdGFnXSkgOiB0YWcpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGV4dHJhVGFnIG9mIGV4dHJhVGFncykgYWRkVGFnKGV4dHJhVGFnKTtcblxuICAgIGNvbnN0IGlzQ29uc3RydWN0b3IgPSBmbkRlY2xzLmZpbmQoZCA9PiBkLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuQ29uc3RydWN0b3IpICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gRm9yIGVhY2ggcGFyYW1ldGVyIGluZGV4IGksIHBhcmFtVGFnc1tpXSBpcyBhbiBhcnJheSBvZiBwYXJhbWV0ZXJzXG4gICAgLy8gdGhhdCBjYW4gYmUgZm91bmQgYXQgaW5kZXggaS4gIEUuZy5cbiAgICAvLyAgICBmdW5jdGlvbiBmb28oeDogc3RyaW5nKVxuICAgIC8vICAgIGZ1bmN0aW9uIGZvbyh5OiBudW1iZXIsIHo6IHN0cmluZylcbiAgICAvLyB0aGVuIHBhcmFtVGFnc1swXSA9IFtpbmZvIGFib3V0IHgsIGluZm8gYWJvdXQgeV0uXG4gICAgY29uc3QgcGFyYW1UYWdzOiBqc2RvYy5UYWdbXVtdID0gW107XG4gICAgY29uc3QgcmV0dXJuVGFnczoganNkb2MuVGFnW10gPSBbXTtcbiAgICBjb25zdCB0aGlzVGFnczoganNkb2MuVGFnW10gPSBbXTtcbiAgICBjb25zdCB0eXBlUGFyYW1ldGVyTmFtZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAgIGNvbnN0IGFyZ0NvdW50cyA9IFtdO1xuICAgIGxldCB0aGlzUmV0dXJuVHlwZTogdHMuVHlwZXxudWxsID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGZuRGVjbCBvZiBmbkRlY2xzKSB7XG4gICAgICAvLyBDb25zdHJ1Y3QgdGhlIEpTRG9jIGNvbW1lbnQgYnkgcmVhZGluZyB0aGUgZXhpc3RpbmcgSlNEb2MsIGlmXG4gICAgICAvLyBhbnksIGFuZCBtZXJnaW5nIGl0IHdpdGggdGhlIGtub3duIHR5cGVzIG9mIHRoZSBmdW5jdGlvblxuICAgICAgLy8gcGFyYW1ldGVycyBhbmQgcmV0dXJuIHR5cGUuXG4gICAgICBjb25zdCB0YWdzID0gdGhpcy5nZXRKU0RvYyhmbkRlY2wsIC8qIHJlcG9ydFdhcm5pbmdzICovIGZhbHNlKTtcblxuICAgICAgLy8gQ29weSBhbGwgdGhlIHRhZ3Mgb3RoZXIgdGhhbiBAcGFyYW0vQHJldHVybiBpbnRvIHRoZSBuZXdcbiAgICAgIC8vIEpTRG9jIHdpdGhvdXQgYW55IGNoYW5nZTsgQHBhcmFtL0ByZXR1cm4gYXJlIGhhbmRsZWQgc3BlY2lhbGx5LlxuICAgICAgLy8gVE9ETzogdGhlcmUgbWF5IGJlIHByb2JsZW1zIGlmIGFuIGFubm90YXRpb24gZG9lc24ndCBhcHBseSB0byBhbGwgb3ZlcmxvYWRzO1xuICAgICAgLy8gaXMgaXQgd29ydGggY2hlY2tpbmcgZm9yIHRoaXMgYW5kIGVycm9yaW5nP1xuICAgICAgZm9yIChjb25zdCB0YWcgb2YgdGFncykge1xuICAgICAgICBpZiAodGFnLnRhZ05hbWUgPT09ICdwYXJhbScgfHwgdGFnLnRhZ05hbWUgPT09ICdyZXR1cm4nKSBjb250aW51ZTtcbiAgICAgICAgYWRkVGFnKHRhZyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZsYWdzID0gdHMuZ2V0Q29tYmluZWRNb2RpZmllckZsYWdzKGZuRGVjbCk7XG4gICAgICAvLyBBZGQgQGFic3RyYWN0IG9uIFwiYWJzdHJhY3RcIiBkZWNsYXJhdGlvbnMuXG4gICAgICBpZiAoZmxhZ3MgJiB0cy5Nb2RpZmllckZsYWdzLkFic3RyYWN0KSB7XG4gICAgICAgIGFkZFRhZyh7dGFnTmFtZTogJ2Fic3RyYWN0J30pO1xuICAgICAgfVxuICAgICAgLy8gQWRkIEBwcm90ZWN0ZWQvQHByaXZhdGUgaWYgcHJlc2VudC5cbiAgICAgIGlmIChmbGFncyAmIHRzLk1vZGlmaWVyRmxhZ3MuUHJvdGVjdGVkKSB7XG4gICAgICAgIGFkZFRhZyh7dGFnTmFtZTogJ3Byb3RlY3RlZCd9KTtcbiAgICAgIH0gZWxzZSBpZiAoZmxhZ3MgJiB0cy5Nb2RpZmllckZsYWdzLlByaXZhdGUpIHtcbiAgICAgICAgYWRkVGFnKHt0YWdOYW1lOiAncHJpdmF0ZSd9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGFueSBAdGVtcGxhdGUgdGFncy5cbiAgICAgIC8vIE11bHRpcGxlIGRlY2xhcmF0aW9ucyB3aXRoIHRoZSBzYW1lIHRlbXBsYXRlIHZhcmlhYmxlIG5hbWVzIHNob3VsZCB3b3JrOlxuICAgICAgLy8gdGhlIGRlY2xhcmF0aW9ucyBnZXQgdHVybmVkIGludG8gdW5pb24gdHlwZXMsIGFuZCBDbG9zdXJlIENvbXBpbGVyIHdpbGwgbmVlZFxuICAgICAgLy8gdG8gZmluZCBhIHVuaW9uIHdoZXJlIGFsbCB0eXBlIGFyZ3VtZW50cyBhcmUgc2F0aXNmaWVkLlxuICAgICAgaWYgKGZuRGVjbC50eXBlUGFyYW1ldGVycykge1xuICAgICAgICBmb3IgKGNvbnN0IHRwIG9mIGZuRGVjbC50eXBlUGFyYW1ldGVycykge1xuICAgICAgICAgIHR5cGVQYXJhbWV0ZXJOYW1lcy5hZGQoZ2V0SWRlbnRpZmllclRleHQodHAubmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBNZXJnZSB0aGUgcGFyYW1ldGVycyBpbnRvIGEgc2luZ2xlIGxpc3Qgb2YgbWVyZ2VkIG5hbWVzIGFuZCBsaXN0IG9mIHR5cGVzXG4gICAgICBjb25zdCBzaWcgPSB0eXBlQ2hlY2tlci5nZXRTaWduYXR1cmVGcm9tRGVjbGFyYXRpb24oZm5EZWNsKTtcbiAgICAgIGlmICghc2lnIHx8ICFzaWcuZGVjbGFyYXRpb24pIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBzaWduYXR1cmUgJHtmbkRlY2wubmFtZX1gKTtcbiAgICAgIGlmIChzaWcuZGVjbGFyYXRpb24ua2luZCA9PT0gdHMuU3ludGF4S2luZC5KU0RvY1NpZ25hdHVyZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEpTRG9jIHNpZ25hdHVyZSAke2ZuRGVjbC5uYW1lfWApO1xuICAgICAgfVxuICAgICAgbGV0IGhhc1RoaXNQYXJhbSA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWcuZGVjbGFyYXRpb24ucGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJhbU5vZGUgPSBzaWcuZGVjbGFyYXRpb24ucGFyYW1ldGVyc1tpXTtcblxuICAgICAgICBjb25zdCBuYW1lID0gZ2V0UGFyYW1ldGVyTmFtZShwYXJhbU5vZGUsIGkpO1xuICAgICAgICBjb25zdCBpc1RoaXNQYXJhbSA9IG5hbWUgPT09ICd0aGlzJztcbiAgICAgICAgaWYgKGlzVGhpc1BhcmFtKSBoYXNUaGlzUGFyYW0gPSB0cnVlO1xuXG4gICAgICAgIGNvbnN0IG5ld1RhZzoganNkb2MuVGFnID0ge1xuICAgICAgICAgIHRhZ05hbWU6IGlzVGhpc1BhcmFtID8gJ3RoaXMnIDogJ3BhcmFtJyxcbiAgICAgICAgICBvcHRpb25hbDogcGFyYW1Ob2RlLmluaXRpYWxpemVyICE9PSB1bmRlZmluZWQgfHwgcGFyYW1Ob2RlLnF1ZXN0aW9uVG9rZW4gIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICBwYXJhbWV0ZXJOYW1lOiBpc1RoaXNQYXJhbSA/IHVuZGVmaW5lZCA6IG5hbWUsXG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlQ2hlY2tlci5nZXRUeXBlQXRMb2NhdGlvbihwYXJhbU5vZGUpO1xuICAgICAgICBpZiAocGFyYW1Ob2RlLmRvdERvdERvdFRva2VuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBuZXdUYWcucmVzdFBhcmFtID0gdHJ1ZTtcbiAgICAgICAgICAvLyBJbiBUeXBlU2NyaXB0IHlvdSB3cml0ZSBcIi4uLng6IG51bWJlcltdXCIsIGJ1dCBpbiBDbG9zdXJlXG4gICAgICAgICAgLy8geW91IGRvbid0IHdyaXRlIHRoZSBhcnJheTogXCJAcGFyYW0gey4uLm51bWJlcn0geFwiLiAgVW53cmFwXG4gICAgICAgICAgLy8gdGhlIEFycmF5PD4gd3JhcHBlci5cbiAgICAgICAgICBpZiAoKHR5cGUuZmxhZ3MgJiB0cy5UeXBlRmxhZ3MuT2JqZWN0KSA9PT0gMCAmJiB0eXBlLmZsYWdzICYgdHMuVHlwZUZsYWdzLlR5cGVQYXJhbWV0ZXIpIHtcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uIGY8VCBleHRlbmRzIHN0cmluZ1tdPiguLi50czogVCkgaGFzIHRoZSBBcnJheSB0eXBlIG9uIHRoZSB0eXBlIHBhcmFtZXRlclxuICAgICAgICAgICAgLy8gY29uc3RyYWludCwgbm90IG9uIHRoZSBwYXJhbWV0ZXIgaXRzZWxmLiBSZXNvbHZlIGl0LlxuICAgICAgICAgICAgY29uc3QgYmFzZUNvbnN0cmFpbnQgPSB0eXBlQ2hlY2tlci5nZXRCYXNlQ29uc3RyYWludE9mVHlwZSh0eXBlKTtcbiAgICAgICAgICAgIGlmIChiYXNlQ29uc3RyYWludCkgdHlwZSA9IGJhc2VDb25zdHJhaW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZS5mbGFncyAmIHRzLlR5cGVGbGFncy5PYmplY3QgJiZcbiAgICAgICAgICAgICAgKHR5cGUgYXMgdHMuT2JqZWN0VHlwZSkub2JqZWN0RmxhZ3MgJiB0cy5PYmplY3RGbGFncy5SZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVSZWYgPSB0eXBlIGFzIHRzLlR5cGVSZWZlcmVuY2U7XG4gICAgICAgICAgICBpZiAoIXR5cGVSZWYudHlwZUFyZ3VtZW50cykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc3QgcGFyYW1ldGVyIGRvZXMgbm90IHJlc29sdmUgdG8gYSByZWZlcmVuY2UgdHlwZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZSA9IHR5cGVSZWYudHlwZUFyZ3VtZW50cyFbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld1RhZy50eXBlID0gdGhpcy50eXBlVG9DbG9zdXJlKGZuRGVjbCwgdHlwZSk7XG5cbiAgICAgICAgZm9yIChjb25zdCB7dGFnTmFtZSwgcGFyYW1ldGVyTmFtZSwgdGV4dH0gb2YgdGFncykge1xuICAgICAgICAgIGlmICh0YWdOYW1lID09PSAncGFyYW0nICYmIHBhcmFtZXRlck5hbWUgPT09IG5ld1RhZy5wYXJhbWV0ZXJOYW1lKSB7XG4gICAgICAgICAgICBuZXdUYWcudGV4dCA9IHRleHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1RoaXNQYXJhbSkge1xuICAgICAgICAgIGNvbnN0IHBhcmFtSWR4ID0gaGFzVGhpc1BhcmFtID8gaSAtIDEgOiBpO1xuICAgICAgICAgIGlmICghcGFyYW1UYWdzW3BhcmFtSWR4XSkgcGFyYW1UYWdzLnB1c2goW10pO1xuICAgICAgICAgIHBhcmFtVGFnc1twYXJhbUlkeF0ucHVzaChuZXdUYWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNUYWdzLnB1c2gobmV3VGFnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXJnQ291bnRzLnB1c2goXG4gICAgICAgICAgaGFzVGhpc1BhcmFtID8gc2lnLmRlY2xhcmF0aW9uLnBhcmFtZXRlcnMubGVuZ3RoIC0gMSA6IHNpZy5kZWNsYXJhdGlvbi5wYXJhbWV0ZXJzLmxlbmd0aCk7XG5cbiAgICAgIC8vIFJldHVybiB0eXBlLlxuICAgICAgaWYgKCFpc0NvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNvbnN0IHJldHVyblRhZzoganNkb2MuVGFnID0ge1xuICAgICAgICAgIHRhZ05hbWU6ICdyZXR1cm4nLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXRUeXBlID0gdHlwZUNoZWNrZXIuZ2V0UmV0dXJuVHlwZU9mU2lnbmF0dXJlKHNpZyk7XG4gICAgICAgIC8vIEdlbmVyYXRlIGEgdGVtcGxhdGVkIGBAdGhpc2AgdGFnIGZvciBUeXBlU2NyaXB0IGBmb28oKTogdGhpc2AgcmV0dXJuIHR5cGUgc3BlY2lmaWNhdGlvbi5cbiAgICAgICAgLy8gTWFrZSBzdXJlIG5vdCB0byBkbyB0aGF0IGlmIHRoZSBmdW5jdGlvbiBhbHJlYWR5IGhhcyB1c2VkIGBAdGhpc2AgZHVlIHRvIGEgdGhpc1xuICAgICAgICAvLyBwYXJhbWV0ZXIuIEl0J3Mgbm90IGNsZWFyIGhvdyB0byByZXNvbHZlIHRoZSB0d28gY29uZmxpY3RpbmcgdGhpcyB0eXBlcyBiZXN0LCB0aGUgY3VycmVudFxuICAgICAgICAvLyBzb2x1dGlvbiBwcmVmZXJzIHRoZSBleHBsaWNpdGx5IGdpdmVuIGB0aGlzYCBwYXJhbWV0ZXIuXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnkgYWNjZXNzaW5nIFRTIGludGVybmFsIGZpZWxkLlxuICAgICAgICBpZiAoKHJldFR5cGUgYXMgYW55KS5pc1RoaXNUeXBlICYmICFoYXNUaGlzUGFyYW0pIHtcbiAgICAgICAgICAvLyBmb28oKTogdGhpc1xuICAgICAgICAgIHRoaXNSZXR1cm5UeXBlID0gcmV0VHlwZTtcbiAgICAgICAgICBhZGRUYWcoe3RhZ05hbWU6ICd0ZW1wbGF0ZScsIHRleHQ6ICdUSElTJ30pO1xuICAgICAgICAgIGFkZFRhZyh7dGFnTmFtZTogJ3RoaXMnLCB0eXBlOiAnVEhJUyd9KTtcbiAgICAgICAgICByZXR1cm5UYWcudHlwZSA9ICdUSElTJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm5UYWcudHlwZSA9IHRoaXMudHlwZVRvQ2xvc3VyZShmbkRlY2wsIHJldFR5cGUpO1xuICAgICAgICAgIGZvciAoY29uc3Qge3RhZ05hbWUsIHRleHR9IG9mIHRhZ3MpIHtcbiAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAncmV0dXJuJykge1xuICAgICAgICAgICAgICByZXR1cm5UYWcudGV4dCA9IHRleHQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm5UYWdzLnB1c2gocmV0dXJuVGFnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZVBhcmFtZXRlck5hbWVzLnNpemUgPiAwKSB7XG4gICAgICBhZGRUYWcoe3RhZ05hbWU6ICd0ZW1wbGF0ZScsIHRleHQ6IEFycmF5LmZyb20odHlwZVBhcmFtZXRlck5hbWVzLnZhbHVlcygpKS5qb2luKCcsICcpfSk7XG4gICAgfVxuXG4gICAgY29uc3QgbmV3RG9jID0gQXJyYXkuZnJvbSh0YWdzQnlOYW1lLnZhbHVlcygpKTtcblxuICAgIGlmICh0aGlzVGFncy5sZW5ndGggPiAwKSB7XG4gICAgICBuZXdEb2MucHVzaChqc2RvYy5tZXJnZSh0aGlzVGFncykpO1xuICAgIH1cblxuICAgIGNvbnN0IG1pbkFyZ3NDb3VudCA9IE1hdGgubWluKC4uLmFyZ0NvdW50cyk7XG4gICAgY29uc3QgbWF4QXJnc0NvdW50ID0gTWF0aC5tYXgoLi4uYXJnQ291bnRzKTtcblxuICAgIC8vIE1lcmdlIHRoZSBKU0RvYyB0YWdzIGZvciBlYWNoIG92ZXJsb2FkZWQgcGFyYW1ldGVyLlxuICAgIC8vIEVuc3VyZSBlYWNoIHBhcmFtZXRlciBoYXMgYSB1bmlxdWUgbmFtZTsgdGhlIG1lcmdpbmcgcHJvY2VzcyBjYW4gb3RoZXJ3aXNlXG4gICAgLy8gYWNjaWRlbnRhbGx5IGdlbmVyYXRlIHRoZSBzYW1lIHBhcmFtZXRlciBuYW1lIHR3aWNlLlxuICAgIGNvbnN0IHBhcmFtTmFtZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBsZXQgZm91bmRPcHRpb25hbCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4QXJnc0NvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcmFtVGFnID0ganNkb2MubWVyZ2UocGFyYW1UYWdzW2ldKTtcbiAgICAgIGlmIChwYXJhbVRhZy5wYXJhbWV0ZXJOYW1lKSB7XG4gICAgICAgIGlmIChwYXJhbU5hbWVzLmhhcyhwYXJhbVRhZy5wYXJhbWV0ZXJOYW1lKSkge1xuICAgICAgICAgIHBhcmFtVGFnLnBhcmFtZXRlck5hbWUgKz0gaS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtTmFtZXMuYWRkKHBhcmFtVGFnLnBhcmFtZXRlck5hbWUpO1xuICAgICAgfVxuICAgICAgLy8gSWYgdGhlIHRhZyBpcyBvcHRpb25hbCwgbWFyayBwYXJhbWV0ZXJzIGZvbGxvd2luZyBvcHRpb25hbCBhcyBvcHRpb25hbCxcbiAgICAgIC8vIGV2ZW4gaWYgdGhleSBhcmUgbm90LCBzaW5jZSBDbG9zdXJlIHJlc3RyaWN0cyB0aGlzLCBzZWVcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1jb21waWxlci9pc3N1ZXMvMjMxNFxuICAgICAgaWYgKCFwYXJhbVRhZy5yZXN0UGFyYW0gJiYgKHBhcmFtVGFnLm9wdGlvbmFsIHx8IGZvdW5kT3B0aW9uYWwgfHwgaSA+PSBtaW5BcmdzQ291bnQpKSB7XG4gICAgICAgIGZvdW5kT3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICBwYXJhbVRhZy5vcHRpb25hbCA9IHRydWU7XG4gICAgICB9XG4gICAgICBuZXdEb2MucHVzaChwYXJhbVRhZyk7XG4gICAgICBpZiAocGFyYW1UYWcucmVzdFBhcmFtKSB7XG4gICAgICAgIC8vIENhbm5vdCBoYXZlIGFueSBwYXJhbWV0ZXJzIGFmdGVyIGEgcmVzdCBwYXJhbS5cbiAgICAgICAgLy8gSnVzdCBkdW1wIHRoZSByZW1haW5pbmcgcGFyYW1ldGVycy5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWVyZ2UgdGhlIEpTRG9jIHRhZ3MgZm9yIGVhY2ggb3ZlcmxvYWRlZCByZXR1cm4uXG4gICAgaWYgKCFpc0NvbnN0cnVjdG9yKSB7XG4gICAgICBuZXdEb2MucHVzaChqc2RvYy5tZXJnZShyZXR1cm5UYWdzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRhZ3M6IG5ld0RvYyxcbiAgICAgIHBhcmFtZXRlck5hbWVzOiBuZXdEb2MuZmlsdGVyKHQgPT4gdC50YWdOYW1lID09PSAncGFyYW0nKS5tYXAodCA9PiB0LnBhcmFtZXRlck5hbWUhKSxcbiAgICAgIHRoaXNSZXR1cm5UeXBlLFxuICAgIH07XG4gIH1cbn1cbiJdfQ==