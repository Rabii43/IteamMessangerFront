/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/externs", ["require", "exports", "typescript", "tsickle/src/annotator_host", "tsickle/src/enum_transformer", "tsickle/src/googmodule", "tsickle/src/jsdoc", "tsickle/src/jsdoc_transformer", "tsickle/src/module_type_translator", "tsickle/src/path", "tsickle/src/transformer_util", "tsickle/src/type_translator"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @fileoverview Externs creates Closure Compiler #externs definitions from the
     * ambient declarations in a TypeScript file.
     *
     * (Note that we cannot write the "@" form of the externs tag, even in comments,
     * because the compiler greps for it in source files(!).  So we write #externs
     * instead.)
     *
     * For example, a
     *   declare interface Foo { bar: string; }
     *
     * Would generate a
     *   /.. #externs ./
     *   /.. @record ./
     *   var Foo = function() {};
     *   /.. @type {string} ./
     *   Foo.prototype.bar;
     *
     * The generated externs indicate to Closure Compiler that symbols are external
     * to the optimization process, i.e. they are provided by outside code. That
     * most importantly means they must not be renamed or removed.
     *
     * A major difficulty here is that TypeScript supports module-scoped external
     * symbols; `.d.ts` files can contain `export`s and `import` other files.
     * Closure Compiler does not have such a concept, so tsickle must emulate the
     * behaviour. It does so by following this scheme:
     *
     * 1. non-module .d.ts produces global symbols
     * 2. module .d.ts produce symbols namespaced to the module, by creating a
     *    mangled name matching the current file's path. tsickle expects outside
     *    code (e.g. build system integration or manually written code) to contain a
     *    goog.module/provide that references the mangled path.
     * 3. declarations in `.ts` files produce types that can be separately emitted
     *    in e.g. an `externs.js`, using `getGeneratedExterns` below.
     *    1. non-exported symbols produce global types, because that's what users
     *       expect and it matches TypeScripts emit, which just references `Foo` for
     *       a locally declared symbol `Foo` in a module. Arguably these should be
     *       wrapped in `declare global { ... }`.
     *    2. exported symbols are scoped to the `.ts` file by prefixing them with a
     *       mangled name. Exported types are re-exported from the JavaScript
     *       `goog.module`, allowing downstream code to reference them. This has the
     *       same problem regarding ambient values as above, it is unclear where the
     *       value symbol would be defined, so for the time being this is
     *       unsupported.
     *
     * The effect of this is that:
     * - symbols in a module (i.e. not globals) are generally scoped to the local
     *   module using a mangled name, preventing symbol collisions on the Closure
     *   side.
     * - importing code can unconditionally refer to and import any symbol defined
     *   in a module `X` as `path.to.module.X`, regardless of whether the defining
     *   location is a `.d.ts` file or a `.ts` file, and regardless whether the
     *   symbol is ambient (assuming there's an appropriate shim).
     * - if there is a shim present, tsickle avoids emitting the Closure namespace
     *   itself, expecting the shim to provide the namespace and initialize it to a
     *   symbol that provides the right value at runtime (i.e. the implementation of
     *   whatever third party library the .d.ts describes).
     */
    const ts = require("typescript");
    const annotator_host_1 = require("tsickle/src/annotator_host");
    const enum_transformer_1 = require("tsickle/src/enum_transformer");
    const googmodule_1 = require("tsickle/src/googmodule");
    const jsdoc = require("tsickle/src/jsdoc");
    const jsdoc_transformer_1 = require("tsickle/src/jsdoc_transformer");
    const module_type_translator_1 = require("tsickle/src/module_type_translator");
    const path = require("tsickle/src/path");
    const transformer_util_1 = require("tsickle/src/transformer_util");
    const type_translator_1 = require("tsickle/src/type_translator");
    /**
     * Symbols that are already declared as externs in Closure, that should
     * be avoided by tsickle's "declare ..." => externs.js conversion.
     */
    const CLOSURE_EXTERNS_BLACKLIST = [
        'exports',
        'global',
        'module',
        // ErrorConstructor is the interface of the Error object itself.
        // tsickle detects that this is part of the TypeScript standard library
        // and assumes it's part of the Closure standard library, but this
        // assumption is wrong for ErrorConstructor.  To properly handle this
        // we'd somehow need to map methods defined on the ErrorConstructor
        // interface into properties on Closure's Error object, but for now it's
        // simpler to just blacklist it.
        'ErrorConstructor',
        'Symbol',
        'WorkerGlobalScope',
    ];
    /**
     * The header to be used in generated externs.  This is not included in the output of
     * generateExterns() because generateExterns() works one file at a time, and typically you create
     * one externs file from the entire compilation unit.
     *
     * Suppressions:
     * - duplicate: because externs might duplicate re-opened definitions from other JS files.
     * - checkTypes: Closure's type system does not match TS'.
     * - undefinedNames: code below tries to be careful not to overwrite previously emitted definitions,
     *   but on the flip side might accidentally miss definitions.
     */
    const EXTERNS_HEADER = `/**
 * @${''}externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
`;
    /**
     * Concatenate all generated externs definitions together into a string, including a file comment
     * header.
     *
     * @param rootDir Project root.  Emitted comments will reference paths relative to this root.
     *    This param is effectively required, but made optional here until Angular is fixed.
     */
    function getGeneratedExterns(externs, rootDir = '') {
        let allExterns = EXTERNS_HEADER;
        for (const fileName of Object.keys(externs)) {
            allExterns += `// externs from ${path.relative(rootDir, fileName)}:\n`;
            allExterns += externs[fileName];
        }
        return allExterns;
    }
    exports.getGeneratedExterns = getGeneratedExterns;
    /**
     * isInGlobalAugmentation returns true if declaration is the immediate child of a 'declare global'
     * block.
     */
    function isInGlobalAugmentation(declaration) {
        // declare global { ... } creates a ModuleDeclaration containing a ModuleBlock containing the
        // declaration, with the ModuleDeclaration having the GlobalAugmentation flag set.
        if (!declaration.parent || !declaration.parent.parent)
            return false;
        return (declaration.parent.parent.flags & ts.NodeFlags.GlobalAugmentation) !== 0;
    }
    /**
     * generateExterns generates extern definitions for all ambient declarations in the given source
     * file. It returns a string representation of the Closure JavaScript, not including the initial
     * comment with \@fileoverview and #externs (see above for that).
     */
    function generateExterns(typeChecker, sourceFile, host, moduleResolutionHost, options) {
        let output = '';
        const diagnostics = [];
        const isDts = transformer_util_1.isDtsFileName(sourceFile.fileName);
        const isExternalModule = ts.isExternalModule(sourceFile);
        const mtt = new module_type_translator_1.ModuleTypeTranslator(sourceFile, typeChecker, host, diagnostics, /*isForExterns*/ true);
        let rootNamespace = '';
        if (isExternalModule) {
            // .d.ts files that are modules do not declare global symbols - their symbols must be explicitly
            // imported to be used. However Closure Compiler has no concept of externs that are modules and
            // require imports. This code mangles the symbol names by wrapping them in a top level variable
            // that's unique to this file. That allows emitting them for Closure as global symbols while
            // avoiding collisions. This is necessary as symbols local to this module can (and will very
            // commonly) conflict with the namespace used in "export as namespace", e.g. "angular", and also
            // to avoid users accidentally using these symbols in .js files (and more collisions). The
            // symbols that are "hidden" like that can be made accessible through an "export as namespace"
            // declaration (see below).
            rootNamespace = annotator_host_1.moduleNameAsIdentifier(host, sourceFile.fileName);
        }
        for (const stmt of sourceFile.statements) {
            if (!isDts && !transformer_util_1.hasModifierFlag(stmt, ts.ModifierFlags.Ambient)) {
                continue;
            }
            visitor(stmt, []);
        }
        if (output && isExternalModule) {
            // If tsickle generated any externs and this is an external module, prepend the namespace
            // declaration for it.
            output = `/** @const */\nvar ${rootNamespace} = {};\n` + output;
            // There can only be one export =.
            const exportAssignment = sourceFile.statements.find(ts.isExportAssignment);
            let exportedNamespace = rootNamespace;
            if (exportAssignment && exportAssignment.isExportEquals) {
                if (ts.isIdentifier(exportAssignment.expression) ||
                    ts.isQualifiedName(exportAssignment.expression)) {
                    // E.g. export = someName;
                    // If someName is "declare global { namespace someName {...} }", tsickle must not qualify
                    // access to it with module namespace as it is emitted in the global namespace.
                    const symbol = typeChecker.getSymbolAtLocation(exportAssignment.expression);
                    const isGlobalSymbol = symbol && symbol.declarations &&
                        symbol.declarations.some(d => isInGlobalAugmentation(d));
                    const entityName = transformer_util_1.getEntityNameText(exportAssignment.expression);
                    if (isGlobalSymbol) {
                        exportedNamespace = entityName;
                    }
                    else {
                        exportedNamespace = rootNamespace + '.' + entityName;
                    }
                }
                else {
                    transformer_util_1.reportDiagnostic(diagnostics, exportAssignment.expression, `export = expression must be a qualified name, got ${ts.SyntaxKind[exportAssignment.expression.kind]}.`);
                }
            }
            if (isDts && host.provideExternalModuleDtsNamespace) {
                // In a non-shimmed module, create a global namespace. This exists purely for backwards
                // compatiblity, in the medium term all code using tsickle should always use `goog.module`s,
                // so global names should not be neccessary.
                for (const nsExport of sourceFile.statements.filter(ts.isNamespaceExportDeclaration)) {
                    const namespaceName = transformer_util_1.getIdentifierText(nsExport.name);
                    emit(`// export as namespace ${namespaceName}\n`);
                    writeVariableStatement(namespaceName, [], exportedNamespace);
                }
            }
        }
        return { output, diagnostics };
        function emit(str) {
            output += str;
        }
        /**
         * isFirstDeclaration returns true if decl is the first declaration
         * of its symbol.  E.g. imagine
         *   interface Foo { x: number; }
         *   interface Foo { y: number; }
         * we only want to emit the "\@record" for Foo on the first one.
         *
         * The exception are variable declarations, which - in externs - do not assign a value:
         *   /.. \@type {...} ./
         *   var someVariable;
         *   /.. \@type {...} ./
         *   someNamespace.someVariable;
         * If a later declaration wants to add additional properties on someVariable, tsickle must still
         * emit an assignment into the object, as it's otherwise absent.
         */
        function isFirstValueDeclaration(decl) {
            if (!decl.name)
                return true;
            const sym = typeChecker.getSymbolAtLocation(decl.name);
            if (!sym.declarations || sym.declarations.length < 2)
                return true;
            const earlierDecls = sym.declarations.slice(0, sym.declarations.indexOf(decl));
            // Either there are no earlier declarations, or all of them are variables (see above). tsickle
            // emits a value for all other declaration kinds (function for functions, classes, interfaces,
            // {} object for namespaces).
            return earlierDecls.length === 0 || earlierDecls.every(ts.isVariableDeclaration);
        }
        /** Writes the actual variable statement of a Closure variable declaration. */
        function writeVariableStatement(name, namespace, value) {
            const qualifiedName = namespace.concat([name]).join('.');
            if (namespace.length === 0)
                emit(`var `);
            emit(qualifiedName);
            if (value)
                emit(` = ${value}`);
            emit(';\n');
        }
        /**
         * Writes a Closure variable declaration, i.e. the variable statement with a leading JSDoc
         * comment making it a declaration.
         */
        function writeVariableDeclaration(decl, namespace) {
            if (decl.name.kind === ts.SyntaxKind.Identifier) {
                const name = transformer_util_1.getIdentifierText(decl.name);
                if (CLOSURE_EXTERNS_BLACKLIST.indexOf(name) >= 0)
                    return;
                emit(jsdoc.toString([{ tagName: 'type', type: mtt.typeToClosure(decl) }]));
                emit('\n');
                writeVariableStatement(name, namespace);
            }
            else {
                errorUnimplementedKind(decl.name, 'externs for variable');
            }
        }
        /**
         * Emits a JSDoc declaration that merges the signatures of the given function declaration (for
         * overloads), and returns the parameter names chosen.
         */
        function emitFunctionType(decls, extraTags = []) {
            const { tags, parameterNames } = mtt.getFunctionTypeJSDoc(decls, extraTags);
            emit('\n');
            emit(jsdoc.toString(tags));
            return parameterNames;
        }
        function writeFunction(name, params, namespace) {
            const paramsStr = params.join(', ');
            if (namespace.length > 0) {
                let fqn = namespace.join('.');
                if (name.kind === ts.SyntaxKind.Identifier) {
                    fqn += '.'; // computed names include [ ] in their getText() representation.
                }
                fqn += name.getText();
                emit(`${fqn} = function(${paramsStr}) {};\n`);
            }
            else {
                if (name.kind !== ts.SyntaxKind.Identifier) {
                    transformer_util_1.reportDiagnostic(diagnostics, name, 'Non-namespaced computed name in externs');
                }
                emit(`function ${name.getText()}(${paramsStr}) {}\n`);
            }
        }
        function writeEnum(decl, namespace) {
            // E.g. /** @enum {number} */ var COUNTRY = {US: 1, CA: 1};
            const name = transformer_util_1.getIdentifierText(decl.name);
            let members = '';
            const enumType = enum_transformer_1.getEnumType(typeChecker, decl);
            // Closure enums members must have a value of the correct type, but the actual value does not
            // matter in externs.
            const initializer = enumType === 'string' ? `''` : 1;
            for (const member of decl.members) {
                let memberName;
                switch (member.name.kind) {
                    case ts.SyntaxKind.Identifier:
                        memberName = transformer_util_1.getIdentifierText(member.name);
                        break;
                    case ts.SyntaxKind.StringLiteral:
                        const text = member.name.text;
                        if (type_translator_1.isValidClosurePropertyName(text))
                            memberName = text;
                        break;
                    default:
                        break;
                }
                if (!memberName) {
                    members += `  /* TODO: ${ts.SyntaxKind[member.name.kind]}: ${jsdoc_transformer_1.escapeForComment(member.name.getText())} */\n`;
                    continue;
                }
                members += `  ${memberName}: ${initializer},\n`;
            }
            emit(`\n/** @enum {${enumType}} */\n`);
            writeVariableStatement(name, namespace, `{\n${members}}`);
        }
        function writeTypeAlias(decl, namespace) {
            const typeStr = mtt.typeToClosure(decl, undefined);
            emit(`\n/** @typedef {${typeStr}} */\n`);
            writeVariableStatement(transformer_util_1.getIdentifierText(decl.name), namespace);
        }
        function writeType(decl, namespace) {
            const name = decl.name;
            if (!name) {
                transformer_util_1.reportDiagnostic(diagnostics, decl, 'anonymous type in externs');
                return;
            }
            const typeName = namespace.concat([name.getText()]).join('.');
            if (CLOSURE_EXTERNS_BLACKLIST.indexOf(typeName) >= 0)
                return;
            if (isFirstValueDeclaration(decl)) {
                // Emit the 'function' that is actually the declaration of the interface
                // itself.  If it's a class, this function also must include the type
                // annotations of the constructor.
                let paramNames = [];
                const jsdocTags = [];
                let wroteJsDoc = false;
                jsdoc_transformer_1.maybeAddHeritageClauses(jsdocTags, mtt, decl);
                jsdoc_transformer_1.maybeAddTemplateClause(jsdocTags, decl);
                if (decl.kind === ts.SyntaxKind.ClassDeclaration) {
                    // TODO: it appears you can just write 'class Foo { ...' in externs.
                    // This code instead tries to translate it to a function.
                    jsdocTags.push({ tagName: 'constructor' }, { tagName: 'struct' });
                    const ctors = decl
                        .members.filter((m) => m.kind === ts.SyntaxKind.Constructor);
                    if (ctors.length) {
                        const firstCtor = ctors[0];
                        if (ctors.length > 1) {
                            paramNames = emitFunctionType(ctors, jsdocTags);
                        }
                        else {
                            paramNames = emitFunctionType([firstCtor], jsdocTags);
                        }
                        wroteJsDoc = true;
                    }
                }
                else {
                    // Otherwise it's an interface; tag it as structurally typed.
                    jsdocTags.push({ tagName: 'record' }, { tagName: 'struct' });
                }
                if (!wroteJsDoc)
                    emit(jsdoc.toString(jsdocTags));
                writeFunction(name, paramNames, namespace);
            }
            // Process everything except (MethodSignature|MethodDeclaration|Constructor)
            const methods = new Map();
            for (const member of decl.members) {
                switch (member.kind) {
                    case ts.SyntaxKind.PropertySignature:
                    case ts.SyntaxKind.PropertyDeclaration:
                        const prop = member;
                        if (prop.name.kind === ts.SyntaxKind.Identifier) {
                            let type = mtt.typeToClosure(prop);
                            if (prop.questionToken && type === '?') {
                                // An optional 'any' type translates to '?|undefined' in Closure.
                                type = '?|undefined';
                            }
                            emit(jsdoc.toString([{ tagName: 'type', type }]));
                            if (transformer_util_1.hasModifierFlag(prop, ts.ModifierFlags.Static)) {
                                emit(`\n${typeName}.${prop.name.getText()};\n`);
                            }
                            else {
                                emit(`\n${typeName}.prototype.${prop.name.getText()};\n`);
                            }
                            continue;
                        }
                        // TODO: For now property names other than Identifiers are not handled; e.g.
                        //    interface Foo { "123bar": number }
                        break;
                    case ts.SyntaxKind.MethodSignature:
                    case ts.SyntaxKind.MethodDeclaration:
                        const method = member;
                        const isStatic = transformer_util_1.hasModifierFlag(method, ts.ModifierFlags.Static);
                        const methodSignature = `${method.name.getText()}$$$${isStatic ? 'static' : 'instance'}`;
                        if (methods.has(methodSignature)) {
                            methods.get(methodSignature).push(method);
                        }
                        else {
                            methods.set(methodSignature, [method]);
                        }
                        continue;
                    case ts.SyntaxKind.Constructor:
                        continue; // Handled above.
                    default:
                        // Members can include things like index signatures, for e.g.
                        //   interface Foo { [key: string]: number; }
                        // For now, just skip it.
                        break;
                }
                // If we get here, the member wasn't handled in the switch statement.
                let memberName = namespace;
                if (member.name) {
                    memberName = memberName.concat([member.name.getText()]);
                }
                emit(`\n/* TODO: ${ts.SyntaxKind[member.kind]}: ${memberName.join('.')} */\n`);
            }
            // Handle method declarations/signatures separately, since we need to deal with overloads.
            for (const methodVariants of Array.from(methods.values())) {
                const firstMethodVariant = methodVariants[0];
                let parameterNames;
                if (methodVariants.length > 1) {
                    parameterNames = emitFunctionType(methodVariants);
                }
                else {
                    parameterNames = emitFunctionType([firstMethodVariant]);
                }
                const methodNamespace = namespace.concat([name.getText()]);
                // If the method is static, don't add the prototype.
                if (!transformer_util_1.hasModifierFlag(firstMethodVariant, ts.ModifierFlags.Static)) {
                    methodNamespace.push('prototype');
                }
                writeFunction(firstMethodVariant.name, parameterNames, methodNamespace);
            }
        }
        function writeExportDeclaration(exportDeclaration, namespace) {
            if (!exportDeclaration.exportClause) {
                emit(`\n// TODO(tsickle): export * declaration in ${debugLocationStr(exportDeclaration, namespace)}\n`);
                return;
            }
            for (const exportSpecifier of exportDeclaration.exportClause.elements) {
                // No need to do anything for properties exported under their original name.
                if (!exportSpecifier.propertyName)
                    continue;
                emit('/** @const */\n');
                writeVariableStatement(exportSpecifier.name.text, namespace, namespace.join('.') + '.' + exportSpecifier.propertyName.text);
            }
        }
        /**
         * Adds aliases for the symbols imported in the given declaration, so that their types get
         * printed as the fully qualified name, and not just as a reference to the local import alias.
         *
         * tsickle generates .js files that (at most) contain a `goog.provide`, but are not
         * `goog.module`s. These files cannot express an aliased import. However Closure Compiler allows
         * referencing types using fully qualified names in such files, so tsickle can resolve the
         * imported module URI and produce `path.to.module.Symbol` as an alias, and use that when
         * referencing the type.
         */
        function addImportAliases(decl) {
            let moduleUri;
            if (ts.isImportDeclaration(decl)) {
                moduleUri = decl.moduleSpecifier.text;
            }
            else if (ts.isExternalModuleReference(decl.moduleReference)) {
                // import foo = require('./bar');
                moduleUri = decl.moduleReference.expression.text;
            }
            else {
                // import foo = bar.baz.bam;
                // unsupported.
                return;
            }
            const googNamespace = googmodule_1.extractGoogNamespaceImport(moduleUri);
            const moduleName = googNamespace ||
                host.pathToModuleName(sourceFile.fileName, googmodule_1.resolveModuleName(host, sourceFile.fileName, moduleUri));
            if (ts.isImportEqualsDeclaration(decl)) {
                // import foo = require('./bar');
                addImportAlias(decl.name, moduleName, undefined);
                return;
            }
            // Side effect import, like "import 'somepath';" declares no local aliases.
            if (!decl.importClause)
                return;
            if (decl.importClause.name) {
                // import name from ... -> map to .default on the module.name.
                if (googNamespace) {
                    addImportAlias(decl.importClause.name, googNamespace, undefined);
                }
                else {
                    addImportAlias(decl.importClause.name, moduleName, 'default');
                }
            }
            const namedBindings = decl.importClause.namedBindings;
            if (!namedBindings)
                return;
            if (ts.isNamespaceImport(namedBindings)) {
                // import * as name -> map directly to the module.name.
                addImportAlias(namedBindings.name, moduleName, undefined);
            }
            if (ts.isNamedImports(namedBindings)) {
                // import {A as B}, map to module.name.A
                for (const namedBinding of namedBindings.elements) {
                    addImportAlias(namedBinding.name, moduleName, namedBinding.name);
                }
            }
        }
        /**
         * Adds an import alias for the symbol defined at the given node. Creates an alias name based on
         * the given moduleName and (optionally) the name.
         */
        function addImportAlias(node, moduleName, name) {
            let symbol = typeChecker.getSymbolAtLocation(node);
            if (!symbol) {
                transformer_util_1.reportDiagnostic(diagnostics, node, `named import has no symbol`);
                return;
            }
            let aliasName = moduleName;
            if (typeof name === 'string') {
                aliasName += '.' + name;
            }
            else if (name) {
                aliasName += '.' + transformer_util_1.getIdentifierText(name);
            }
            if (symbol.flags & ts.SymbolFlags.Alias) {
                symbol = typeChecker.getAliasedSymbol(symbol);
            }
            mtt.symbolsToAliasedNames.set(symbol, aliasName);
        }
        /**
         * Produces a compiler error that references the Node's kind. This is useful for the "else"
         * branch of code that is attempting to handle all possible input Node types, to ensure all cases
         * covered.
         */
        function errorUnimplementedKind(node, where) {
            transformer_util_1.reportDiagnostic(diagnostics, node, `${ts.SyntaxKind[node.kind]} not implemented in ${where}`);
        }
        /**
         * getNamespaceForLocalDeclaration returns the namespace that should be used for the given
         * declaration, deciding whether to namespace the symbol to the file or whether to create a
         * global name.
         *
         * The function covers these cases:
         * 1) a declaration in a .d.ts
         * 1a) where the .d.ts is an external module     --> namespace
         * 1b) where the .d.ts is not an external module --> global
         * 2) a declaration in a .ts file (all are treated as modules)
         * 2a) that is exported                          --> namespace
         * 2b) that is unexported                        --> global
         *
         * For 1), all symbols in .d.ts should generally be namespaced to the file to avoid collisions.
         * However .d.ts files that are not external modules do declare global names (1b).
         *
         * For 2), ambient declarations in .ts files must be namespaced, for the same collision reasons.
         * The exception is 2b), where in TypeScript, an unexported local "declare const x: string;"
         * creates a symbol that, when used locally, is emitted as just "x". That is, it behaves
         * like a variable declared in a 'declare global' block. Closure Compiler would fail the build if
         * there is no declaration for "x", so tsickle must generate a global external symbol, i.e.
         * without the namespace wrapper.
         */
        function getNamespaceForTopLevelDeclaration(declaration, namespace) {
            // Only use rootNamespace for top level symbols, any other namespacing (global names, nested
            // namespaces) is always kept.
            if (namespace.length !== 0)
                return namespace;
            // All names in a module (external) .d.ts file can only be accessed locally, so they always get
            // namespace prefixed.
            if (isDts && isExternalModule)
                return [rootNamespace];
            // Same for exported declarations in regular .ts files.
            if (transformer_util_1.hasModifierFlag(declaration, ts.ModifierFlags.Export))
                return [rootNamespace];
            // But local declarations in .ts files or .d.ts files (1b, 2b) are global, too.
            return [];
        }
        /**
         * Returns a string representation for the location: either the namespace, or, if empty, the
         * current source file name. This is intended to be included in the emit for warnings, so that
         * users can more easily find where a problematic definition is from.
         *
         * The code below does not use diagnostics to avoid breaking the build for harmless unhandled
         * cases.
         */
        function debugLocationStr(node, namespace) {
            // Use a regex to grab the filename without a path, to make the output stable
            // under bazel where sandboxes use different paths.
            return namespace.join('.') || node.getSourceFile().fileName.replace(/.*[/\\]/, '');
        }
        function visitor(node, namespace) {
            if (node.parent === sourceFile) {
                namespace = getNamespaceForTopLevelDeclaration(node, namespace);
            }
            switch (node.kind) {
                case ts.SyntaxKind.ModuleDeclaration:
                    const decl = node;
                    switch (decl.name.kind) {
                        case ts.SyntaxKind.Identifier:
                            if (decl.flags & ts.NodeFlags.GlobalAugmentation) {
                                // E.g. "declare global { ... }".  Reset to the outer namespace.
                                namespace = [];
                            }
                            else {
                                // E.g. "declare namespace foo {"
                                const name = transformer_util_1.getIdentifierText(decl.name);
                                if (isFirstValueDeclaration(decl)) {
                                    emit('/** @const */\n');
                                    writeVariableStatement(name, namespace, '{}');
                                }
                                namespace = namespace.concat(name);
                            }
                            if (decl.body)
                                visitor(decl.body, namespace);
                            break;
                        case ts.SyntaxKind.StringLiteral:
                            // E.g. "declare module 'foo' {" (note the quotes).
                            // We still want to emit externs for this module, but Closure doesn't provide a
                            // mechanism for module-scoped externs. Instead, we emit in a mangled namespace.
                            // The mangled namespace (after resolving files) matches the emit for an original module
                            // file, so effectively this augments any existing module.
                            const importName = decl.name.text;
                            const importedModuleName = googmodule_1.resolveModuleName({ moduleResolutionHost, options }, sourceFile.fileName, importName);
                            const mangled = annotator_host_1.moduleNameAsIdentifier(host, importedModuleName);
                            emit(`// Derived from: declare module "${importName}"\n`);
                            namespace = [mangled];
                            // Declare "mangled$name" if it's not declared already elsewhere.
                            if (isFirstValueDeclaration(decl)) {
                                emit('/** @const */\n');
                                writeVariableStatement(mangled, [], '{}');
                            }
                            // Declare the contents inside the "mangled$name".
                            if (decl.body)
                                visitor(decl.body, [mangled]);
                            break;
                        default:
                            errorUnimplementedKind(decl.name, 'externs generation of namespace');
                            break;
                    }
                    break;
                case ts.SyntaxKind.ModuleBlock:
                    const block = node;
                    for (const stmt of block.statements) {
                        visitor(stmt, namespace);
                    }
                    break;
                case ts.SyntaxKind.ImportEqualsDeclaration:
                    const importEquals = node;
                    const localName = transformer_util_1.getIdentifierText(importEquals.name);
                    if (localName === 'ng') {
                        emit(`\n/* Skipping problematic import ng = ...; */\n`);
                        break;
                    }
                    if (importEquals.moduleReference.kind === ts.SyntaxKind.ExternalModuleReference) {
                        addImportAliases(importEquals);
                        break;
                    }
                    const qn = transformer_util_1.getEntityNameText(importEquals.moduleReference);
                    // @const so that Closure Compiler understands this is an alias.
                    if (namespace.length === 0)
                        emit('/** @const */\n');
                    writeVariableStatement(localName, namespace, qn);
                    break;
                case ts.SyntaxKind.ClassDeclaration:
                case ts.SyntaxKind.InterfaceDeclaration:
                    writeType(node, namespace);
                    break;
                case ts.SyntaxKind.FunctionDeclaration:
                    const fnDecl = node;
                    const name = fnDecl.name;
                    if (!name) {
                        transformer_util_1.reportDiagnostic(diagnostics, fnDecl, 'anonymous function in externs');
                        break;
                    }
                    // Gather up all overloads of this function.
                    const sym = typeChecker.getSymbolAtLocation(name);
                    const decls = sym.declarations.filter(ts.isFunctionDeclaration);
                    // Only emit the first declaration of each overloaded function.
                    if (fnDecl !== decls[0])
                        break;
                    const params = emitFunctionType(decls);
                    writeFunction(name, params, namespace);
                    break;
                case ts.SyntaxKind.VariableStatement:
                    for (const decl of node.declarationList.declarations) {
                        writeVariableDeclaration(decl, namespace);
                    }
                    break;
                case ts.SyntaxKind.EnumDeclaration:
                    writeEnum(node, namespace);
                    break;
                case ts.SyntaxKind.TypeAliasDeclaration:
                    writeTypeAlias(node, namespace);
                    break;
                case ts.SyntaxKind.ImportDeclaration:
                    addImportAliases(node);
                    break;
                case ts.SyntaxKind.NamespaceExportDeclaration:
                case ts.SyntaxKind.ExportAssignment:
                    // Handled on the file level.
                    break;
                case ts.SyntaxKind.ExportDeclaration:
                    const exportDeclaration = node;
                    writeExportDeclaration(exportDeclaration, namespace);
                    break;
                default:
                    emit(`\n// TODO(tsickle): ${ts.SyntaxKind[node.kind]} in ${debugLocationStr(node, namespace)}\n`);
                    break;
            }
        }
    }
    exports.generateExterns = generateExterns;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0ZXJucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9leHRlcm5zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRzs7Ozs7Ozs7Ozs7O0lBRUg7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXlERztJQUVILGlDQUFpQztJQUVqQywrREFBdUU7SUFDdkUsbUVBQStDO0lBQy9DLHVEQUEyRTtJQUMzRSwyQ0FBaUM7SUFDakMscUVBQXNHO0lBQ3RHLCtFQUE4RDtJQUM5RCx5Q0FBK0I7SUFDL0IsbUVBQTBIO0lBQzFILGlFQUE2RDtJQUU3RDs7O09BR0c7SUFDSCxNQUFNLHlCQUF5QixHQUEwQjtRQUN2RCxTQUFTO1FBQ1QsUUFBUTtRQUNSLFFBQVE7UUFDUixnRUFBZ0U7UUFDaEUsdUVBQXVFO1FBQ3ZFLGtFQUFrRTtRQUNsRSxxRUFBcUU7UUFDckUsbUVBQW1FO1FBQ25FLHdFQUF3RTtRQUN4RSxnQ0FBZ0M7UUFDaEMsa0JBQWtCO1FBQ2xCLFFBQVE7UUFDUixtQkFBbUI7S0FDcEIsQ0FBQztJQUdGOzs7Ozs7Ozs7O09BVUc7SUFDSCxNQUFNLGNBQWMsR0FBRztNQUNqQixFQUFFOzs7O0NBSVAsQ0FBQztJQUVGOzs7Ozs7T0FNRztJQUNILFNBQWdCLG1CQUFtQixDQUFDLE9BQXFDLEVBQUUsT0FBTyxHQUFHLEVBQUU7UUFDckYsSUFBSSxVQUFVLEdBQUcsY0FBYyxDQUFDO1FBQ2hDLEtBQUssTUFBTSxRQUFRLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUMzQyxVQUFVLElBQUksbUJBQW1CLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxLQUFLLENBQUM7WUFDdkUsVUFBVSxJQUFJLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUNqQztRQUNELE9BQU8sVUFBVSxDQUFDO0lB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LElBQUksSUFBSyxJQUE2QixDQUFDLGVBQWUsQ0FBQyxZQUFZLEVBQUU7d0JBQzlFLHdCQUF3QixDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztxQkFDM0M7b0JBQ0QsTUFBTTtnQkFDUixLQUFLLEVBQUUsQ0FBQyxVQUFVLENBQUMsZUFBZTtvQkFDaEMsU0FBUyxDQUFDLElBQTBCLEVBQUUsU0FBUyxDQUFDLENBQUM7b0JBQ2pELE1BQU07Z0JBQ1IsS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLG9CQUFvQjtvQkFDckMsY0FBYyxDQUFDLElBQStCLEVBQUUsU0FBUyxDQUFDLENBQUM7b0JBQzNELE1BQU07Z0JBQ1IsS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLGlCQUFpQjtvQkFDbEMsZ0JBQWdCLENBQUMsSUFBNEIsQ0FBQyxDQUFDO29CQUMvQyxNQUFNO2dCQUNSLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQywwQkFBMEIsQ0FBQztnQkFDOUMsS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLGdCQUFnQjtvQkFDakMsNkJBQTZCO29CQUM3QixNQUFNO2dCQUNSLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxpQkFBaUI7b0JBQ2xDLE1BQU0saUJBQWlCLEdBQUcsSUFBNEIsQ0FBQztvQkFDdkQsc0JBQXNCLENBQUMsaUJBQWlCLEVBQUUsU0FBUyxDQUFDLENBQUM7b0JBQ3JELE1BQU07Z0JBQ1I7b0JBQ0UsSUFBSSxDQUFDLHVCQUF1QixFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FDaEQsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDM0MsTUFBTTthQUNUO1FBQ0gsQ0FBQztJQUNILENBQUM7SUFqbEJELDBDQWlsQkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBFeHRlcm5zIGNyZWF0ZXMgQ2xvc3VyZSBDb21waWxlciAjZXh0ZXJucyBkZWZpbml0aW9ucyBmcm9tIHRoZVxuICogYW1iaWVudCBkZWNsYXJhdGlvbnMgaW4gYSBUeXBlU2NyaXB0IGZpbGUuXG4gKlxuICogKE5vdGUgdGhhdCB3ZSBjYW5ub3Qgd3JpdGUgdGhlIFwiQFwiIGZvcm0gb2YgdGhlIGV4dGVybnMgdGFnLCBldmVuIGluIGNvbW1lbnRzLFxuICogYmVjYXVzZSB0aGUgY29tcGlsZXIgZ3JlcHMgZm9yIGl0IGluIHNvdXJjZSBmaWxlcyghKS4gIFNvIHdlIHdyaXRlICNleHRlcm5zXG4gKiBpbnN0ZWFkLilcbiAqXG4gKiBGb3IgZXhhbXBsZSwgYVxuICogICBkZWNsYXJlIGludGVyZmFjZSBGb28geyBiYXI6IHN0cmluZzsgfVxuICpcbiAqIFdvdWxkIGdlbmVyYXRlIGFcbiAqICAgLy4uICNleHRlcm5zIC4vXG4gKiAgIC8uLiBAcmVjb3JkIC4vXG4gKiAgIHZhciBGb28gPSBmdW5jdGlvbigpIHt9O1xuICogICAvLi4gQHR5cGUge3N0cmluZ30gLi9cbiAqICAgRm9vLnByb3RvdHlwZS5iYXI7XG4gKlxuICogVGhlIGdlbmVyYXRlZCBleHRlcm5zIGluZGljYXRlIHRvIENsb3N1cmUgQ29tcGlsZXIgdGhhdCBzeW1ib2xzIGFyZSBleHRlcm5hbFxuICogdG8gdGhlIG9wdGltaXphdGlvbiBwcm9jZXNzLCBpLmUuIHRoZXkgYXJlIHByb3ZpZGVkIGJ5IG91dHNpZGUgY29kZS4gVGhhdFxuICogbW9zdCBpbXBvcnRhbnRseSBtZWFucyB0aGV5IG11c3Qgbm90IGJlIHJlbmFtZWQgb3IgcmVtb3ZlZC5cbiAqXG4gKiBBIG1ham9yIGRpZmZpY3VsdHkgaGVyZSBpcyB0aGF0IFR5cGVTY3JpcHQgc3VwcG9ydHMgbW9kdWxlLXNjb3BlZCBleHRlcm5hbFxuICogc3ltYm9sczsgYC5kLnRzYCBmaWxlcyBjYW4gY29udGFpbiBgZXhwb3J0YHMgYW5kIGBpbXBvcnRgIG90aGVyIGZpbGVzLlxuICogQ2xvc3VyZSBDb21waWxlciBkb2VzIG5vdCBoYXZlIHN1Y2ggYSBjb25jZXB0LCBzbyB0c2lja2xlIG11c3QgZW11bGF0ZSB0aGVcbiAqIGJlaGF2aW91ci4gSXQgZG9lcyBzbyBieSBmb2xsb3dpbmcgdGhpcyBzY2hlbWU6XG4gKlxuICogMS4gbm9uLW1vZHVsZSAuZC50cyBwcm9kdWNlcyBnbG9iYWwgc3ltYm9sc1xuICogMi4gbW9kdWxlIC5kLnRzIHByb2R1Y2Ugc3ltYm9scyBuYW1lc3BhY2VkIHRvIHRoZSBtb2R1bGUsIGJ5IGNyZWF0aW5nIGFcbiAqICAgIG1hbmdsZWQgbmFtZSBtYXRjaGluZyB0aGUgY3VycmVudCBmaWxlJ3MgcGF0aC4gdHNpY2tsZSBleHBlY3RzIG91dHNpZGVcbiAqICAgIGNvZGUgKGUuZy4gYnVpbGQgc3lzdGVtIGludGVncmF0aW9uIG9yIG1hbnVhbGx5IHdyaXR0ZW4gY29kZSkgdG8gY29udGFpbiBhXG4gKiAgICBnb29nLm1vZHVsZS9wcm92aWRlIHRoYXQgcmVmZXJlbmNlcyB0aGUgbWFuZ2xlZCBwYXRoLlxuICogMy4gZGVjbGFyYXRpb25zIGluIGAudHNgIGZpbGVzIHByb2R1Y2UgdHlwZXMgdGhhdCBjYW4gYmUgc2VwYXJhdGVseSBlbWl0dGVkXG4gKiAgICBpbiBlLmcuIGFuIGBleHRlcm5zLmpzYCwgdXNpbmcgYGdldEdlbmVyYXRlZEV4dGVybnNgIGJlbG93LlxuICogICAgMS4gbm9uLWV4cG9ydGVkIHN5bWJvbHMgcHJvZHVjZSBnbG9iYWwgdHlwZXMsIGJlY2F1c2UgdGhhdCdzIHdoYXQgdXNlcnNcbiAqICAgICAgIGV4cGVjdCBhbmQgaXQgbWF0Y2hlcyBUeXBlU2NyaXB0cyBlbWl0LCB3aGljaCBqdXN0IHJlZmVyZW5jZXMgYEZvb2AgZm9yXG4gKiAgICAgICBhIGxvY2FsbHkgZGVjbGFyZWQgc3ltYm9sIGBGb29gIGluIGEgbW9kdWxlLiBBcmd1YWJseSB0aGVzZSBzaG91bGQgYmVcbiAqICAgICAgIHdyYXBwZWQgaW4gYGRlY2xhcmUgZ2xvYmFsIHsgLi4uIH1gLlxuICogICAgMi4gZXhwb3J0ZWQgc3ltYm9scyBhcmUgc2NvcGVkIHRvIHRoZSBgLnRzYCBmaWxlIGJ5IHByZWZpeGluZyB0aGVtIHdpdGggYVxuICogICAgICAgbWFuZ2xlZCBuYW1lLiBFeHBvcnRlZCB0eXBlcyBhcmUgcmUtZXhwb3J0ZWQgZnJvbSB0aGUgSmF2YVNjcmlwdFxuICogICAgICAgYGdvb2cubW9kdWxlYCwgYWxsb3dpbmcgZG93bnN0cmVhbSBjb2RlIHRvIHJlZmVyZW5jZSB0aGVtLiBUaGlzIGhhcyB0aGVcbiAqICAgICAgIHNhbWUgcHJvYmxlbSByZWdhcmRpbmcgYW1iaWVudCB2YWx1ZXMgYXMgYWJvdmUsIGl0IGlzIHVuY2xlYXIgd2hlcmUgdGhlXG4gKiAgICAgICB2YWx1ZSBzeW1ib2wgd291bGQgYmUgZGVmaW5lZCwgc28gZm9yIHRoZSB0aW1lIGJlaW5nIHRoaXMgaXNcbiAqICAgICAgIHVuc3VwcG9ydGVkLlxuICpcbiAqIFRoZSBlZmZlY3Qgb2YgdGhpcyBpcyB0aGF0OlxuICogLSBzeW1ib2xzIGluIGEgbW9kdWxlIChpLmUuIG5vdCBnbG9iYWxzKSBhcmUgZ2VuZXJhbGx5IHNjb3BlZCB0byB0aGUgbG9jYWxcbiAqICAgbW9kdWxlIHVzaW5nIGEgbWFuZ2xlZCBuYW1lLCBwcmV2ZW50aW5nIHN5bWJvbCBjb2xsaXNpb25zIG9uIHRoZSBDbG9zdXJlXG4gKiAgIHNpZGUuXG4gKiAtIGltcG9ydGluZyBjb2RlIGNhbiB1bmNvbmRpdGlvbmFsbHkgcmVmZXIgdG8gYW5kIGltcG9ydCBhbnkgc3ltYm9sIGRlZmluZWRcbiAqICAgaW4gYSBtb2R1bGUgYFhgIGFzIGBwYXRoLnRvLm1vZHVsZS5YYCwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBkZWZpbmluZ1xuICogICBsb2NhdGlvbiBpcyBhIGAuZC50c2AgZmlsZSBvciBhIGAudHNgIGZpbGUsIGFuZCByZWdhcmRsZXNzIHdoZXRoZXIgdGhlXG4gKiAgIHN5bWJvbCBpcyBhbWJpZW50IChhc3N1bWluZyB0aGVyZSdzIGFuIGFwcHJvcHJpYXRlIHNoaW0pLlxuICogLSBpZiB0aGVyZSBpcyBhIHNoaW0gcHJlc2VudCwgdHNpY2tsZSBhdm9pZHMgZW1pdHRpbmcgdGhlIENsb3N1cmUgbmFtZXNwYWNlXG4gKiAgIGl0c2VsZiwgZXhwZWN0aW5nIHRoZSBzaGltIHRvIHByb3ZpZGUgdGhlIG5hbWVzcGFjZSBhbmQgaW5pdGlhbGl6ZSBpdCB0byBhXG4gKiAgIHN5bWJvbCB0aGF0IHByb3ZpZGVzIHRoZSByaWdodCB2YWx1ZSBhdCBydW50aW1lIChpLmUuIHRoZSBpbXBsZW1lbnRhdGlvbiBvZlxuICogICB3aGF0ZXZlciB0aGlyZCBwYXJ0eSBsaWJyYXJ5IHRoZSAuZC50cyBkZXNjcmliZXMpLlxuICovXG5cbmltcG9ydCAqIGFzIHRzIGZyb20gJ3R5cGVzY3JpcHQnO1xuXG5pbXBvcnQge0Fubm90YXRvckhvc3QsIG1vZHVsZU5hbWVBc0lkZW50aWZpZXJ9IGZyb20gJy4vYW5ub3RhdG9yX2hvc3QnO1xuaW1wb3J0IHtnZXRFbnVtVHlwZX0gZnJvbSAnLi9lbnVtX3RyYW5zZm9ybWVyJztcbmltcG9ydCB7ZXh0cmFjdEdvb2dOYW1lc3BhY2VJbXBvcnQsIHJlc29sdmVNb2R1bGVOYW1lfSBmcm9tICcuL2dvb2dtb2R1bGUnO1xuaW1wb3J0ICogYXMganNkb2MgZnJvbSAnLi9qc2RvYyc7XG5pbXBvcnQge2VzY2FwZUZvckNvbW1lbnQsIG1heWJlQWRkSGVyaXRhZ2VDbGF1c2VzLCBtYXliZUFkZFRlbXBsYXRlQ2xhdXNlfSBmcm9tICcuL2pzZG9jX3RyYW5zZm9ybWVyJztcbmltcG9ydCB7TW9kdWxlVHlwZVRyYW5zbGF0b3J9IGZyb20gJy4vbW9kdWxlX3R5cGVfdHJhbnNsYXRvcic7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJy4vcGF0aCc7XG5pbXBvcnQge2dldEVudGl0eU5hbWVUZXh0LCBnZXRJZGVudGlmaWVyVGV4dCwgaGFzTW9kaWZpZXJGbGFnLCBpc0R0c0ZpbGVOYW1lLCByZXBvcnREaWFnbm9zdGljfSBmcm9tICcuL3RyYW5zZm9ybWVyX3V0aWwnO1xuaW1wb3J0IHtpc1ZhbGlkQ2xvc3VyZVByb3BlcnR5TmFtZX0gZnJvbSAnLi90eXBlX3RyYW5zbGF0b3InO1xuXG4vKipcbiAqIFN5bWJvbHMgdGhhdCBhcmUgYWxyZWFkeSBkZWNsYXJlZCBhcyBleHRlcm5zIGluIENsb3N1cmUsIHRoYXQgc2hvdWxkXG4gKiBiZSBhdm9pZGVkIGJ5IHRzaWNrbGUncyBcImRlY2xhcmUgLi4uXCIgPT4gZXh0ZXJucy5qcyBjb252ZXJzaW9uLlxuICovXG5jb25zdCBDTE9TVVJFX0VYVEVSTlNfQkxBQ0tMSVNUOiBSZWFkb25seUFycmF5PHN0cmluZz4gPSBbXG4gICdleHBvcnRzJyxcbiAgJ2dsb2JhbCcsXG4gICdtb2R1bGUnLFxuICAvLyBFcnJvckNvbnN0cnVjdG9yIGlzIHRoZSBpbnRlcmZhY2Ugb2YgdGhlIEVycm9yIG9iamVjdCBpdHNlbGYuXG4gIC8vIHRzaWNrbGUgZGV0ZWN0cyB0aGF0IHRoaXMgaXMgcGFydCBvZiB0aGUgVHlwZVNjcmlwdCBzdGFuZGFyZCBsaWJyYXJ5XG4gIC8vIGFuZCBhc3N1bWVzIGl0J3MgcGFydCBvZiB0aGUgQ2xvc3VyZSBzdGFuZGFyZCBsaWJyYXJ5LCBidXQgdGhpc1xuICAvLyBhc3N1bXB0aW9uIGlzIHdyb25nIGZvciBFcnJvckNvbnN0cnVjdG9yLiAgVG8gcHJvcGVybHkgaGFuZGxlIHRoaXNcbiAgLy8gd2UnZCBzb21laG93IG5lZWQgdG8gbWFwIG1ldGhvZHMgZGVmaW5lZCBvbiB0aGUgRXJyb3JDb25zdHJ1Y3RvclxuICAvLyBpbnRlcmZhY2UgaW50byBwcm9wZXJ0aWVzIG9uIENsb3N1cmUncyBFcnJvciBvYmplY3QsIGJ1dCBmb3Igbm93IGl0J3NcbiAgLy8gc2ltcGxlciB0byBqdXN0IGJsYWNrbGlzdCBpdC5cbiAgJ0Vycm9yQ29uc3RydWN0b3InLFxuICAnU3ltYm9sJyxcbiAgJ1dvcmtlckdsb2JhbFNjb3BlJyxcbl07XG5cblxuLyoqXG4gKiBUaGUgaGVhZGVyIHRvIGJlIHVzZWQgaW4gZ2VuZXJhdGVkIGV4dGVybnMuICBUaGlzIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgb3V0cHV0IG9mXG4gKiBnZW5lcmF0ZUV4dGVybnMoKSBiZWNhdXNlIGdlbmVyYXRlRXh0ZXJucygpIHdvcmtzIG9uZSBmaWxlIGF0IGEgdGltZSwgYW5kIHR5cGljYWxseSB5b3UgY3JlYXRlXG4gKiBvbmUgZXh0ZXJucyBmaWxlIGZyb20gdGhlIGVudGlyZSBjb21waWxhdGlvbiB1bml0LlxuICpcbiAqIFN1cHByZXNzaW9uczpcbiAqIC0gZHVwbGljYXRlOiBiZWNhdXNlIGV4dGVybnMgbWlnaHQgZHVwbGljYXRlIHJlLW9wZW5lZCBkZWZpbml0aW9ucyBmcm9tIG90aGVyIEpTIGZpbGVzLlxuICogLSBjaGVja1R5cGVzOiBDbG9zdXJlJ3MgdHlwZSBzeXN0ZW0gZG9lcyBub3QgbWF0Y2ggVFMnLlxuICogLSB1bmRlZmluZWROYW1lczogY29kZSBiZWxvdyB0cmllcyB0byBiZSBjYXJlZnVsIG5vdCB0byBvdmVyd3JpdGUgcHJldmlvdXNseSBlbWl0dGVkIGRlZmluaXRpb25zLFxuICogICBidXQgb24gdGhlIGZsaXAgc2lkZSBtaWdodCBhY2NpZGVudGFsbHkgbWlzcyBkZWZpbml0aW9ucy5cbiAqL1xuY29uc3QgRVhURVJOU19IRUFERVIgPSBgLyoqXG4gKiBAJHsnJ31leHRlcm5zXG4gKiBAc3VwcHJlc3Mge2R1cGxpY2F0ZSxjaGVja1R5cGVzfVxuICovXG4vLyBOT1RFOiBnZW5lcmF0ZWQgYnkgdHNpY2tsZSwgZG8gbm90IGVkaXQuXG5gO1xuXG4vKipcbiAqIENvbmNhdGVuYXRlIGFsbCBnZW5lcmF0ZWQgZXh0ZXJucyBkZWZpbml0aW9ucyB0b2dldGhlciBpbnRvIGEgc3RyaW5nLCBpbmNsdWRpbmcgYSBmaWxlIGNvbW1lbnRcbiAqIGhlYWRlci5cbiAqXG4gKiBAcGFyYW0gcm9vdERpciBQcm9qZWN0IHJvb3QuICBFbWl0dGVkIGNvbW1lbnRzIHdpbGwgcmVmZXJlbmNlIHBhdGhzIHJlbGF0aXZlIHRvIHRoaXMgcm9vdC5cbiAqICAgIFRoaXMgcGFyYW0gaXMgZWZmZWN0aXZlbHkgcmVxdWlyZWQsIGJ1dCBtYWRlIG9wdGlvbmFsIGhlcmUgdW50aWwgQW5ndWxhciBpcyBmaXhlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEdlbmVyYXRlZEV4dGVybnMoZXh0ZXJuczoge1tmaWxlTmFtZTogc3RyaW5nXTogc3RyaW5nfSwgcm9vdERpciA9ICcnKTogc3RyaW5nIHtcbiAgbGV0IGFsbEV4dGVybnMgPSBFWFRFUk5TX0hFQURFUjtcbiAgZm9yIChjb25zdCBmaWxlTmFtZSBvZiBPYmplY3Qua2V5cyhleHRlcm5zKSkge1xuICAgIGFsbEV4dGVybnMgKz0gYC8vIGV4dGVybnMgZnJvbSAke3BhdGgucmVsYXRpdmUocm9vdERpciwgZmlsZU5hbWUpfTpcXG5gO1xuICAgIGFsbEV4dGVybnMgKz0gZXh0ZXJuc1tmaWxlTmFtZV07XG4gIH1cbiAgcmV0dXJuIGFsbEV4dGVybnM7XG59XG5cbi8qKlxuICogaXNJbkdsb2JhbEF1Z21lbnRhdGlvbiByZXR1cm5zIHRydWUgaWYgZGVjbGFyYXRpb24gaXMgdGhlIGltbWVkaWF0ZSBjaGlsZCBvZiBhICdkZWNsYXJlIGdsb2JhbCdcbiAqIGJsb2NrLlxuICovXG5mdW5jdGlvbiBpc0luR2xvYmFsQXVnbWVudGF0aW9uKGRlY2xhcmF0aW9uOiB0cy5EZWNsYXJhdGlvbik6IGJvb2xlYW4ge1xuICAvLyBkZWNsYXJlIGdsb2JhbCB7IC4uLiB9IGNyZWF0ZXMgYSBNb2R1bGVEZWNsYXJhdGlvbiBjb250YWluaW5nIGEgTW9kdWxlQmxvY2sgY29udGFpbmluZyB0aGVcbiAgLy8gZGVjbGFyYXRpb24sIHdpdGggdGhlIE1vZHVsZURlY2xhcmF0aW9uIGhhdmluZyB0aGUgR2xvYmFsQXVnbWVudGF0aW9uIGZsYWcgc2V0LlxuICBpZiAoIWRlY2xhcmF0aW9uLnBhcmVudCB8fCAhZGVjbGFyYXRpb24ucGFyZW50LnBhcmVudCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gKGRlY2xhcmF0aW9uLnBhcmVudC5wYXJlbnQuZmxhZ3MgJiB0cy5Ob2RlRmxhZ3MuR2xvYmFsQXVnbWVudGF0aW9uKSAhPT0gMDtcbn1cblxuLyoqXG4gKiBnZW5lcmF0ZUV4dGVybnMgZ2VuZXJhdGVzIGV4dGVybiBkZWZpbml0aW9ucyBmb3IgYWxsIGFtYmllbnQgZGVjbGFyYXRpb25zIGluIHRoZSBnaXZlbiBzb3VyY2VcbiAqIGZpbGUuIEl0IHJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIENsb3N1cmUgSmF2YVNjcmlwdCwgbm90IGluY2x1ZGluZyB0aGUgaW5pdGlhbFxuICogY29tbWVudCB3aXRoIFxcQGZpbGVvdmVydmlldyBhbmQgI2V4dGVybnMgKHNlZSBhYm92ZSBmb3IgdGhhdCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUV4dGVybnMoXG4gICAgdHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLCBzb3VyY2VGaWxlOiB0cy5Tb3VyY2VGaWxlLCBob3N0OiBBbm5vdGF0b3JIb3N0LFxuICAgIG1vZHVsZVJlc29sdXRpb25Ib3N0OiB0cy5Nb2R1bGVSZXNvbHV0aW9uSG9zdCxcbiAgICBvcHRpb25zOiB0cy5Db21waWxlck9wdGlvbnMpOiB7b3V0cHV0OiBzdHJpbmcsIGRpYWdub3N0aWNzOiB0cy5EaWFnbm9zdGljW119IHtcbiAgbGV0IG91dHB1dCA9ICcnO1xuICBjb25zdCBkaWFnbm9zdGljczogdHMuRGlhZ25vc3RpY1tdID0gW107XG4gIGNvbnN0IGlzRHRzID0gaXNEdHNGaWxlTmFtZShzb3VyY2VGaWxlLmZpbGVOYW1lKTtcbiAgY29uc3QgaXNFeHRlcm5hbE1vZHVsZSA9IHRzLmlzRXh0ZXJuYWxNb2R1bGUoc291cmNlRmlsZSk7XG5cbiAgY29uc3QgbXR0ID1cbiAgICAgIG5ldyBNb2R1bGVUeXBlVHJhbnNsYXRvcihzb3VyY2VGaWxlLCB0eXBlQ2hlY2tlciwgaG9zdCwgZGlhZ25vc3RpY3MsIC8qaXNGb3JFeHRlcm5zKi8gdHJ1ZSk7XG5cbiAgbGV0IHJvb3ROYW1lc3BhY2UgPSAnJztcbiAgaWYgKGlzRXh0ZXJuYWxNb2R1bGUpIHtcbiAgICAvLyAuZC50cyBmaWxlcyB0aGF0IGFyZSBtb2R1bGVzIGRvIG5vdCBkZWNsYXJlIGdsb2JhbCBzeW1ib2xzIC0gdGhlaXIgc3ltYm9scyBtdXN0IGJlIGV4cGxpY2l0bHlcbiAgICAvLyBpbXBvcnRlZCB0byBiZSB1c2VkLiBIb3dldmVyIENsb3N1cmUgQ29tcGlsZXIgaGFzIG5vIGNvbmNlcHQgb2YgZXh0ZXJucyB0aGF0IGFyZSBtb2R1bGVzIGFuZFxuICAgIC8vIHJlcXVpcmUgaW1wb3J0cy4gVGhpcyBjb2RlIG1hbmdsZXMgdGhlIHN5bWJvbCBuYW1lcyBieSB3cmFwcGluZyB0aGVtIGluIGEgdG9wIGxldmVsIHZhcmlhYmxlXG4gICAgLy8gdGhhdCdzIHVuaXF1ZSB0byB0aGlzIGZpbGUuIFRoYXQgYWxsb3dzIGVtaXR0aW5nIHRoZW0gZm9yIENsb3N1cmUgYXMgZ2xvYmFsIHN5bWJvbHMgd2hpbGVcbiAgICAvLyBhdm9pZGluZyBjb2xsaXNpb25zLiBUaGlzIGlzIG5lY2Vzc2FyeSBhcyBzeW1ib2xzIGxvY2FsIHRvIHRoaXMgbW9kdWxlIGNhbiAoYW5kIHdpbGwgdmVyeVxuICAgIC8vIGNvbW1vbmx5KSBjb25mbGljdCB3aXRoIHRoZSBuYW1lc3BhY2UgdXNlZCBpbiBcImV4cG9ydCBhcyBuYW1lc3BhY2VcIiwgZS5nLiBcImFuZ3VsYXJcIiwgYW5kIGFsc29cbiAgICAvLyB0byBhdm9pZCB1c2VycyBhY2NpZGVudGFsbHkgdXNpbmcgdGhlc2Ugc3ltYm9scyBpbiAuanMgZmlsZXMgKGFuZCBtb3JlIGNvbGxpc2lvbnMpLiBUaGVcbiAgICAvLyBzeW1ib2xzIHRoYXQgYXJlIFwiaGlkZGVuXCIgbGlrZSB0aGF0IGNhbiBiZSBtYWRlIGFjY2Vzc2libGUgdGhyb3VnaCBhbiBcImV4cG9ydCBhcyBuYW1lc3BhY2VcIlxuICAgIC8vIGRlY2xhcmF0aW9uIChzZWUgYmVsb3cpLlxuICAgIHJvb3ROYW1lc3BhY2UgPSBtb2R1bGVOYW1lQXNJZGVudGlmaWVyKGhvc3QsIHNvdXJjZUZpbGUuZmlsZU5hbWUpO1xuICB9XG5cbiAgZm9yIChjb25zdCBzdG10IG9mIHNvdXJjZUZpbGUuc3RhdGVtZW50cykge1xuICAgIGlmICghaXNEdHMgJiYgIWhhc01vZGlmaWVyRmxhZyhzdG10IGFzIHRzLkRlY2xhcmF0aW9uU3RhdGVtZW50LCB0cy5Nb2RpZmllckZsYWdzLkFtYmllbnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmlzaXRvcihzdG10LCBbXSk7XG4gIH1cblxuICBpZiAob3V0cHV0ICYmIGlzRXh0ZXJuYWxNb2R1bGUpIHtcbiAgICAvLyBJZiB0c2lja2xlIGdlbmVyYXRlZCBhbnkgZXh0ZXJucyBhbmQgdGhpcyBpcyBhbiBleHRlcm5hbCBtb2R1bGUsIHByZXBlbmQgdGhlIG5hbWVzcGFjZVxuICAgIC8vIGRlY2xhcmF0aW9uIGZvciBpdC5cbiAgICBvdXRwdXQgPSBgLyoqIEBjb25zdCAqL1xcbnZhciAke3Jvb3ROYW1lc3BhY2V9ID0ge307XFxuYCArIG91dHB1dDtcblxuICAgIC8vIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBleHBvcnQgPS5cbiAgICBjb25zdCBleHBvcnRBc3NpZ25tZW50ID0gc291cmNlRmlsZS5zdGF0ZW1lbnRzLmZpbmQodHMuaXNFeHBvcnRBc3NpZ25tZW50KTtcbiAgICBsZXQgZXhwb3J0ZWROYW1lc3BhY2UgPSByb290TmFtZXNwYWNlO1xuICAgIGlmIChleHBvcnRBc3NpZ25tZW50ICYmIGV4cG9ydEFzc2lnbm1lbnQuaXNFeHBvcnRFcXVhbHMpIHtcbiAgICAgIGlmICh0cy5pc0lkZW50aWZpZXIoZXhwb3J0QXNzaWdubWVudC5leHByZXNzaW9uKSB8fFxuICAgICAgICAgIHRzLmlzUXVhbGlmaWVkTmFtZShleHBvcnRBc3NpZ25tZW50LmV4cHJlc3Npb24pKSB7XG4gICAgICAgIC8vIEUuZy4gZXhwb3J0ID0gc29tZU5hbWU7XG4gICAgICAgIC8vIElmIHNvbWVOYW1lIGlzIFwiZGVjbGFyZSBnbG9iYWwgeyBuYW1lc3BhY2Ugc29tZU5hbWUgey4uLn0gfVwiLCB0c2lja2xlIG11c3Qgbm90IHF1YWxpZnlcbiAgICAgICAgLy8gYWNjZXNzIHRvIGl0IHdpdGggbW9kdWxlIG5hbWVzcGFjZSBhcyBpdCBpcyBlbWl0dGVkIGluIHRoZSBnbG9iYWwgbmFtZXNwYWNlLlxuICAgICAgICBjb25zdCBzeW1ib2wgPSB0eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKGV4cG9ydEFzc2lnbm1lbnQuZXhwcmVzc2lvbik7XG4gICAgICAgIGNvbnN0IGlzR2xvYmFsU3ltYm9sID0gc3ltYm9sICYmIHN5bWJvbC5kZWNsYXJhdGlvbnMgJiZcbiAgICAgICAgICAgIHN5bWJvbC5kZWNsYXJhdGlvbnMuc29tZShkID0+IGlzSW5HbG9iYWxBdWdtZW50YXRpb24oZCkpO1xuICAgICAgICBjb25zdCBlbnRpdHlOYW1lID0gZ2V0RW50aXR5TmFtZVRleHQoZXhwb3J0QXNzaWdubWVudC5leHByZXNzaW9uKTtcbiAgICAgICAgaWYgKGlzR2xvYmFsU3ltYm9sKSB7XG4gICAgICAgICAgZXhwb3J0ZWROYW1lc3BhY2UgPSBlbnRpdHlOYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cG9ydGVkTmFtZXNwYWNlID0gcm9vdE5hbWVzcGFjZSArICcuJyArIGVudGl0eU5hbWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcG9ydERpYWdub3N0aWMoXG4gICAgICAgICAgICBkaWFnbm9zdGljcywgZXhwb3J0QXNzaWdubWVudC5leHByZXNzaW9uLFxuICAgICAgICAgICAgYGV4cG9ydCA9IGV4cHJlc3Npb24gbXVzdCBiZSBhIHF1YWxpZmllZCBuYW1lLCBnb3QgJHtcbiAgICAgICAgICAgICAgICB0cy5TeW50YXhLaW5kW2V4cG9ydEFzc2lnbm1lbnQuZXhwcmVzc2lvbi5raW5kXX0uYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzRHRzICYmIGhvc3QucHJvdmlkZUV4dGVybmFsTW9kdWxlRHRzTmFtZXNwYWNlKSB7XG4gICAgICAvLyBJbiBhIG5vbi1zaGltbWVkIG1vZHVsZSwgY3JlYXRlIGEgZ2xvYmFsIG5hbWVzcGFjZS4gVGhpcyBleGlzdHMgcHVyZWx5IGZvciBiYWNrd2FyZHNcbiAgICAgIC8vIGNvbXBhdGlibGl0eSwgaW4gdGhlIG1lZGl1bSB0ZXJtIGFsbCBjb2RlIHVzaW5nIHRzaWNrbGUgc2hvdWxkIGFsd2F5cyB1c2UgYGdvb2cubW9kdWxlYHMsXG4gICAgICAvLyBzbyBnbG9iYWwgbmFtZXMgc2hvdWxkIG5vdCBiZSBuZWNjZXNzYXJ5LlxuICAgICAgZm9yIChjb25zdCBuc0V4cG9ydCBvZiBzb3VyY2VGaWxlLnN0YXRlbWVudHMuZmlsdGVyKHRzLmlzTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb24pKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzcGFjZU5hbWUgPSBnZXRJZGVudGlmaWVyVGV4dChuc0V4cG9ydC5uYW1lKTtcbiAgICAgICAgZW1pdChgLy8gZXhwb3J0IGFzIG5hbWVzcGFjZSAke25hbWVzcGFjZU5hbWV9XFxuYCk7XG4gICAgICAgIHdyaXRlVmFyaWFibGVTdGF0ZW1lbnQobmFtZXNwYWNlTmFtZSwgW10sIGV4cG9ydGVkTmFtZXNwYWNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge291dHB1dCwgZGlhZ25vc3RpY3N9O1xuXG4gIGZ1bmN0aW9uIGVtaXQoc3RyOiBzdHJpbmcpIHtcbiAgICBvdXRwdXQgKz0gc3RyO1xuICB9XG5cbiAgLyoqXG4gICAqIGlzRmlyc3REZWNsYXJhdGlvbiByZXR1cm5zIHRydWUgaWYgZGVjbCBpcyB0aGUgZmlyc3QgZGVjbGFyYXRpb25cbiAgICogb2YgaXRzIHN5bWJvbC4gIEUuZy4gaW1hZ2luZVxuICAgKiAgIGludGVyZmFjZSBGb28geyB4OiBudW1iZXI7IH1cbiAgICogICBpbnRlcmZhY2UgRm9vIHsgeTogbnVtYmVyOyB9XG4gICAqIHdlIG9ubHkgd2FudCB0byBlbWl0IHRoZSBcIlxcQHJlY29yZFwiIGZvciBGb28gb24gdGhlIGZpcnN0IG9uZS5cbiAgICpcbiAgICogVGhlIGV4Y2VwdGlvbiBhcmUgdmFyaWFibGUgZGVjbGFyYXRpb25zLCB3aGljaCAtIGluIGV4dGVybnMgLSBkbyBub3QgYXNzaWduIGEgdmFsdWU6XG4gICAqICAgLy4uIFxcQHR5cGUgey4uLn0gLi9cbiAgICogICB2YXIgc29tZVZhcmlhYmxlO1xuICAgKiAgIC8uLiBcXEB0eXBlIHsuLi59IC4vXG4gICAqICAgc29tZU5hbWVzcGFjZS5zb21lVmFyaWFibGU7XG4gICAqIElmIGEgbGF0ZXIgZGVjbGFyYXRpb24gd2FudHMgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvbiBzb21lVmFyaWFibGUsIHRzaWNrbGUgbXVzdCBzdGlsbFxuICAgKiBlbWl0IGFuIGFzc2lnbm1lbnQgaW50byB0aGUgb2JqZWN0LCBhcyBpdCdzIG90aGVyd2lzZSBhYnNlbnQuXG4gICAqL1xuICBmdW5jdGlvbiBpc0ZpcnN0VmFsdWVEZWNsYXJhdGlvbihkZWNsOiB0cy5EZWNsYXJhdGlvblN0YXRlbWVudCk6IGJvb2xlYW4ge1xuICAgIGlmICghZGVjbC5uYW1lKSByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBzeW0gPSB0eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKGRlY2wubmFtZSkhO1xuICAgIGlmICghc3ltLmRlY2xhcmF0aW9ucyB8fCBzeW0uZGVjbGFyYXRpb25zLmxlbmd0aCA8IDIpIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IGVhcmxpZXJEZWNscyA9IHN5bS5kZWNsYXJhdGlvbnMuc2xpY2UoMCwgc3ltLmRlY2xhcmF0aW9ucy5pbmRleE9mKGRlY2wpKTtcbiAgICAvLyBFaXRoZXIgdGhlcmUgYXJlIG5vIGVhcmxpZXIgZGVjbGFyYXRpb25zLCBvciBhbGwgb2YgdGhlbSBhcmUgdmFyaWFibGVzIChzZWUgYWJvdmUpLiB0c2lja2xlXG4gICAgLy8gZW1pdHMgYSB2YWx1ZSBmb3IgYWxsIG90aGVyIGRlY2xhcmF0aW9uIGtpbmRzIChmdW5jdGlvbiBmb3IgZnVuY3Rpb25zLCBjbGFzc2VzLCBpbnRlcmZhY2VzLFxuICAgIC8vIHt9IG9iamVjdCBmb3IgbmFtZXNwYWNlcykuXG4gICAgcmV0dXJuIGVhcmxpZXJEZWNscy5sZW5ndGggPT09IDAgfHwgZWFybGllckRlY2xzLmV2ZXJ5KHRzLmlzVmFyaWFibGVEZWNsYXJhdGlvbik7XG4gIH1cblxuICAvKiogV3JpdGVzIHRoZSBhY3R1YWwgdmFyaWFibGUgc3RhdGVtZW50IG9mIGEgQ2xvc3VyZSB2YXJpYWJsZSBkZWNsYXJhdGlvbi4gKi9cbiAgZnVuY3Rpb24gd3JpdGVWYXJpYWJsZVN0YXRlbWVudChuYW1lOiBzdHJpbmcsIG5hbWVzcGFjZTogUmVhZG9ubHlBcnJheTxzdHJpbmc+LCB2YWx1ZT86IHN0cmluZykge1xuICAgIGNvbnN0IHF1YWxpZmllZE5hbWUgPSBuYW1lc3BhY2UuY29uY2F0KFtuYW1lXSkuam9pbignLicpO1xuICAgIGlmIChuYW1lc3BhY2UubGVuZ3RoID09PSAwKSBlbWl0KGB2YXIgYCk7XG4gICAgZW1pdChxdWFsaWZpZWROYW1lKTtcbiAgICBpZiAodmFsdWUpIGVtaXQoYCA9ICR7dmFsdWV9YCk7XG4gICAgZW1pdCgnO1xcbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlcyBhIENsb3N1cmUgdmFyaWFibGUgZGVjbGFyYXRpb24sIGkuZS4gdGhlIHZhcmlhYmxlIHN0YXRlbWVudCB3aXRoIGEgbGVhZGluZyBKU0RvY1xuICAgKiBjb21tZW50IG1ha2luZyBpdCBhIGRlY2xhcmF0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gd3JpdGVWYXJpYWJsZURlY2xhcmF0aW9uKFxuICAgICAgZGVjbDogdHMuVmFyaWFibGVEZWNsYXJhdGlvbiwgbmFtZXNwYWNlOiBSZWFkb25seUFycmF5PHN0cmluZz4pIHtcbiAgICBpZiAoZGVjbC5uYW1lLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuSWRlbnRpZmllcikge1xuICAgICAgY29uc3QgbmFtZSA9IGdldElkZW50aWZpZXJUZXh0KGRlY2wubmFtZSBhcyB0cy5JZGVudGlmaWVyKTtcbiAgICAgIGlmIChDTE9TVVJFX0VYVEVSTlNfQkxBQ0tMSVNULmluZGV4T2YobmFtZSkgPj0gMCkgcmV0dXJuO1xuICAgICAgZW1pdChqc2RvYy50b1N0cmluZyhbe3RhZ05hbWU6ICd0eXBlJywgdHlwZTogbXR0LnR5cGVUb0Nsb3N1cmUoZGVjbCl9XSkpO1xuICAgICAgZW1pdCgnXFxuJyk7XG4gICAgICB3cml0ZVZhcmlhYmxlU3RhdGVtZW50KG5hbWUsIG5hbWVzcGFjZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yVW5pbXBsZW1lbnRlZEtpbmQoZGVjbC5uYW1lLCAnZXh0ZXJucyBmb3IgdmFyaWFibGUnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW1pdHMgYSBKU0RvYyBkZWNsYXJhdGlvbiB0aGF0IG1lcmdlcyB0aGUgc2lnbmF0dXJlcyBvZiB0aGUgZ2l2ZW4gZnVuY3Rpb24gZGVjbGFyYXRpb24gKGZvclxuICAgKiBvdmVybG9hZHMpLCBhbmQgcmV0dXJucyB0aGUgcGFyYW1ldGVyIG5hbWVzIGNob3Nlbi5cbiAgICovXG4gIGZ1bmN0aW9uIGVtaXRGdW5jdGlvblR5cGUoZGVjbHM6IHRzLkZ1bmN0aW9uTGlrZURlY2xhcmF0aW9uW10sIGV4dHJhVGFnczoganNkb2MuVGFnW10gPSBbXSkge1xuICAgIGNvbnN0IHt0YWdzLCBwYXJhbWV0ZXJOYW1lc30gPSBtdHQuZ2V0RnVuY3Rpb25UeXBlSlNEb2MoZGVjbHMsIGV4dHJhVGFncyk7XG4gICAgZW1pdCgnXFxuJyk7XG4gICAgZW1pdChqc2RvYy50b1N0cmluZyh0YWdzKSk7XG4gICAgcmV0dXJuIHBhcmFtZXRlck5hbWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGVGdW5jdGlvbihuYW1lOiB0cy5Ob2RlLCBwYXJhbXM6IHN0cmluZ1tdLCBuYW1lc3BhY2U6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPikge1xuICAgIGNvbnN0IHBhcmFtc1N0ciA9IHBhcmFtcy5qb2luKCcsICcpO1xuICAgIGlmIChuYW1lc3BhY2UubGVuZ3RoID4gMCkge1xuICAgICAgbGV0IGZxbiA9IG5hbWVzcGFjZS5qb2luKCcuJyk7XG4gICAgICBpZiAobmFtZS5raW5kID09PSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXIpIHtcbiAgICAgICAgZnFuICs9ICcuJzsgIC8vIGNvbXB1dGVkIG5hbWVzIGluY2x1ZGUgWyBdIGluIHRoZWlyIGdldFRleHQoKSByZXByZXNlbnRhdGlvbi5cbiAgICAgIH1cbiAgICAgIGZxbiArPSBuYW1lLmdldFRleHQoKTtcbiAgICAgIGVtaXQoYCR7ZnFufSA9IGZ1bmN0aW9uKCR7cGFyYW1zU3RyfSkge307XFxuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuYW1lLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuSWRlbnRpZmllcikge1xuICAgICAgICByZXBvcnREaWFnbm9zdGljKGRpYWdub3N0aWNzLCBuYW1lLCAnTm9uLW5hbWVzcGFjZWQgY29tcHV0ZWQgbmFtZSBpbiBleHRlcm5zJyk7XG4gICAgICB9XG4gICAgICBlbWl0KGBmdW5jdGlvbiAke25hbWUuZ2V0VGV4dCgpfSgke3BhcmFtc1N0cn0pIHt9XFxuYCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGVFbnVtKGRlY2w6IHRzLkVudW1EZWNsYXJhdGlvbiwgbmFtZXNwYWNlOiBSZWFkb25seUFycmF5PHN0cmluZz4pIHtcbiAgICAvLyBFLmcuIC8qKiBAZW51bSB7bnVtYmVyfSAqLyB2YXIgQ09VTlRSWSA9IHtVUzogMSwgQ0E6IDF9O1xuICAgIGNvbnN0IG5hbWUgPSBnZXRJZGVudGlmaWVyVGV4dChkZWNsLm5hbWUpO1xuICAgIGxldCBtZW1iZXJzID0gJyc7XG4gICAgY29uc3QgZW51bVR5cGUgPSBnZXRFbnVtVHlwZSh0eXBlQ2hlY2tlciwgZGVjbCk7XG4gICAgLy8gQ2xvc3VyZSBlbnVtcyBtZW1iZXJzIG11c3QgaGF2ZSBhIHZhbHVlIG9mIHRoZSBjb3JyZWN0IHR5cGUsIGJ1dCB0aGUgYWN0dWFsIHZhbHVlIGRvZXMgbm90XG4gICAgLy8gbWF0dGVyIGluIGV4dGVybnMuXG4gICAgY29uc3QgaW5pdGlhbGl6ZXIgPSBlbnVtVHlwZSA9PT0gJ3N0cmluZycgPyBgJydgIDogMTtcbiAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBkZWNsLm1lbWJlcnMpIHtcbiAgICAgIGxldCBtZW1iZXJOYW1lOiBzdHJpbmd8dW5kZWZpbmVkO1xuICAgICAgc3dpdGNoIChtZW1iZXIubmFtZS5raW5kKSB7XG4gICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5JZGVudGlmaWVyOlxuICAgICAgICAgIG1lbWJlck5hbWUgPSBnZXRJZGVudGlmaWVyVGV4dChtZW1iZXIubmFtZSBhcyB0cy5JZGVudGlmaWVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlN0cmluZ0xpdGVyYWw6XG4gICAgICAgICAgY29uc3QgdGV4dCA9IChtZW1iZXIubmFtZSBhcyB0cy5TdHJpbmdMaXRlcmFsKS50ZXh0O1xuICAgICAgICAgIGlmIChpc1ZhbGlkQ2xvc3VyZVByb3BlcnR5TmFtZSh0ZXh0KSkgbWVtYmVyTmFtZSA9IHRleHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoIW1lbWJlck5hbWUpIHtcbiAgICAgICAgbWVtYmVycyArPSBgICAvKiBUT0RPOiAke3RzLlN5bnRheEtpbmRbbWVtYmVyLm5hbWUua2luZF19OiAke1xuICAgICAgICAgICAgZXNjYXBlRm9yQ29tbWVudChtZW1iZXIubmFtZS5nZXRUZXh0KCkpfSAqL1xcbmA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbWVtYmVycyArPSBgICAke21lbWJlck5hbWV9OiAke2luaXRpYWxpemVyfSxcXG5gO1xuICAgIH1cblxuICAgIGVtaXQoYFxcbi8qKiBAZW51bSB7JHtlbnVtVHlwZX19ICovXFxuYCk7XG4gICAgd3JpdGVWYXJpYWJsZVN0YXRlbWVudChuYW1lLCBuYW1lc3BhY2UsIGB7XFxuJHttZW1iZXJzfX1gKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyaXRlVHlwZUFsaWFzKGRlY2w6IHRzLlR5cGVBbGlhc0RlY2xhcmF0aW9uLCBuYW1lc3BhY2U6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPikge1xuICAgIGNvbnN0IHR5cGVTdHIgPSBtdHQudHlwZVRvQ2xvc3VyZShkZWNsLCB1bmRlZmluZWQpO1xuICAgIGVtaXQoYFxcbi8qKiBAdHlwZWRlZiB7JHt0eXBlU3RyfX0gKi9cXG5gKTtcbiAgICB3cml0ZVZhcmlhYmxlU3RhdGVtZW50KGdldElkZW50aWZpZXJUZXh0KGRlY2wubmFtZSksIG5hbWVzcGFjZSk7XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZVR5cGUoXG4gICAgICBkZWNsOiB0cy5JbnRlcmZhY2VEZWNsYXJhdGlvbnx0cy5DbGFzc0RlY2xhcmF0aW9uLCBuYW1lc3BhY2U6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPikge1xuICAgIGNvbnN0IG5hbWUgPSBkZWNsLm5hbWU7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICByZXBvcnREaWFnbm9zdGljKGRpYWdub3N0aWNzLCBkZWNsLCAnYW5vbnltb3VzIHR5cGUgaW4gZXh0ZXJucycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0eXBlTmFtZSA9IG5hbWVzcGFjZS5jb25jYXQoW25hbWUuZ2V0VGV4dCgpXSkuam9pbignLicpO1xuICAgIGlmIChDTE9TVVJFX0VYVEVSTlNfQkxBQ0tMSVNULmluZGV4T2YodHlwZU5hbWUpID49IDApIHJldHVybjtcblxuICAgIGlmIChpc0ZpcnN0VmFsdWVEZWNsYXJhdGlvbihkZWNsKSkge1xuICAgICAgLy8gRW1pdCB0aGUgJ2Z1bmN0aW9uJyB0aGF0IGlzIGFjdHVhbGx5IHRoZSBkZWNsYXJhdGlvbiBvZiB0aGUgaW50ZXJmYWNlXG4gICAgICAvLyBpdHNlbGYuICBJZiBpdCdzIGEgY2xhc3MsIHRoaXMgZnVuY3Rpb24gYWxzbyBtdXN0IGluY2x1ZGUgdGhlIHR5cGVcbiAgICAgIC8vIGFubm90YXRpb25zIG9mIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIGxldCBwYXJhbU5hbWVzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgY29uc3QganNkb2NUYWdzOiBqc2RvYy5UYWdbXSA9IFtdO1xuICAgICAgbGV0IHdyb3RlSnNEb2MgPSBmYWxzZTtcbiAgICAgIG1heWJlQWRkSGVyaXRhZ2VDbGF1c2VzKGpzZG9jVGFncywgbXR0LCBkZWNsKTtcbiAgICAgIG1heWJlQWRkVGVtcGxhdGVDbGF1c2UoanNkb2NUYWdzLCBkZWNsKTtcbiAgICAgIGlmIChkZWNsLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuQ2xhc3NEZWNsYXJhdGlvbikge1xuICAgICAgICAvLyBUT0RPOiBpdCBhcHBlYXJzIHlvdSBjYW4ganVzdCB3cml0ZSAnY2xhc3MgRm9vIHsgLi4uJyBpbiBleHRlcm5zLlxuICAgICAgICAvLyBUaGlzIGNvZGUgaW5zdGVhZCB0cmllcyB0byB0cmFuc2xhdGUgaXQgdG8gYSBmdW5jdGlvbi5cbiAgICAgICAganNkb2NUYWdzLnB1c2goe3RhZ05hbWU6ICdjb25zdHJ1Y3Rvcid9LCB7dGFnTmFtZTogJ3N0cnVjdCd9KTtcbiAgICAgICAgY29uc3QgY3RvcnMgPSAoZGVjbCBhcyB0cy5DbGFzc0RlY2xhcmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAubWVtYmVycy5maWx0ZXIoKG0pID0+IG0ua2luZCA9PT0gdHMuU3ludGF4S2luZC5Db25zdHJ1Y3Rvcik7XG4gICAgICAgIGlmIChjdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBmaXJzdEN0b3I6IHRzLkNvbnN0cnVjdG9yRGVjbGFyYXRpb24gPSBjdG9yc1swXSBhcyB0cy5Db25zdHJ1Y3RvckRlY2xhcmF0aW9uO1xuICAgICAgICAgIGlmIChjdG9ycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBwYXJhbU5hbWVzID0gZW1pdEZ1bmN0aW9uVHlwZShjdG9ycyBhcyB0cy5Db25zdHJ1Y3RvckRlY2xhcmF0aW9uW10sIGpzZG9jVGFncyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtTmFtZXMgPSBlbWl0RnVuY3Rpb25UeXBlKFtmaXJzdEN0b3JdLCBqc2RvY1RhZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3cm90ZUpzRG9jID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGl0J3MgYW4gaW50ZXJmYWNlOyB0YWcgaXQgYXMgc3RydWN0dXJhbGx5IHR5cGVkLlxuICAgICAgICBqc2RvY1RhZ3MucHVzaCh7dGFnTmFtZTogJ3JlY29yZCd9LCB7dGFnTmFtZTogJ3N0cnVjdCd9KTtcbiAgICAgIH1cbiAgICAgIGlmICghd3JvdGVKc0RvYykgZW1pdChqc2RvYy50b1N0cmluZyhqc2RvY1RhZ3MpKTtcbiAgICAgIHdyaXRlRnVuY3Rpb24obmFtZSwgcGFyYW1OYW1lcywgbmFtZXNwYWNlKTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGV2ZXJ5dGhpbmcgZXhjZXB0IChNZXRob2RTaWduYXR1cmV8TWV0aG9kRGVjbGFyYXRpb258Q29uc3RydWN0b3IpXG4gICAgY29uc3QgbWV0aG9kcyA9IG5ldyBNYXA8c3RyaW5nLCB0cy5NZXRob2REZWNsYXJhdGlvbltdPigpO1xuICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIGRlY2wubWVtYmVycykge1xuICAgICAgc3dpdGNoIChtZW1iZXIua2luZCkge1xuICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuUHJvcGVydHlTaWduYXR1cmU6XG4gICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5Qcm9wZXJ0eURlY2xhcmF0aW9uOlxuICAgICAgICAgIGNvbnN0IHByb3AgPSBtZW1iZXIgYXMgdHMuUHJvcGVydHlTaWduYXR1cmU7XG4gICAgICAgICAgaWYgKHByb3AubmFtZS5raW5kID09PSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gbXR0LnR5cGVUb0Nsb3N1cmUocHJvcCk7XG4gICAgICAgICAgICBpZiAocHJvcC5xdWVzdGlvblRva2VuICYmIHR5cGUgPT09ICc/Jykge1xuICAgICAgICAgICAgICAvLyBBbiBvcHRpb25hbCAnYW55JyB0eXBlIHRyYW5zbGF0ZXMgdG8gJz98dW5kZWZpbmVkJyBpbiBDbG9zdXJlLlxuICAgICAgICAgICAgICB0eXBlID0gJz98dW5kZWZpbmVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVtaXQoanNkb2MudG9TdHJpbmcoW3t0YWdOYW1lOiAndHlwZScsIHR5cGV9XSkpO1xuICAgICAgICAgICAgaWYgKGhhc01vZGlmaWVyRmxhZyhwcm9wLCB0cy5Nb2RpZmllckZsYWdzLlN0YXRpYykpIHtcbiAgICAgICAgICAgICAgZW1pdChgXFxuJHt0eXBlTmFtZX0uJHtwcm9wLm5hbWUuZ2V0VGV4dCgpfTtcXG5gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVtaXQoYFxcbiR7dHlwZU5hbWV9LnByb3RvdHlwZS4ke3Byb3AubmFtZS5nZXRUZXh0KCl9O1xcbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRPRE86IEZvciBub3cgcHJvcGVydHkgbmFtZXMgb3RoZXIgdGhhbiBJZGVudGlmaWVycyBhcmUgbm90IGhhbmRsZWQ7IGUuZy5cbiAgICAgICAgICAvLyAgICBpbnRlcmZhY2UgRm9vIHsgXCIxMjNiYXJcIjogbnVtYmVyIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLk1ldGhvZFNpZ25hdHVyZTpcbiAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLk1ldGhvZERlY2xhcmF0aW9uOlxuICAgICAgICAgIGNvbnN0IG1ldGhvZCA9IG1lbWJlciBhcyB0cy5NZXRob2REZWNsYXJhdGlvbjtcbiAgICAgICAgICBjb25zdCBpc1N0YXRpYyA9IGhhc01vZGlmaWVyRmxhZyhtZXRob2QsIHRzLk1vZGlmaWVyRmxhZ3MuU3RhdGljKTtcbiAgICAgICAgICBjb25zdCBtZXRob2RTaWduYXR1cmUgPSBgJHttZXRob2QubmFtZS5nZXRUZXh0KCl9JCQkJHtpc1N0YXRpYyA/ICdzdGF0aWMnIDogJ2luc3RhbmNlJ31gO1xuXG4gICAgICAgICAgaWYgKG1ldGhvZHMuaGFzKG1ldGhvZFNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAgIG1ldGhvZHMuZ2V0KG1ldGhvZFNpZ25hdHVyZSkhLnB1c2gobWV0aG9kKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kcy5zZXQobWV0aG9kU2lnbmF0dXJlLCBbbWV0aG9kXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuQ29uc3RydWN0b3I6XG4gICAgICAgICAgY29udGludWU7ICAvLyBIYW5kbGVkIGFib3ZlLlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIE1lbWJlcnMgY2FuIGluY2x1ZGUgdGhpbmdzIGxpa2UgaW5kZXggc2lnbmF0dXJlcywgZm9yIGUuZy5cbiAgICAgICAgICAvLyAgIGludGVyZmFjZSBGb28geyBba2V5OiBzdHJpbmddOiBudW1iZXI7IH1cbiAgICAgICAgICAvLyBGb3Igbm93LCBqdXN0IHNraXAgaXQuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgdGhlIG1lbWJlciB3YXNuJ3QgaGFuZGxlZCBpbiB0aGUgc3dpdGNoIHN0YXRlbWVudC5cbiAgICAgIGxldCBtZW1iZXJOYW1lID0gbmFtZXNwYWNlO1xuICAgICAgaWYgKG1lbWJlci5uYW1lKSB7XG4gICAgICAgIG1lbWJlck5hbWUgPSBtZW1iZXJOYW1lLmNvbmNhdChbbWVtYmVyLm5hbWUuZ2V0VGV4dCgpXSk7XG4gICAgICB9XG4gICAgICBlbWl0KGBcXG4vKiBUT0RPOiAke3RzLlN5bnRheEtpbmRbbWVtYmVyLmtpbmRdfTogJHttZW1iZXJOYW1lLmpvaW4oJy4nKX0gKi9cXG5gKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgbWV0aG9kIGRlY2xhcmF0aW9ucy9zaWduYXR1cmVzIHNlcGFyYXRlbHksIHNpbmNlIHdlIG5lZWQgdG8gZGVhbCB3aXRoIG92ZXJsb2Fkcy5cbiAgICBmb3IgKGNvbnN0IG1ldGhvZFZhcmlhbnRzIG9mIEFycmF5LmZyb20obWV0aG9kcy52YWx1ZXMoKSkpIHtcbiAgICAgIGNvbnN0IGZpcnN0TWV0aG9kVmFyaWFudCA9IG1ldGhvZFZhcmlhbnRzWzBdO1xuICAgICAgbGV0IHBhcmFtZXRlck5hbWVzOiBzdHJpbmdbXTtcbiAgICAgIGlmIChtZXRob2RWYXJpYW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHBhcmFtZXRlck5hbWVzID0gZW1pdEZ1bmN0aW9uVHlwZShtZXRob2RWYXJpYW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbWV0ZXJOYW1lcyA9IGVtaXRGdW5jdGlvblR5cGUoW2ZpcnN0TWV0aG9kVmFyaWFudF0pO1xuICAgICAgfVxuICAgICAgY29uc3QgbWV0aG9kTmFtZXNwYWNlID0gbmFtZXNwYWNlLmNvbmNhdChbbmFtZS5nZXRUZXh0KCldKTtcbiAgICAgIC8vIElmIHRoZSBtZXRob2QgaXMgc3RhdGljLCBkb24ndCBhZGQgdGhlIHByb3RvdHlwZS5cbiAgICAgIGlmICghaGFzTW9kaWZpZXJGbGFnKGZpcnN0TWV0aG9kVmFyaWFudCwgdHMuTW9kaWZpZXJGbGFncy5TdGF0aWMpKSB7XG4gICAgICAgIG1ldGhvZE5hbWVzcGFjZS5wdXNoKCdwcm90b3R5cGUnKTtcbiAgICAgIH1cbiAgICAgIHdyaXRlRnVuY3Rpb24oZmlyc3RNZXRob2RWYXJpYW50Lm5hbWUsIHBhcmFtZXRlck5hbWVzLCBtZXRob2ROYW1lc3BhY2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdyaXRlRXhwb3J0RGVjbGFyYXRpb24oXG4gICAgICBleHBvcnREZWNsYXJhdGlvbjogdHMuRXhwb3J0RGVjbGFyYXRpb24sIG5hbWVzcGFjZTogUmVhZG9ubHlBcnJheTxzdHJpbmc+KSB7XG4gICAgaWYgKCFleHBvcnREZWNsYXJhdGlvbi5leHBvcnRDbGF1c2UpIHtcbiAgICAgIGVtaXQoYFxcbi8vIFRPRE8odHNpY2tsZSk6IGV4cG9ydCAqIGRlY2xhcmF0aW9uIGluICR7XG4gICAgICAgICAgZGVidWdMb2NhdGlvblN0cihleHBvcnREZWNsYXJhdGlvbiwgbmFtZXNwYWNlKX1cXG5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBleHBvcnRTcGVjaWZpZXIgb2YgZXhwb3J0RGVjbGFyYXRpb24uZXhwb3J0Q2xhdXNlLmVsZW1lbnRzKSB7XG4gICAgICAvLyBObyBuZWVkIHRvIGRvIGFueXRoaW5nIGZvciBwcm9wZXJ0aWVzIGV4cG9ydGVkIHVuZGVyIHRoZWlyIG9yaWdpbmFsIG5hbWUuXG4gICAgICBpZiAoIWV4cG9ydFNwZWNpZmllci5wcm9wZXJ0eU5hbWUpIGNvbnRpbnVlO1xuICAgICAgZW1pdCgnLyoqIEBjb25zdCAqL1xcbicpO1xuICAgICAgd3JpdGVWYXJpYWJsZVN0YXRlbWVudChcbiAgICAgICAgICBleHBvcnRTcGVjaWZpZXIubmFtZS50ZXh0LCBuYW1lc3BhY2UsXG4gICAgICAgICAgbmFtZXNwYWNlLmpvaW4oJy4nKSArICcuJyArIGV4cG9ydFNwZWNpZmllci5wcm9wZXJ0eU5hbWUudGV4dCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYWxpYXNlcyBmb3IgdGhlIHN5bWJvbHMgaW1wb3J0ZWQgaW4gdGhlIGdpdmVuIGRlY2xhcmF0aW9uLCBzbyB0aGF0IHRoZWlyIHR5cGVzIGdldFxuICAgKiBwcmludGVkIGFzIHRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZSwgYW5kIG5vdCBqdXN0IGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBsb2NhbCBpbXBvcnQgYWxpYXMuXG4gICAqXG4gICAqIHRzaWNrbGUgZ2VuZXJhdGVzIC5qcyBmaWxlcyB0aGF0IChhdCBtb3N0KSBjb250YWluIGEgYGdvb2cucHJvdmlkZWAsIGJ1dCBhcmUgbm90XG4gICAqIGBnb29nLm1vZHVsZWBzLiBUaGVzZSBmaWxlcyBjYW5ub3QgZXhwcmVzcyBhbiBhbGlhc2VkIGltcG9ydC4gSG93ZXZlciBDbG9zdXJlIENvbXBpbGVyIGFsbG93c1xuICAgKiByZWZlcmVuY2luZyB0eXBlcyB1c2luZyBmdWxseSBxdWFsaWZpZWQgbmFtZXMgaW4gc3VjaCBmaWxlcywgc28gdHNpY2tsZSBjYW4gcmVzb2x2ZSB0aGVcbiAgICogaW1wb3J0ZWQgbW9kdWxlIFVSSSBhbmQgcHJvZHVjZSBgcGF0aC50by5tb2R1bGUuU3ltYm9sYCBhcyBhbiBhbGlhcywgYW5kIHVzZSB0aGF0IHdoZW5cbiAgICogcmVmZXJlbmNpbmcgdGhlIHR5cGUuXG4gICAqL1xuICBmdW5jdGlvbiBhZGRJbXBvcnRBbGlhc2VzKGRlY2w6IHRzLkltcG9ydERlY2xhcmF0aW9ufHRzLkltcG9ydEVxdWFsc0RlY2xhcmF0aW9uKSB7XG4gICAgbGV0IG1vZHVsZVVyaTogc3RyaW5nO1xuICAgIGlmICh0cy5pc0ltcG9ydERlY2xhcmF0aW9uKGRlY2wpKSB7XG4gICAgICBtb2R1bGVVcmkgPSAoZGVjbC5tb2R1bGVTcGVjaWZpZXIgYXMgdHMuU3RyaW5nTGl0ZXJhbCkudGV4dDtcbiAgICB9IGVsc2UgaWYgKHRzLmlzRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2UoZGVjbC5tb2R1bGVSZWZlcmVuY2UpKSB7XG4gICAgICAvLyBpbXBvcnQgZm9vID0gcmVxdWlyZSgnLi9iYXInKTtcbiAgICAgIG1vZHVsZVVyaSA9IChkZWNsLm1vZHVsZVJlZmVyZW5jZS5leHByZXNzaW9uIGFzIHRzLlN0cmluZ0xpdGVyYWwpLnRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGltcG9ydCBmb28gPSBiYXIuYmF6LmJhbTtcbiAgICAgIC8vIHVuc3VwcG9ydGVkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGdvb2dOYW1lc3BhY2UgPSBleHRyYWN0R29vZ05hbWVzcGFjZUltcG9ydChtb2R1bGVVcmkpO1xuICAgIGNvbnN0IG1vZHVsZU5hbWUgPSBnb29nTmFtZXNwYWNlIHx8XG4gICAgICAgIGhvc3QucGF0aFRvTW9kdWxlTmFtZShcbiAgICAgICAgICAgIHNvdXJjZUZpbGUuZmlsZU5hbWUsIHJlc29sdmVNb2R1bGVOYW1lKGhvc3QsIHNvdXJjZUZpbGUuZmlsZU5hbWUsIG1vZHVsZVVyaSkpO1xuXG4gICAgaWYgKHRzLmlzSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24oZGVjbCkpIHtcbiAgICAgIC8vIGltcG9ydCBmb28gPSByZXF1aXJlKCcuL2JhcicpO1xuICAgICAgYWRkSW1wb3J0QWxpYXMoZGVjbC5uYW1lLCBtb2R1bGVOYW1lLCB1bmRlZmluZWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydCwgbGlrZSBcImltcG9ydCAnc29tZXBhdGgnO1wiIGRlY2xhcmVzIG5vIGxvY2FsIGFsaWFzZXMuXG4gICAgaWYgKCFkZWNsLmltcG9ydENsYXVzZSkgcmV0dXJuO1xuXG4gICAgaWYgKGRlY2wuaW1wb3J0Q2xhdXNlLm5hbWUpIHtcbiAgICAgIC8vIGltcG9ydCBuYW1lIGZyb20gLi4uIC0+IG1hcCB0byAuZGVmYXVsdCBvbiB0aGUgbW9kdWxlLm5hbWUuXG4gICAgICBpZiAoZ29vZ05hbWVzcGFjZSkge1xuICAgICAgICBhZGRJbXBvcnRBbGlhcyhkZWNsLmltcG9ydENsYXVzZS5uYW1lLCBnb29nTmFtZXNwYWNlLCB1bmRlZmluZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkSW1wb3J0QWxpYXMoZGVjbC5pbXBvcnRDbGF1c2UubmFtZSwgbW9kdWxlTmFtZSwgJ2RlZmF1bHQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmFtZWRCaW5kaW5ncyA9IGRlY2wuaW1wb3J0Q2xhdXNlLm5hbWVkQmluZGluZ3M7XG4gICAgaWYgKCFuYW1lZEJpbmRpbmdzKSByZXR1cm47XG5cbiAgICBpZiAodHMuaXNOYW1lc3BhY2VJbXBvcnQobmFtZWRCaW5kaW5ncykpIHtcbiAgICAgIC8vIGltcG9ydCAqIGFzIG5hbWUgLT4gbWFwIGRpcmVjdGx5IHRvIHRoZSBtb2R1bGUubmFtZS5cbiAgICAgIGFkZEltcG9ydEFsaWFzKG5hbWVkQmluZGluZ3MubmFtZSwgbW9kdWxlTmFtZSwgdW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICBpZiAodHMuaXNOYW1lZEltcG9ydHMobmFtZWRCaW5kaW5ncykpIHtcbiAgICAgIC8vIGltcG9ydCB7QSBhcyBCfSwgbWFwIHRvIG1vZHVsZS5uYW1lLkFcbiAgICAgIGZvciAoY29uc3QgbmFtZWRCaW5kaW5nIG9mIG5hbWVkQmluZGluZ3MuZWxlbWVudHMpIHtcbiAgICAgICAgYWRkSW1wb3J0QWxpYXMobmFtZWRCaW5kaW5nLm5hbWUsIG1vZHVsZU5hbWUsIG5hbWVkQmluZGluZy5uYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBpbXBvcnQgYWxpYXMgZm9yIHRoZSBzeW1ib2wgZGVmaW5lZCBhdCB0aGUgZ2l2ZW4gbm9kZS4gQ3JlYXRlcyBhbiBhbGlhcyBuYW1lIGJhc2VkIG9uXG4gICAqIHRoZSBnaXZlbiBtb2R1bGVOYW1lIGFuZCAob3B0aW9uYWxseSkgdGhlIG5hbWUuXG4gICAqL1xuICBmdW5jdGlvbiBhZGRJbXBvcnRBbGlhcyhub2RlOiB0cy5Ob2RlLCBtb2R1bGVOYW1lOiBzdHJpbmcsIG5hbWU6IHRzLklkZW50aWZpZXJ8c3RyaW5nfHVuZGVmaW5lZCkge1xuICAgIGxldCBzeW1ib2wgPSB0eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKG5vZGUpO1xuICAgIGlmICghc3ltYm9sKSB7XG4gICAgICByZXBvcnREaWFnbm9zdGljKGRpYWdub3N0aWNzLCBub2RlLCBgbmFtZWQgaW1wb3J0IGhhcyBubyBzeW1ib2xgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGFsaWFzTmFtZSA9IG1vZHVsZU5hbWU7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgYWxpYXNOYW1lICs9ICcuJyArIG5hbWU7XG4gICAgfSBlbHNlIGlmIChuYW1lKSB7XG4gICAgICBhbGlhc05hbWUgKz0gJy4nICsgZ2V0SWRlbnRpZmllclRleHQobmFtZSk7XG4gICAgfVxuICAgIGlmIChzeW1ib2wuZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5BbGlhcykge1xuICAgICAgc3ltYm9sID0gdHlwZUNoZWNrZXIuZ2V0QWxpYXNlZFN5bWJvbChzeW1ib2wpO1xuICAgIH1cbiAgICBtdHQuc3ltYm9sc1RvQWxpYXNlZE5hbWVzLnNldChzeW1ib2wsIGFsaWFzTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogUHJvZHVjZXMgYSBjb21waWxlciBlcnJvciB0aGF0IHJlZmVyZW5jZXMgdGhlIE5vZGUncyBraW5kLiBUaGlzIGlzIHVzZWZ1bCBmb3IgdGhlIFwiZWxzZVwiXG4gICAqIGJyYW5jaCBvZiBjb2RlIHRoYXQgaXMgYXR0ZW1wdGluZyB0byBoYW5kbGUgYWxsIHBvc3NpYmxlIGlucHV0IE5vZGUgdHlwZXMsIHRvIGVuc3VyZSBhbGwgY2FzZXNcbiAgICogY292ZXJlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGVycm9yVW5pbXBsZW1lbnRlZEtpbmQobm9kZTogdHMuTm9kZSwgd2hlcmU6IHN0cmluZykge1xuICAgIHJlcG9ydERpYWdub3N0aWMoZGlhZ25vc3RpY3MsIG5vZGUsIGAke3RzLlN5bnRheEtpbmRbbm9kZS5raW5kXX0gbm90IGltcGxlbWVudGVkIGluICR7d2hlcmV9YCk7XG4gIH1cblxuICAvKipcbiAgICogZ2V0TmFtZXNwYWNlRm9yTG9jYWxEZWNsYXJhdGlvbiByZXR1cm5zIHRoZSBuYW1lc3BhY2UgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgdGhlIGdpdmVuXG4gICAqIGRlY2xhcmF0aW9uLCBkZWNpZGluZyB3aGV0aGVyIHRvIG5hbWVzcGFjZSB0aGUgc3ltYm9sIHRvIHRoZSBmaWxlIG9yIHdoZXRoZXIgdG8gY3JlYXRlIGFcbiAgICogZ2xvYmFsIG5hbWUuXG4gICAqXG4gICAqIFRoZSBmdW5jdGlvbiBjb3ZlcnMgdGhlc2UgY2FzZXM6XG4gICAqIDEpIGEgZGVjbGFyYXRpb24gaW4gYSAuZC50c1xuICAgKiAxYSkgd2hlcmUgdGhlIC5kLnRzIGlzIGFuIGV4dGVybmFsIG1vZHVsZSAgICAgLS0+IG5hbWVzcGFjZVxuICAgKiAxYikgd2hlcmUgdGhlIC5kLnRzIGlzIG5vdCBhbiBleHRlcm5hbCBtb2R1bGUgLS0+IGdsb2JhbFxuICAgKiAyKSBhIGRlY2xhcmF0aW9uIGluIGEgLnRzIGZpbGUgKGFsbCBhcmUgdHJlYXRlZCBhcyBtb2R1bGVzKVxuICAgKiAyYSkgdGhhdCBpcyBleHBvcnRlZCAgICAgICAgICAgICAgICAgICAgICAgICAgLS0+IG5hbWVzcGFjZVxuICAgKiAyYikgdGhhdCBpcyB1bmV4cG9ydGVkICAgICAgICAgICAgICAgICAgICAgICAgLS0+IGdsb2JhbFxuICAgKlxuICAgKiBGb3IgMSksIGFsbCBzeW1ib2xzIGluIC5kLnRzIHNob3VsZCBnZW5lcmFsbHkgYmUgbmFtZXNwYWNlZCB0byB0aGUgZmlsZSB0byBhdm9pZCBjb2xsaXNpb25zLlxuICAgKiBIb3dldmVyIC5kLnRzIGZpbGVzIHRoYXQgYXJlIG5vdCBleHRlcm5hbCBtb2R1bGVzIGRvIGRlY2xhcmUgZ2xvYmFsIG5hbWVzICgxYikuXG4gICAqXG4gICAqIEZvciAyKSwgYW1iaWVudCBkZWNsYXJhdGlvbnMgaW4gLnRzIGZpbGVzIG11c3QgYmUgbmFtZXNwYWNlZCwgZm9yIHRoZSBzYW1lIGNvbGxpc2lvbiByZWFzb25zLlxuICAgKiBUaGUgZXhjZXB0aW9uIGlzIDJiKSwgd2hlcmUgaW4gVHlwZVNjcmlwdCwgYW4gdW5leHBvcnRlZCBsb2NhbCBcImRlY2xhcmUgY29uc3QgeDogc3RyaW5nO1wiXG4gICAqIGNyZWF0ZXMgYSBzeW1ib2wgdGhhdCwgd2hlbiB1c2VkIGxvY2FsbHksIGlzIGVtaXR0ZWQgYXMganVzdCBcInhcIi4gVGhhdCBpcywgaXQgYmVoYXZlc1xuICAgKiBsaWtlIGEgdmFyaWFibGUgZGVjbGFyZWQgaW4gYSAnZGVjbGFyZSBnbG9iYWwnIGJsb2NrLiBDbG9zdXJlIENvbXBpbGVyIHdvdWxkIGZhaWwgdGhlIGJ1aWxkIGlmXG4gICAqIHRoZXJlIGlzIG5vIGRlY2xhcmF0aW9uIGZvciBcInhcIiwgc28gdHNpY2tsZSBtdXN0IGdlbmVyYXRlIGEgZ2xvYmFsIGV4dGVybmFsIHN5bWJvbCwgaS5lLlxuICAgKiB3aXRob3V0IHRoZSBuYW1lc3BhY2Ugd3JhcHBlci5cbiAgICovXG4gIGZ1bmN0aW9uIGdldE5hbWVzcGFjZUZvclRvcExldmVsRGVjbGFyYXRpb24oXG4gICAgICBkZWNsYXJhdGlvbjogdHMuRGVjbGFyYXRpb24sIG5hbWVzcGFjZTogUmVhZG9ubHlBcnJheTxzdHJpbmc+KTogUmVhZG9ubHlBcnJheTxzdHJpbmc+IHtcbiAgICAvLyBPbmx5IHVzZSByb290TmFtZXNwYWNlIGZvciB0b3AgbGV2ZWwgc3ltYm9scywgYW55IG90aGVyIG5hbWVzcGFjaW5nIChnbG9iYWwgbmFtZXMsIG5lc3RlZFxuICAgIC8vIG5hbWVzcGFjZXMpIGlzIGFsd2F5cyBrZXB0LlxuICAgIGlmIChuYW1lc3BhY2UubGVuZ3RoICE9PSAwKSByZXR1cm4gbmFtZXNwYWNlO1xuICAgIC8vIEFsbCBuYW1lcyBpbiBhIG1vZHVsZSAoZXh0ZXJuYWwpIC5kLnRzIGZpbGUgY2FuIG9ubHkgYmUgYWNjZXNzZWQgbG9jYWxseSwgc28gdGhleSBhbHdheXMgZ2V0XG4gICAgLy8gbmFtZXNwYWNlIHByZWZpeGVkLlxuICAgIGlmIChpc0R0cyAmJiBpc0V4dGVybmFsTW9kdWxlKSByZXR1cm4gW3Jvb3ROYW1lc3BhY2VdO1xuICAgIC8vIFNhbWUgZm9yIGV4cG9ydGVkIGRlY2xhcmF0aW9ucyBpbiByZWd1bGFyIC50cyBmaWxlcy5cbiAgICBpZiAoaGFzTW9kaWZpZXJGbGFnKGRlY2xhcmF0aW9uLCB0cy5Nb2RpZmllckZsYWdzLkV4cG9ydCkpIHJldHVybiBbcm9vdE5hbWVzcGFjZV07XG4gICAgLy8gQnV0IGxvY2FsIGRlY2xhcmF0aW9ucyBpbiAudHMgZmlsZXMgb3IgLmQudHMgZmlsZXMgKDFiLCAyYikgYXJlIGdsb2JhbCwgdG9vLlxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciB0aGUgbG9jYXRpb246IGVpdGhlciB0aGUgbmFtZXNwYWNlLCBvciwgaWYgZW1wdHksIHRoZVxuICAgKiBjdXJyZW50IHNvdXJjZSBmaWxlIG5hbWUuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIGVtaXQgZm9yIHdhcm5pbmdzLCBzbyB0aGF0XG4gICAqIHVzZXJzIGNhbiBtb3JlIGVhc2lseSBmaW5kIHdoZXJlIGEgcHJvYmxlbWF0aWMgZGVmaW5pdGlvbiBpcyBmcm9tLlxuICAgKlxuICAgKiBUaGUgY29kZSBiZWxvdyBkb2VzIG5vdCB1c2UgZGlhZ25vc3RpY3MgdG8gYXZvaWQgYnJlYWtpbmcgdGhlIGJ1aWxkIGZvciBoYXJtbGVzcyB1bmhhbmRsZWRcbiAgICogY2FzZXMuXG4gICAqL1xuICBmdW5jdGlvbiBkZWJ1Z0xvY2F0aW9uU3RyKG5vZGU6IHRzLk5vZGUsIG5hbWVzcGFjZTogUmVhZG9ubHlBcnJheTxzdHJpbmc+KSB7XG4gICAgLy8gVXNlIGEgcmVnZXggdG8gZ3JhYiB0aGUgZmlsZW5hbWUgd2l0aG91dCBhIHBhdGgsIHRvIG1ha2UgdGhlIG91dHB1dCBzdGFibGVcbiAgICAvLyB1bmRlciBiYXplbCB3aGVyZSBzYW5kYm94ZXMgdXNlIGRpZmZlcmVudCBwYXRocy5cbiAgICByZXR1cm4gbmFtZXNwYWNlLmpvaW4oJy4nKSB8fCBub2RlLmdldFNvdXJjZUZpbGUoKS5maWxlTmFtZS5yZXBsYWNlKC8uKlsvXFxcXF0vLCAnJyk7XG4gIH1cblxuICBmdW5jdGlvbiB2aXNpdG9yKG5vZGU6IHRzLk5vZGUsIG5hbWVzcGFjZTogUmVhZG9ubHlBcnJheTxzdHJpbmc+KSB7XG4gICAgaWYgKG5vZGUucGFyZW50ID09PSBzb3VyY2VGaWxlKSB7XG4gICAgICBuYW1lc3BhY2UgPSBnZXROYW1lc3BhY2VGb3JUb3BMZXZlbERlY2xhcmF0aW9uKG5vZGUgYXMgdHMuRGVjbGFyYXRpb25TdGF0ZW1lbnQsIG5hbWVzcGFjZSk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChub2RlLmtpbmQpIHtcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5Nb2R1bGVEZWNsYXJhdGlvbjpcbiAgICAgICAgY29uc3QgZGVjbCA9IG5vZGUgYXMgdHMuTW9kdWxlRGVjbGFyYXRpb247XG4gICAgICAgIHN3aXRjaCAoZGVjbC5uYW1lLmtpbmQpIHtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuSWRlbnRpZmllcjpcbiAgICAgICAgICAgIGlmIChkZWNsLmZsYWdzICYgdHMuTm9kZUZsYWdzLkdsb2JhbEF1Z21lbnRhdGlvbikge1xuICAgICAgICAgICAgICAvLyBFLmcuIFwiZGVjbGFyZSBnbG9iYWwgeyAuLi4gfVwiLiAgUmVzZXQgdG8gdGhlIG91dGVyIG5hbWVzcGFjZS5cbiAgICAgICAgICAgICAgbmFtZXNwYWNlID0gW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBFLmcuIFwiZGVjbGFyZSBuYW1lc3BhY2UgZm9vIHtcIlxuICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZ2V0SWRlbnRpZmllclRleHQoZGVjbC5uYW1lIGFzIHRzLklkZW50aWZpZXIpO1xuICAgICAgICAgICAgICBpZiAoaXNGaXJzdFZhbHVlRGVjbGFyYXRpb24oZGVjbCkpIHtcbiAgICAgICAgICAgICAgICBlbWl0KCcvKiogQGNvbnN0ICovXFxuJyk7XG4gICAgICAgICAgICAgICAgd3JpdGVWYXJpYWJsZVN0YXRlbWVudChuYW1lLCBuYW1lc3BhY2UsICd7fScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5hbWVzcGFjZSA9IG5hbWVzcGFjZS5jb25jYXQobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVjbC5ib2R5KSB2aXNpdG9yKGRlY2wuYm9keSwgbmFtZXNwYWNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5TdHJpbmdMaXRlcmFsOlxuICAgICAgICAgICAgLy8gRS5nLiBcImRlY2xhcmUgbW9kdWxlICdmb28nIHtcIiAobm90ZSB0aGUgcXVvdGVzKS5cbiAgICAgICAgICAgIC8vIFdlIHN0aWxsIHdhbnQgdG8gZW1pdCBleHRlcm5zIGZvciB0aGlzIG1vZHVsZSwgYnV0IENsb3N1cmUgZG9lc24ndCBwcm92aWRlIGFcbiAgICAgICAgICAgIC8vIG1lY2hhbmlzbSBmb3IgbW9kdWxlLXNjb3BlZCBleHRlcm5zLiBJbnN0ZWFkLCB3ZSBlbWl0IGluIGEgbWFuZ2xlZCBuYW1lc3BhY2UuXG4gICAgICAgICAgICAvLyBUaGUgbWFuZ2xlZCBuYW1lc3BhY2UgKGFmdGVyIHJlc29sdmluZyBmaWxlcykgbWF0Y2hlcyB0aGUgZW1pdCBmb3IgYW4gb3JpZ2luYWwgbW9kdWxlXG4gICAgICAgICAgICAvLyBmaWxlLCBzbyBlZmZlY3RpdmVseSB0aGlzIGF1Z21lbnRzIGFueSBleGlzdGluZyBtb2R1bGUuXG5cbiAgICAgICAgICAgIGNvbnN0IGltcG9ydE5hbWUgPSAoZGVjbC5uYW1lIGFzIHRzLlN0cmluZ0xpdGVyYWwpLnRleHQ7XG4gICAgICAgICAgICBjb25zdCBpbXBvcnRlZE1vZHVsZU5hbWUgPVxuICAgICAgICAgICAgICAgIHJlc29sdmVNb2R1bGVOYW1lKHttb2R1bGVSZXNvbHV0aW9uSG9zdCwgb3B0aW9uc30sIHNvdXJjZUZpbGUuZmlsZU5hbWUsIGltcG9ydE5hbWUpO1xuICAgICAgICAgICAgY29uc3QgbWFuZ2xlZCA9IG1vZHVsZU5hbWVBc0lkZW50aWZpZXIoaG9zdCwgaW1wb3J0ZWRNb2R1bGVOYW1lKTtcbiAgICAgICAgICAgIGVtaXQoYC8vIERlcml2ZWQgZnJvbTogZGVjbGFyZSBtb2R1bGUgXCIke2ltcG9ydE5hbWV9XCJcXG5gKTtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IFttYW5nbGVkXTtcblxuICAgICAgICAgICAgLy8gRGVjbGFyZSBcIm1hbmdsZWQkbmFtZVwiIGlmIGl0J3Mgbm90IGRlY2xhcmVkIGFscmVhZHkgZWxzZXdoZXJlLlxuICAgICAgICAgICAgaWYgKGlzRmlyc3RWYWx1ZURlY2xhcmF0aW9uKGRlY2wpKSB7XG4gICAgICAgICAgICAgIGVtaXQoJy8qKiBAY29uc3QgKi9cXG4nKTtcbiAgICAgICAgICAgICAgd3JpdGVWYXJpYWJsZVN0YXRlbWVudChtYW5nbGVkLCBbXSwgJ3t9Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWNsYXJlIHRoZSBjb250ZW50cyBpbnNpZGUgdGhlIFwibWFuZ2xlZCRuYW1lXCIuXG4gICAgICAgICAgICBpZiAoZGVjbC5ib2R5KSB2aXNpdG9yKGRlY2wuYm9keSwgW21hbmdsZWRdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBlcnJvclVuaW1wbGVtZW50ZWRLaW5kKGRlY2wubmFtZSwgJ2V4dGVybnMgZ2VuZXJhdGlvbiBvZiBuYW1lc3BhY2UnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLk1vZHVsZUJsb2NrOlxuICAgICAgICBjb25zdCBibG9jayA9IG5vZGUgYXMgdHMuTW9kdWxlQmxvY2s7XG4gICAgICAgIGZvciAoY29uc3Qgc3RtdCBvZiBibG9jay5zdGF0ZW1lbnRzKSB7XG4gICAgICAgICAgdmlzaXRvcihzdG10LCBuYW1lc3BhY2UpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkltcG9ydEVxdWFsc0RlY2xhcmF0aW9uOlxuICAgICAgICBjb25zdCBpbXBvcnRFcXVhbHMgPSBub2RlIGFzIHRzLkltcG9ydEVxdWFsc0RlY2xhcmF0aW9uO1xuICAgICAgICBjb25zdCBsb2NhbE5hbWUgPSBnZXRJZGVudGlmaWVyVGV4dChpbXBvcnRFcXVhbHMubmFtZSk7XG4gICAgICAgIGlmIChsb2NhbE5hbWUgPT09ICduZycpIHtcbiAgICAgICAgICBlbWl0KGBcXG4vKiBTa2lwcGluZyBwcm9ibGVtYXRpYyBpbXBvcnQgbmcgPSAuLi47ICovXFxuYCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltcG9ydEVxdWFscy5tb2R1bGVSZWZlcmVuY2Uua2luZCA9PT0gdHMuU3ludGF4S2luZC5FeHRlcm5hbE1vZHVsZVJlZmVyZW5jZSkge1xuICAgICAgICAgIGFkZEltcG9ydEFsaWFzZXMoaW1wb3J0RXF1YWxzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxbiA9IGdldEVudGl0eU5hbWVUZXh0KGltcG9ydEVxdWFscy5tb2R1bGVSZWZlcmVuY2UpO1xuICAgICAgICAvLyBAY29uc3Qgc28gdGhhdCBDbG9zdXJlIENvbXBpbGVyIHVuZGVyc3RhbmRzIHRoaXMgaXMgYW4gYWxpYXMuXG4gICAgICAgIGlmIChuYW1lc3BhY2UubGVuZ3RoID09PSAwKSBlbWl0KCcvKiogQGNvbnN0ICovXFxuJyk7XG4gICAgICAgIHdyaXRlVmFyaWFibGVTdGF0ZW1lbnQobG9jYWxOYW1lLCBuYW1lc3BhY2UsIHFuKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuQ2xhc3NEZWNsYXJhdGlvbjpcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5JbnRlcmZhY2VEZWNsYXJhdGlvbjpcbiAgICAgICAgd3JpdGVUeXBlKG5vZGUgYXMgdHMuSW50ZXJmYWNlRGVjbGFyYXRpb24gfCB0cy5DbGFzc0RlY2xhcmF0aW9uLCBuYW1lc3BhY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5GdW5jdGlvbkRlY2xhcmF0aW9uOlxuICAgICAgICBjb25zdCBmbkRlY2wgPSBub2RlIGFzIHRzLkZ1bmN0aW9uRGVjbGFyYXRpb247XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmbkRlY2wubmFtZTtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgcmVwb3J0RGlhZ25vc3RpYyhkaWFnbm9zdGljcywgZm5EZWNsLCAnYW5vbnltb3VzIGZ1bmN0aW9uIGluIGV4dGVybnMnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBHYXRoZXIgdXAgYWxsIG92ZXJsb2FkcyBvZiB0aGlzIGZ1bmN0aW9uLlxuICAgICAgICBjb25zdCBzeW0gPSB0eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKG5hbWUpITtcbiAgICAgICAgY29uc3QgZGVjbHMgPSBzeW0uZGVjbGFyYXRpb25zIS5maWx0ZXIodHMuaXNGdW5jdGlvbkRlY2xhcmF0aW9uKTtcbiAgICAgICAgLy8gT25seSBlbWl0IHRoZSBmaXJzdCBkZWNsYXJhdGlvbiBvZiBlYWNoIG92ZXJsb2FkZWQgZnVuY3Rpb24uXG4gICAgICAgIGlmIChmbkRlY2wgIT09IGRlY2xzWzBdKSBicmVhaztcbiAgICAgICAgY29uc3QgcGFyYW1zID0gZW1pdEZ1bmN0aW9uVHlwZShkZWNscyk7XG4gICAgICAgIHdyaXRlRnVuY3Rpb24obmFtZSwgcGFyYW1zLCBuYW1lc3BhY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5WYXJpYWJsZVN0YXRlbWVudDpcbiAgICAgICAgZm9yIChjb25zdCBkZWNsIG9mIChub2RlIGFzIHRzLlZhcmlhYmxlU3RhdGVtZW50KS5kZWNsYXJhdGlvbkxpc3QuZGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgd3JpdGVWYXJpYWJsZURlY2xhcmF0aW9uKGRlY2wsIG5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuRW51bURlY2xhcmF0aW9uOlxuICAgICAgICB3cml0ZUVudW0obm9kZSBhcyB0cy5FbnVtRGVjbGFyYXRpb24sIG5hbWVzcGFjZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlR5cGVBbGlhc0RlY2xhcmF0aW9uOlxuICAgICAgICB3cml0ZVR5cGVBbGlhcyhub2RlIGFzIHRzLlR5cGVBbGlhc0RlY2xhcmF0aW9uLCBuYW1lc3BhY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5JbXBvcnREZWNsYXJhdGlvbjpcbiAgICAgICAgYWRkSW1wb3J0QWxpYXNlcyhub2RlIGFzIHRzLkltcG9ydERlY2xhcmF0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb246XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuRXhwb3J0QXNzaWdubWVudDpcbiAgICAgICAgLy8gSGFuZGxlZCBvbiB0aGUgZmlsZSBsZXZlbC5cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuRXhwb3J0RGVjbGFyYXRpb246XG4gICAgICAgIGNvbnN0IGV4cG9ydERlY2xhcmF0aW9uID0gbm9kZSBhcyB0cy5FeHBvcnREZWNsYXJhdGlvbjtcbiAgICAgICAgd3JpdGVFeHBvcnREZWNsYXJhdGlvbihleHBvcnREZWNsYXJhdGlvbiwgbmFtZXNwYWNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBlbWl0KGBcXG4vLyBUT0RPKHRzaWNrbGUpOiAke3RzLlN5bnRheEtpbmRbbm9kZS5raW5kXX0gaW4gJHtcbiAgICAgICAgICAgIGRlYnVnTG9jYXRpb25TdHIobm9kZSwgbmFtZXNwYWNlKX1cXG5gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG4iXX0=