/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/await_transformer", ["require", "exports", "typescript", "tsickle/src/transformer_util"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const ts = require("typescript");
    const transformerUtil = require("tsickle/src/transformer_util");
    /** Returns the nearest ancestor node that's a function or method declaration. */
    function getContainingFunctionLikeDeclaration(node) {
        while (node) {
            if (ts.isFunctionDeclaration(node) || ts.isMethodDeclaration(node))
                return node;
            node = node.parent;
        }
        return undefined;
    }
    exports.getContainingFunctionLikeDeclaration = getContainingFunctionLikeDeclaration;
    /**
     * awaitTransformer returns a transformer factory that handles await statements after they
     * have been transformed. TypeScript down-levels await statements to code like:
     *     tslib_1.__awaiter(this, void 0, void 0, function* () { ... }
     *
     * The generator function ("function* ...") needs the appropriate `\@this` annotation for Closure,
     * which this transformer inserts.
     *
     * This transformer is only needed (and only run by tsickle) when down-leveling await statements.
     *
     * @param thisTypeByAsyncFunction A map containing the context `this` type for all async function
     *     declarations. This is produced by jsdoc_transformer, as during that stage tsickle can insert
     *     imports and generally deals with types, whereas this code just post-processes TypeScript's
     *     emit.
     */
    function awaitTransformer(thisTypeByAsyncFunction) {
        return (context) => {
            return (sourceFile) => {
                function visitAwaiterCall(awaiterCall) {
                    // __awaiter's last argument is always a function*() {...}
                    const generatorFn = awaiterCall.arguments[3];
                    if (!generatorFn || !ts.isFunctionExpression(generatorFn))
                        return;
                    const fnDecl = getContainingFunctionLikeDeclaration(ts.getOriginalNode(generatorFn.body));
                    if (!fnDecl)
                        return;
                    const thisType = thisTypeByAsyncFunction.get(fnDecl);
                    if (!thisType)
                        return;
                    const comment = {
                        kind: ts.SyntaxKind.MultiLineCommentTrivia,
                        text: `* @this {${thisType}} `,
                        pos: -1,
                        end: -1,
                    };
                    const comments = ts.getSyntheticLeadingComments(generatorFn) || [];
                    comments.push(comment);
                    ts.setSyntheticLeadingComments(generatorFn, comments);
                }
                function visitor(node) {
                    // Find a call to __awaiter(this, ..., ..., *function() { original code }).
                    // There is no access of "tslib.__awaiter" yet, the import access is inserted later on emit.
                    if (ts.isCallExpression(node) && ts.isIdentifier(node.expression) &&
                        transformerUtil.getIdentifierText(node.expression) === '__awaiter') {
                        visitAwaiterCall(node);
                    }
                    return ts.visitEachChild(node, visitor, context);
                }
                sourceFile = ts.visitEachChild(sourceFile, visitor, context);
                return sourceFile;
            };
        };
    }
    exports.awaitTransformer = awaitTransformer;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXdhaXRfdHJhbnNmb3JtZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvYXdhaXRfdHJhbnNmb3JtZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HOzs7Ozs7Ozs7Ozs7SUFFSCxpQ0FBaUM7SUFFakMsZ0VBQXNEO0lBRXRELGlGQUFpRjtJQUNqRixTQUFnQixvQ0FBb0MsQ0FBQyxJQUFhO1FBQ2hFLE9BQU8sSUFBSSxFQUFFO1lBQ1gsSUFBSSxFQUFFLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQztnQkFBRSxPQUFPLElBQUksQ0FBQztZQUNoRixJQUFJLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztTQUNwQjtRQUNELE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFORCxvRkFNQztJQUVEOzs7Ozs7Ozs7Ozs7OztPQWNHO0lBQ0gsU0FBZ0IsZ0JBQWdCLENBQUMsdUJBQWdFO1FBRS9GLE9BQU8sQ0FBQyxPQUFpQyxFQUFpQyxFQUFFO1lBQzFFLE9BQU8sQ0FBQyxVQUF5QixFQUFFLEVBQUU7Z0JBQ25DLFNBQVMsZ0JBQWdCLENBQUMsV0FBOEI7b0JBQ3RELDBEQUEwRDtvQkFDMUQsTUFBTSxXQUFXLEdBQUcsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDN0MsSUFBSSxDQUFDLFdBQVcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxvQkFBb0IsQ0FBQyxXQUFXLENBQUM7d0JBQUUsT0FBTztvQkFDbEUsTUFBTSxNQUFNLEdBQUcsb0NBQW9DLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztvQkFDMUYsSUFBSSxDQUFDLE1BQU07d0JBQUUsT0FBTztvQkFDcEIsTUFBTSxRQUFRLEdBQUcsdUJBQXVCLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO29CQUNyRCxJQUFJLENBQUMsUUFBUTt3QkFBRSxPQUFPO29CQUN0QixNQUFNLE9BQU8sR0FBMEI7d0JBQ3JDLElBQUksRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLHNCQUFzQjt3QkFDMUMsSUFBSSxFQUFFLFlBQVksUUFBUSxJQUFJO3dCQUM5QixHQUFHLEVBQUUsQ0FBQyxDQUFDO3dCQUNQLEdBQUcsRUFBRSxDQUFDLENBQUM7cUJBQ1IsQ0FBQztvQkFDRixNQUFNLFFBQVEsR0FBRyxFQUFFLENBQUMsMkJBQTJCLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxDQUFDO29CQUNuRSxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO29CQUN2QixFQUFFLENBQUMsMkJBQTJCLENBQUMsV0FBVyxFQUFFLFFBQVEsQ0FBQyxDQUFDO2dCQUN4RCxDQUFDO2dCQUNELFNBQVMsT0FBTyxDQUFDLElBQWE7b0JBQzVCLDJFQUEyRTtvQkFDM0UsNEZBQTRGO29CQUM1RixJQUFJLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7d0JBQzdELGVBQWUsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssV0FBVyxFQUFFO3dCQUN0RSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztxQkFDeEI7b0JBQ0QsT0FBTyxFQUFFLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7Z0JBQ25ELENBQUM7Z0JBQ0QsVUFBVSxHQUFHLEVBQUUsQ0FBQyxjQUFjLENBQUMsVUFBVSxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztnQkFDN0QsT0FBTyxVQUFVLENBQUM7WUFDcEIsQ0FBQyxDQUFDO1FBQ0osQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQW5DRCw0Q0FtQ0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCAqIGFzIHRzIGZyb20gJ3R5cGVzY3JpcHQnO1xuXG5pbXBvcnQgKiBhcyB0cmFuc2Zvcm1lclV0aWwgZnJvbSAnLi90cmFuc2Zvcm1lcl91dGlsJztcblxuLyoqIFJldHVybnMgdGhlIG5lYXJlc3QgYW5jZXN0b3Igbm9kZSB0aGF0J3MgYSBmdW5jdGlvbiBvciBtZXRob2QgZGVjbGFyYXRpb24uICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Z1bmN0aW9uTGlrZURlY2xhcmF0aW9uKG5vZGU6IHRzLk5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAodHMuaXNGdW5jdGlvbkRlY2xhcmF0aW9uKG5vZGUpIHx8IHRzLmlzTWV0aG9kRGVjbGFyYXRpb24obm9kZSkpIHJldHVybiBub2RlO1xuICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIGF3YWl0VHJhbnNmb3JtZXIgcmV0dXJucyBhIHRyYW5zZm9ybWVyIGZhY3RvcnkgdGhhdCBoYW5kbGVzIGF3YWl0IHN0YXRlbWVudHMgYWZ0ZXIgdGhleVxuICogaGF2ZSBiZWVuIHRyYW5zZm9ybWVkLiBUeXBlU2NyaXB0IGRvd24tbGV2ZWxzIGF3YWl0IHN0YXRlbWVudHMgdG8gY29kZSBsaWtlOlxuICogICAgIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkgeyAuLi4gfVxuICpcbiAqIFRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gKFwiZnVuY3Rpb24qIC4uLlwiKSBuZWVkcyB0aGUgYXBwcm9wcmlhdGUgYFxcQHRoaXNgIGFubm90YXRpb24gZm9yIENsb3N1cmUsXG4gKiB3aGljaCB0aGlzIHRyYW5zZm9ybWVyIGluc2VydHMuXG4gKlxuICogVGhpcyB0cmFuc2Zvcm1lciBpcyBvbmx5IG5lZWRlZCAoYW5kIG9ubHkgcnVuIGJ5IHRzaWNrbGUpIHdoZW4gZG93bi1sZXZlbGluZyBhd2FpdCBzdGF0ZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB0aGlzVHlwZUJ5QXN5bmNGdW5jdGlvbiBBIG1hcCBjb250YWluaW5nIHRoZSBjb250ZXh0IGB0aGlzYCB0eXBlIGZvciBhbGwgYXN5bmMgZnVuY3Rpb25cbiAqICAgICBkZWNsYXJhdGlvbnMuIFRoaXMgaXMgcHJvZHVjZWQgYnkganNkb2NfdHJhbnNmb3JtZXIsIGFzIGR1cmluZyB0aGF0IHN0YWdlIHRzaWNrbGUgY2FuIGluc2VydFxuICogICAgIGltcG9ydHMgYW5kIGdlbmVyYWxseSBkZWFscyB3aXRoIHR5cGVzLCB3aGVyZWFzIHRoaXMgY29kZSBqdXN0IHBvc3QtcHJvY2Vzc2VzIFR5cGVTY3JpcHQnc1xuICogICAgIGVtaXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhd2FpdFRyYW5zZm9ybWVyKHRoaXNUeXBlQnlBc3luY0Z1bmN0aW9uOiBNYXA8dHMuRnVuY3Rpb25MaWtlRGVjbGFyYXRpb24sIHN0cmluZz4pOlxuICAgIChjb250ZXh0OiB0cy5UcmFuc2Zvcm1hdGlvbkNvbnRleHQpID0+IHRzLlRyYW5zZm9ybWVyPHRzLlNvdXJjZUZpbGU+IHtcbiAgcmV0dXJuIChjb250ZXh0OiB0cy5UcmFuc2Zvcm1hdGlvbkNvbnRleHQpOiB0cy5UcmFuc2Zvcm1lcjx0cy5Tb3VyY2VGaWxlPiA9PiB7XG4gICAgcmV0dXJuIChzb3VyY2VGaWxlOiB0cy5Tb3VyY2VGaWxlKSA9PiB7XG4gICAgICBmdW5jdGlvbiB2aXNpdEF3YWl0ZXJDYWxsKGF3YWl0ZXJDYWxsOiB0cy5DYWxsRXhwcmVzc2lvbikge1xuICAgICAgICAvLyBfX2F3YWl0ZXIncyBsYXN0IGFyZ3VtZW50IGlzIGFsd2F5cyBhIGZ1bmN0aW9uKigpIHsuLi59XG4gICAgICAgIGNvbnN0IGdlbmVyYXRvckZuID0gYXdhaXRlckNhbGwuYXJndW1lbnRzWzNdO1xuICAgICAgICBpZiAoIWdlbmVyYXRvckZuIHx8ICF0cy5pc0Z1bmN0aW9uRXhwcmVzc2lvbihnZW5lcmF0b3JGbikpIHJldHVybjtcbiAgICAgICAgY29uc3QgZm5EZWNsID0gZ2V0Q29udGFpbmluZ0Z1bmN0aW9uTGlrZURlY2xhcmF0aW9uKHRzLmdldE9yaWdpbmFsTm9kZShnZW5lcmF0b3JGbi5ib2R5KSk7XG4gICAgICAgIGlmICghZm5EZWNsKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHRoaXNUeXBlID0gdGhpc1R5cGVCeUFzeW5jRnVuY3Rpb24uZ2V0KGZuRGVjbCk7XG4gICAgICAgIGlmICghdGhpc1R5cGUpIHJldHVybjtcbiAgICAgICAgY29uc3QgY29tbWVudDogdHMuU3ludGhlc2l6ZWRDb21tZW50ID0ge1xuICAgICAgICAgIGtpbmQ6IHRzLlN5bnRheEtpbmQuTXVsdGlMaW5lQ29tbWVudFRyaXZpYSxcbiAgICAgICAgICB0ZXh0OiBgKiBAdGhpcyB7JHt0aGlzVHlwZX19IGAsXG4gICAgICAgICAgcG9zOiAtMSxcbiAgICAgICAgICBlbmQ6IC0xLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb21tZW50cyA9IHRzLmdldFN5bnRoZXRpY0xlYWRpbmdDb21tZW50cyhnZW5lcmF0b3JGbikgfHwgW107XG4gICAgICAgIGNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgIHRzLnNldFN5bnRoZXRpY0xlYWRpbmdDb21tZW50cyhnZW5lcmF0b3JGbiwgY29tbWVudHMpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdmlzaXRvcihub2RlOiB0cy5Ob2RlKTogdHMuTm9kZXx0cy5Ob2RlW10ge1xuICAgICAgICAvLyBGaW5kIGEgY2FsbCB0byBfX2F3YWl0ZXIodGhpcywgLi4uLCAuLi4sICpmdW5jdGlvbigpIHsgb3JpZ2luYWwgY29kZSB9KS5cbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gYWNjZXNzIG9mIFwidHNsaWIuX19hd2FpdGVyXCIgeWV0LCB0aGUgaW1wb3J0IGFjY2VzcyBpcyBpbnNlcnRlZCBsYXRlciBvbiBlbWl0LlxuICAgICAgICBpZiAodHMuaXNDYWxsRXhwcmVzc2lvbihub2RlKSAmJiB0cy5pc0lkZW50aWZpZXIobm9kZS5leHByZXNzaW9uKSAmJlxuICAgICAgICAgICAgdHJhbnNmb3JtZXJVdGlsLmdldElkZW50aWZpZXJUZXh0KG5vZGUuZXhwcmVzc2lvbikgPT09ICdfX2F3YWl0ZXInKSB7XG4gICAgICAgICAgdmlzaXRBd2FpdGVyQ2FsbChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHMudmlzaXRFYWNoQ2hpbGQobm9kZSwgdmlzaXRvciwgY29udGV4dCk7XG4gICAgICB9XG4gICAgICBzb3VyY2VGaWxlID0gdHMudmlzaXRFYWNoQ2hpbGQoc291cmNlRmlsZSwgdmlzaXRvciwgY29udGV4dCk7XG4gICAgICByZXR1cm4gc291cmNlRmlsZTtcbiAgICB9O1xuICB9O1xufVxuIl19