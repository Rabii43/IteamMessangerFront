/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/googmodule", ["require", "exports", "typescript", "tsickle/src/path", "tsickle/src/transformer_util"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const ts = require("typescript");
    const path = require("tsickle/src/path");
    const transformer_util_1 = require("tsickle/src/transformer_util");
    /**
     * Returns true if node is a property access of `child` on the identifier `parent`.
     */
    function isPropertyAccess(node, parent, child) {
        if (!ts.isPropertyAccessExpression(node))
            return false;
        return ts.isIdentifier(node.expression) && node.expression.escapedText === parent &&
            node.name.escapedText === child;
    }
    /** Returns true if expr is "module.exports = ...;". */
    function isModuleExportsAssignment(expr) {
        if (!ts.isBinaryExpression(expr.expression))
            return false;
        if (expr.expression.operatorToken.kind !== ts.SyntaxKind.EqualsToken)
            return false;
        return isPropertyAccess(expr.expression.left, 'module', 'exports');
    }
    /** Returns true if expr is "exports = ...;". */
    function isExportsAssignment(expr) {
        if (!ts.isBinaryExpression(expr.expression))
            return false;
        if (expr.expression.operatorToken.kind !== ts.SyntaxKind.EqualsToken)
            return false;
        return ts.isIdentifier(expr.expression.left) && expr.expression.left.text === 'exports';
    }
    /** isUseStrict returns true if node is a "use strict"; statement. */
    function isUseStrict(node) {
        if (node.kind !== ts.SyntaxKind.ExpressionStatement)
            return false;
        const exprStmt = node;
        const expr = exprStmt.expression;
        if (expr.kind !== ts.SyntaxKind.StringLiteral)
            return false;
        const literal = expr;
        return literal.text === 'use strict';
    }
    /**
     * TypeScript inserts the following code to mark ES moduels in CommonJS:
     *   Object.defineProperty(exports, "__esModule", { value: true });
     * This matches that code snippet.
     */
    function isEsModuleProperty(stmt) {
        // We're matching the explicit source text generated by the TS compiler.
        // Object.defineProperty(exports, "__esModule", { value: true });
        const expr = stmt.expression;
        if (!ts.isCallExpression(expr))
            return false;
        if (!isPropertyAccess(expr.expression, 'Object', 'defineProperty'))
            return false;
        if (expr.arguments.length !== 3)
            return false;
        const [exp, esM, val] = expr.arguments;
        if (!ts.isIdentifier(exp) || exp.escapedText !== 'exports')
            return false;
        if (!ts.isStringLiteral(esM) || esM.text !== '__esModule')
            return false;
        if (!ts.isObjectLiteralExpression(val) || val.properties.length !== 1)
            return false;
        const prop = val.properties[0];
        if (!ts.isPropertyAssignment(prop))
            return false;
        const ident = prop.name;
        if (!ident || !ts.isIdentifier(ident) || ident.text !== 'value')
            return false;
        return prop.initializer.kind === ts.SyntaxKind.TrueKeyword;
    }
    /**
     * Returns the string argument if call is of the form
     *   require('foo')
     */
    function extractRequire(call) {
        // Verify that the call is a call to require(...).
        if (call.expression.kind !== ts.SyntaxKind.Identifier)
            return null;
        const ident = call.expression;
        if (ident.escapedText !== 'require')
            return null;
        // Verify the call takes a single string argument and grab it.
        if (call.arguments.length !== 1)
            return null;
        const arg = call.arguments[0];
        if (arg.kind !== ts.SyntaxKind.StringLiteral)
            return null;
        return arg.text;
    }
    /** Creates a call expression corresponding to `goog.${methodName}(${literal})`. */
    function createGoogCall(methodName, literal) {
        return ts.createCall(ts.createPropertyAccess(ts.createIdentifier('goog'), methodName), undefined, [literal]);
    }
    /**
     * Extracts the namespace part of a goog: import URL, or returns null if the given import URL is not
     * a goog: import.
     *
     * For example, for `import 'goog:foo.Bar';`, returns `foo.Bar`.
     */
    function extractGoogNamespaceImport(tsImport) {
        if (tsImport.match(/^goog:/))
            return tsImport.substring('goog:'.length);
        return null;
    }
    exports.extractGoogNamespaceImport = extractGoogNamespaceImport;
    /**
     * Convert from implicit `import {} from 'pkg'` to a full resolved file name, including any `/index`
     * suffix and also resolving path mappings. TypeScript and many module loaders support the
     * shorthand, but `goog.module` does not, so tsickle needs to resolve the module name shorthand
     * before generating `goog.module` names.
     */
    function resolveModuleName({ options, moduleResolutionHost }, pathOfImportingFile, imported) {
        // The strategy taken here is to use ts.resolveModuleName() to resolve the import to
        // a specific path, which resolves any /index and path mappings.
        const resolved = ts.resolveModuleName(imported, pathOfImportingFile, options, moduleResolutionHost);
        if (!resolved || !resolved.resolvedModule)
            return imported;
        const resolvedModule = resolved.resolvedModule.resolvedFileName;
        // Check if the resolution went into node_modules.
        // Note that the ResolvedModule returned by resolveModuleName() has an
        // attribute isExternalLibraryImport that is documented with
        // "True if resolvedFileName comes from node_modules", but actually it is just
        // true if the absolute path includes node_modules, and is always true when
        // tsickle itself is under a directory named node_modules.
        const relativeResolved = path.relative(options.rootDir || '', resolvedModule);
        if (relativeResolved.indexOf('node_modules') !== -1) {
            // Imports into node_modules resolve through package.json and must be
            // specially handled by the loader anyway.  Return the input.
            return imported;
        }
        // Otherwise return the full resolved file name. This path will be turned into a module name using
        // AnnotatorHost#pathToModuleName, which also takes care of baseUrl and rootDirs.
        return resolved.resolvedModule.resolvedFileName;
    }
    exports.resolveModuleName = resolveModuleName;
    /**
     * importPathToGoogNamespace converts a TS/ES module './import/path' into a goog.module compatible
     * namespace, handling regular imports and `goog:` namespace imports.
     */
    function importPathToGoogNamespace(host, file, tsImport) {
        let modName;
        const nsImport = extractGoogNamespaceImport(tsImport);
        if (nsImport !== null) {
            // This is a namespace import, of the form "goog:foo.bar".
            // Fix it to just "foo.bar".
            modName = nsImport;
        }
        else {
            if (host.convertIndexImportShorthand) {
                tsImport = resolveModuleName(host, file.fileName, tsImport);
            }
            modName = host.pathToModuleName(file.fileName, tsImport);
        }
        return transformer_util_1.createSingleQuoteStringLiteral(modName);
    }
    /**
     * Replace "module.exports = ..." with just "exports = ...". Returns null if `expr` is not an
     * exports assignment.
     */
    function rewriteModuleExportsAssignment(expr) {
        if (!ts.isBinaryExpression(expr.expression))
            return null;
        if (expr.expression.operatorToken.kind !== ts.SyntaxKind.EqualsToken)
            return null;
        if (!isPropertyAccess(expr.expression.left, 'module', 'exports'))
            return null;
        return ts.setOriginalNode(ts.setTextRange(ts.createStatement(ts.createAssignment(ts.createIdentifier('exports'), expr.expression.right)), expr), expr);
    }
    /**
     * Convert a series of comma-separated expressions
     *   x = foo, y(), z.bar();
     * with statements
     *   x = foo; y(); z.bar();
     * This is for handling in particular the case where
     *   exports.x = ..., exports.y = ...;
     * which Closure rejects.
     *
     * @return An array of statements if it converted, or null otherwise.
     */
    function rewriteCommaExpressions(expr) {
        // Early exit if the outer statement isn't a comma statement.
        if (!ts.isBinaryExpression(expr.expression))
            return null;
        if (expr.expression.operatorToken.kind !== ts.SyntaxKind.CommaToken)
            return null;
        // Recursively visit comma-separated subexpressions, and collect them all as
        // separate expression statements.
        return visit(expr.expression);
        function visit(expr) {
            if (ts.isBinaryExpression(expr) && expr.operatorToken.kind === ts.SyntaxKind.CommaToken) {
                return visit(expr.left).concat(visit(expr.right));
            }
            return [ts.setOriginalNode(ts.createExpressionStatement(expr), expr)];
        }
    }
    /**
     * commonJsToGoogmoduleTransformer returns a transformer factory that converts TypeScript's CommonJS
     * module emit to Closure Compiler compatible goog.module and goog.require statements.
     */
    function commonJsToGoogmoduleTransformer(host, modulesManifest, typeChecker, diagnostics) {
        return (context) => {
            // TS' CommonJS processing uses onSubstituteNode to, at the very end of processing, substitute
            // "modulename.default" for default imports. We intercept the substitution here, check if it's a
            // .default access, then check if the original node (and thus original import) was from a goog:
            // module, and if so, replace with just the module name.
            const previousOnSubstituteNode = context.onSubstituteNode;
            context.enableSubstitution(ts.SyntaxKind.PropertyAccessExpression);
            context.onSubstituteNode = (hint, node) => {
                node = previousOnSubstituteNode(hint, node);
                if (!ts.isPropertyAccessExpression(node))
                    return node;
                if (node.name.text !== 'default')
                    return node;
                if (!ts.isIdentifier(node.expression))
                    return node;
                // Find the import declaration this node comes from.
                // This may be the original node, if the identifier was transformed from it.
                const orig = ts.getOriginalNode(node.expression);
                let importExportDecl;
                if (ts.isImportDeclaration(orig) || ts.isExportDeclaration(orig)) {
                    importExportDecl = orig;
                }
                else {
                    // Alternatively, we can try to find the declaration of the symbol. This only works for
                    // user-written .default accesses, the generated ones do not have a symbol associated as
                    // they are only produced in the CommonJS transformation, after type checking.
                    const sym = typeChecker.getSymbolAtLocation(node.expression);
                    if (!sym)
                        return node;
                    const decls = sym.getDeclarations();
                    if (!decls || !decls.length)
                        return node;
                    const decl = decls[0];
                    if (decl.parent && decl.parent.parent && ts.isImportDeclaration(decl.parent.parent)) {
                        importExportDecl = decl.parent.parent;
                    }
                    else {
                        return node;
                    }
                }
                // If the import declaration's URL is a "goog:..." style namespace, then all ".default"
                // accesses on it should be replaced with the symbol itself.
                // This allows referring to the module-level export of a "goog.module" or "goog.provide" as if
                // it was an ES6 default export.
                if (extractGoogNamespaceImport(importExportDecl.moduleSpecifier.text)) {
                    // Substitute "foo.default" with just "foo".
                    return node.expression;
                }
                return node;
            };
            return (sf) => {
                // In TS2.9, transformers can receive Bundle objects, which this code cannot handle (given
                // that a bundle by definition cannot be a goog.module()). The cast through any is necessary
                // to remain compatible with earlier TS versions.
                // tslint:disable-next-line:no-any
                if (sf.kind !== ts.SyntaxKind.SourceFile)
                    return sf;
                // JS scripts (as opposed to modules), must not be rewritten to
                // goog.modules.
                if (host.isJsTranspilation && !isModule(sf)) {
                    return sf;
                }
                let moduleVarCounter = 1;
                /**
                 * Creates a new unique variable to assign side effect imports into. This allows us to re-use
                 * the variable later on for other imports of the same namespace.
                 */
                function nextModuleVar() {
                    return `tsickle_module_${moduleVarCounter++}_`;
                }
                /**
                 * Maps goog.require namespaces to the variable name they are assigned into. E.g.:
                 *     var $varName = goog.require('$namespace'));
                 */
                const namespaceToModuleVarName = new Map();
                /**
                 * maybeCreateGoogRequire returns a `goog.require()` call for the given CommonJS `require`
                 * call. Returns null if `call` is not a CommonJS require.
                 */
                function maybeCreateGoogRequire(original, call, newIdent) {
                    const importedUrl = extractRequire(call);
                    if (!importedUrl)
                        return null;
                    const imp = importPathToGoogNamespace(host, sf, importedUrl);
                    modulesManifest.addReferencedModule(sf.fileName, imp.text);
                    const ident = namespaceToModuleVarName.get(imp.text);
                    let initializer;
                    if (!ident) {
                        namespaceToModuleVarName.set(imp.text, newIdent);
                        initializer = createGoogCall('require', imp);
                    }
                    else {
                        initializer = ident;
                    }
                    // In JS modules it's recommended that users get a handle on the
                    // goog namespace via:
                    //
                    //    import * as goog from 'google3/javascript/closure/goog.js';
                    //
                    // In a goog.module we just want to access the global `goog` value,
                    // so we skip emitting that import as a goog.require.
                    // We check the goog module name so that we also catch relative imports.
                    if (newIdent.escapedText === 'goog' && imp.text === 'google3.javascript.closure.goog') {
                        return transformer_util_1.createNotEmittedStatementWithComments(sf, original);
                    }
                    const varDecl = ts.createVariableDeclaration(newIdent, /* type */ undefined, initializer);
                    const newStmt = ts.createVariableStatement(
                    /* modifiers */ undefined, ts.createVariableDeclarationList([varDecl], 
                    // Use 'const' in ES6 mode so Closure properly forwards type aliases.
                    host.es5Mode ? undefined : ts.NodeFlags.Const));
                    return ts.setOriginalNode(ts.setTextRange(newStmt, original), original);
                }
                /**
                 * Rewrite goog.declareModuleId to something that works in a goog.module.
                 *
                 * goog.declareModuleId exposes a JS module as a goog.module. After we
                 * convert the JS module to a goog.module, what we really want is to
                 * expose the current goog.module at two different module ids. This isn't
                 * possible with the public APIs, but we can make it work at runtime
                 * by writing a record to goog.loadedModules_.
                 *
                 * This only works at runtime, and would fail if compiled by closure
                 * compiler, but that's ok because we only transpile JS in development
                 * mode.
                 */
                function maybeRewriteDeclareModuleId(original, call) {
                    // Verify that the call is a call to goog.declareModuleId(...).
                    if (!ts.isPropertyAccessExpression(call.expression)) {
                        return null;
                    }
                    const propAccess = call.expression;
                    if (propAccess.name.escapedText !== 'declareModuleId') {
                        return null;
                    }
                    if (!ts.isIdentifier(propAccess.expression) ||
                        propAccess.expression.escapedText !== 'goog') {
                        return null;
                    }
                    // Verify the call takes a single string argument and grab it.
                    if (call.arguments.length !== 1) {
                        return null;
                    }
                    const arg = call.arguments[0];
                    if (!ts.isStringLiteral(arg)) {
                        return null;
                    }
                    const moduleId = arg.text;
                    // replace goog.declareModuleId['foo.bar'] with:
                    // goog.loadedModules_['foo.bar'] = {
                    //   exports: exports,
                    //   type: goog.ModuleType.GOOG,
                    //   moduleId: 'foo.bar'
                    // };
                    //
                    // For more info, see `goog.loadModule` in
                    // https://github.com/google/closure-library/blob/master/closure/goog/base.js
                    const newStmt = ts.createStatement(ts.createAssignment(ts.createElementAccess(ts.createPropertyAccess(ts.createIdentifier('goog'), ts.createIdentifier('loadedModules_')), transformer_util_1.createSingleQuoteStringLiteral(moduleId)), ts.createObjectLiteral([
                        ts.createPropertyAssignment('exports', ts.createIdentifier('exports')),
                        ts.createPropertyAssignment('type', ts.createPropertyAccess(ts.createPropertyAccess(ts.createIdentifier('goog'), ts.createIdentifier('ModuleType')), ts.createIdentifier('GOOG'))),
                        ts.createPropertyAssignment('moduleId', transformer_util_1.createSingleQuoteStringLiteral(moduleId)),
                    ])));
                    return ts.setOriginalNode(ts.setTextRange(newStmt, original), original);
                }
                /**
                 * maybeRewriteRequireTslib rewrites a require('tslib') calls to goog.require('tslib'). It
                 * returns the input statement untouched if it does not match.
                 */
                function maybeRewriteRequireTslib(stmt) {
                    if (!ts.isExpressionStatement(stmt))
                        return null;
                    if (!ts.isCallExpression(stmt.expression))
                        return null;
                    const callExpr = stmt.expression;
                    if (!ts.isIdentifier(callExpr.expression) || callExpr.expression.text !== 'require') {
                        return null;
                    }
                    if (callExpr.arguments.length !== 1)
                        return stmt;
                    const arg = callExpr.arguments[0];
                    if (!ts.isStringLiteral(arg) || arg.text !== 'tslib')
                        return null;
                    return ts.setOriginalNode(ts.setTextRange(ts.createStatement(createGoogCall('require', arg)), stmt), stmt);
                }
                /**
                 * visitTopLevelStatement implements the main CommonJS to goog.module conversion. It visits a
                 * SourceFile level statement and adds a (possibly) transformed representation of it into
                 * statements. It adds at least one node per statement to statements.
                 *
                 * visitTopLevelStatement:
                 * - converts require() calls to goog.require() calls, with or w/o var assignment
                 * - removes "use strict"; and "Object.defineProperty(__esModule)" statements
                 * - converts module.exports assignments to just exports assignments
                 * - splits __exportStar() calls into require and export (this needs two statements)
                 * - makes sure to only import each namespace exactly once, and use variables later on
                 */
                function visitTopLevelStatement(statements, sf, node) {
                    // Handle each particular case by adding node to statements, then return.
                    // For unhandled cases, break to jump to the default handling below.
                    // In JS transpilation mode, always rewrite `require('tslib')` to
                    // goog.require('tslib'), ignoring normal module resolution.
                    if (host.isJsTranspilation) {
                        const rewrittenTsLib = maybeRewriteRequireTslib(node);
                        if (rewrittenTsLib) {
                            statements.push(rewrittenTsLib);
                            return;
                        }
                    }
                    switch (node.kind) {
                        case ts.SyntaxKind.ExpressionStatement: {
                            const exprStmt = node;
                            // Check for "use strict" and certain Object.defineProperty and skip it if necessary.
                            if (isUseStrict(exprStmt) || isEsModuleProperty(exprStmt)) {
                                stmts.push(transformer_util_1.createNotEmittedStatementWithComments(sf, exprStmt));
                                return;
                            }
                            // Check for:
                            //   module.exports = ...;
                            const modExports = rewriteModuleExportsAssignment(exprStmt);
                            if (modExports) {
                                stmts.push(modExports);
                                return;
                            }
                            // Check for use of the comma operator.
                            // This occurs in code like
                            //   exports.a = ..., exports.b = ...;
                            // which we want to change into multiple statements.
                            const commaExpanded = rewriteCommaExpressions(exprStmt);
                            if (commaExpanded) {
                                stmts.push(...commaExpanded);
                                return;
                            }
                            // Check for:
                            //   "require('foo');" (a require for its side effects)
                            const expr = exprStmt.expression;
                            if (!ts.isCallExpression(expr))
                                break;
                            let callExpr = expr;
                            const declaredModuleId = maybeRewriteDeclareModuleId(exprStmt, callExpr);
                            if (declaredModuleId) {
                                statements.push(declaredModuleId);
                                return;
                            }
                            // Handle export * in ES5 mode (in ES6 mode, export * is dereferenced already).
                            // export * creates either a pure top-level '__export(require(...))' or the imported
                            // version, 'tslib.__exportStar(require(...))'. The imported version is only substituted
                            // later on though, so appears as a plain "__exportStar" on the top level here.
                            const isExportStar = (ts.isIdentifier(expr.expression) && expr.expression.text === '__exportStar') ||
                                (ts.isIdentifier(expr.expression) && expr.expression.text === '__export');
                            if (isExportStar)
                                callExpr = expr.arguments[0];
                            const ident = ts.createIdentifier(nextModuleVar());
                            const require = maybeCreateGoogRequire(exprStmt, callExpr, ident);
                            if (!require)
                                break;
                            statements.push(require);
                            // If this is an export star, split it up into the import (created by the maybe call
                            // above), and the export operation. This avoids a Closure complaint about non-top-level
                            // requires.
                            if (isExportStar) {
                                const args = [ident];
                                if (expr.arguments.length > 1)
                                    args.push(expr.arguments[1]);
                                statements.push(ts.createStatement(ts.createCall(expr.expression, undefined, args)));
                            }
                            return;
                        }
                        case ts.SyntaxKind.VariableStatement: {
                            // It's possibly of the form "var x = require(...);".
                            const varStmt = node;
                            // Verify it's a single decl (and not "var x = ..., y = ...;").
                            if (varStmt.declarationList.declarations.length !== 1)
                                break;
                            const decl = varStmt.declarationList.declarations[0];
                            // Grab the variable name (avoiding things like destructuring binds).
                            if (decl.name.kind !== ts.SyntaxKind.Identifier)
                                break;
                            if (!decl.initializer || !ts.isCallExpression(decl.initializer)) {
                                break;
                            }
                            const require = maybeCreateGoogRequire(varStmt, decl.initializer, decl.name);
                            if (!require)
                                break;
                            statements.push(require);
                            return;
                        }
                        default:
                            break;
                    }
                    statements.push(node);
                }
                const moduleName = host.pathToModuleName('', sf.fileName);
                // Register the namespace this file provides.
                modulesManifest.addModule(sf.fileName, moduleName);
                // Convert each top level statement to goog.module.
                const stmts = [];
                for (const stmt of sf.statements) {
                    visitTopLevelStatement(stmts, sf, stmt);
                }
                // Additional statements that will be prepended (goog.module call etc).
                const headerStmts = [];
                // Emit: goog.module('moduleName');
                const googModule = ts.createStatement(createGoogCall('module', transformer_util_1.createSingleQuoteStringLiteral(moduleName)));
                headerStmts.push(googModule);
                // Allow code to use `module.id` to discover its module URL, e.g. to resolve a template URL
                // against. Uses 'var', as this code is inserted in ES6 and ES5 modes. The following pattern
                // ensures closure doesn't throw an error in advanced optimizations mode.
                // var module = module || {id: 'path/to/module.ts'};
                const moduleId = host.fileNameToModuleId(sf.fileName);
                const moduleVarInitializer = ts.createBinary(ts.createIdentifier('module'), ts.SyntaxKind.BarBarToken, ts.createObjectLiteral([ts.createPropertyAssignment('id', transformer_util_1.createSingleQuoteStringLiteral(moduleId))]));
                const modAssign = ts.createVariableStatement(
                /* modifiers */ undefined, ts.createVariableDeclarationList([ts.createVariableDeclaration('module', /* type */ undefined, moduleVarInitializer)]));
                headerStmts.push(modAssign);
                if (!host.es5Mode) {
                    // The module=module assignment suppresses an unused variable warning which may trigger
                    // depending on the project's compilation flags.
                    headerStmts.push(ts.createStatement(ts.createAssignment(ts.createIdentifier('module'), ts.createIdentifier('module'))));
                    // The `exports = {}` serves as a default export to disable Closure Compiler's error
                    // checking
                    // for mutable exports. That's OK because TS compiler makes sure that consuming code always
                    // accesses exports through the module object, so mutable exports work.
                    // It is only inserted in ES6 because we strip `.default` accesses in ES5 mode, which breaks
                    // when assigning an `exports = {}` object and then later accessing it.
                    // However Closure bails if code later on assigns into exports directly, as we do if we have
                    // an "exports = " block, so skip emit if that's the case.
                    if (!sf.statements.find(s => ts.isExpressionStatement(s) &&
                        (isModuleExportsAssignment(s) || isExportsAssignment(s)))) {
                        headerStmts.push(ts.createStatement(ts.createAssignment(ts.createIdentifier('exports'), ts.createObjectLiteral())));
                    }
                }
                // Insert goog.module() etc after any leading comments in the source file. The comments have
                // been converted to NotEmittedStatements by transformer_util, which this depends on.
                const insertionIdx = stmts.findIndex(s => s.kind !== ts.SyntaxKind.NotEmittedStatement);
                if (insertionIdx === -1) {
                    stmts.push(...headerStmts);
                }
                else {
                    stmts.splice(insertionIdx, 0, ...headerStmts);
                }
                return ts.updateSourceFileNode(sf, ts.setTextRange(ts.createNodeArray(stmts), sf.statements));
            };
        };
    }
    exports.commonJsToGoogmoduleTransformer = commonJsToGoogmoduleTransformer;
    function isModule(sourceFile) {
        return Boolean(sourceFile.externalModuleIndicator);
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ29vZ21vZHVsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9nb29nbW9kdWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRzs7Ozs7Ozs7Ozs7O0lBRUgsaUNBQWlDO0lBR2pDLHlDQUErQjtJQUMvQixtRUFBMEc7SUF5QjFHOztPQUVHO0lBQ0gsU0FBUyxnQkFBZ0IsQ0FBQyxJQUFhLEVBQUUsTUFBYyxFQUFFLEtBQWE7UUFDcEUsSUFBSSxDQUFDLEVBQUUsQ0FBQywwQkFBMEIsQ0FBQyxJQUFJLENBQUM7WUFBRSxPQUFPLEtBQUssQ0FBQztRQUN2RCxPQUFPLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxLQUFLLE1BQU07WUFDN0UsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEtBQUssS0FBSyxDQUFDO0lBQ3RDLENBQUM7SUFFRCx1REFBdUQ7SUFDdkQsU0FBUyx5QkFBeUIsQ0FBQyxJQUE0QjtRQUM3RCxJQUFJLENBQUMsRUFBRSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7WUFBRSxPQUFPLEtBQUssQ0FBQztRQUMxRCxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLElBQUksS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVc7WUFBRSxPQUFPLEtBQUssQ0FBQztRQUNuRixPQUFPLGdCQUFnQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNyRSxDQUFDO0lBRUQsZ0RBQWdEO0lBQ2hELFNBQVMsbUJBQW1CLENBQUMsSUFBNEI7UUFDdkQsSUFBSSxDQUFDLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO1lBQUUsT0FBTyxLQUFLLENBQUM7UUFDMUQsSUFBSSxJQUFJLENB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QyxvQkFBb0IsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ2hHLENBQUMsQ0FBQztRQUNKLENBQUMsQ0FBQztJQUNKLENBQUM7SUFwWEQsMEVBb1hDO0lBRUQsU0FBUyxRQUFRLENBQUMsVUFBeUI7UUFNekMsT0FBTyxPQUFPLENBQUUsVUFBaUMsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0lBQzdFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCAqIGFzIHRzIGZyb20gJ3R5cGVzY3JpcHQnO1xuXG5pbXBvcnQge01vZHVsZXNNYW5pZmVzdH0gZnJvbSAnLi9tb2R1bGVzX21hbmlmZXN0JztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAnLi9wYXRoJztcbmltcG9ydCB7Y3JlYXRlTm90RW1pdHRlZFN0YXRlbWVudFdpdGhDb21tZW50cywgY3JlYXRlU2luZ2xlUXVvdGVTdHJpbmdMaXRlcmFsLH0gZnJvbSAnLi90cmFuc2Zvcm1lcl91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBHb29nTW9kdWxlUHJvY2Vzc29ySG9zdCB7XG4gIC8qKlxuICAgKiBUYWtlcyBhIGNvbnRleHQgKHRzLlNvdXJjZUZpbGUuZmlsZU5hbWUgb2YgdGhlIGN1cnJlbnQgZmlsZSkgYW5kIHRoZSBpbXBvcnQgVVJMIG9mIGFuIEVTNlxuICAgKiBpbXBvcnQgYW5kIGdlbmVyYXRlcyBhIGdvb2dtb2R1bGUgbW9kdWxlIG5hbWUgZm9yIHRoZSBpbXBvcnRlZCBtb2R1bGUuXG4gICAqL1xuICBwYXRoVG9Nb2R1bGVOYW1lKGNvbnRleHQ6IHN0cmluZywgaW1wb3J0UGF0aDogc3RyaW5nKTogc3RyaW5nO1xuICAvKipcbiAgICogSWYgd2UgZG8gZ29vZ21vZHVsZSBwcm9jZXNzaW5nLCB3ZSBwb2x5ZmlsbCBtb2R1bGUuaWQsIHNpbmNlIHRoYXQnc1xuICAgKiBwYXJ0IG9mIEVTNiBtb2R1bGVzLiAgVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIHdoYXQgdGhlIG1vZHVsZS5pZCB3aWxsIGJlXG4gICAqIGZvciBlYWNoIGZpbGUuXG4gICAqL1xuICBmaWxlTmFtZVRvTW9kdWxlSWQoZmlsZU5hbWU6IHN0cmluZyk6IHN0cmluZztcbiAgLyoqIElkZW50aWZpZXMgd2hldGhlciB0aGlzIGZpbGUgaXMgdGhlIHJlc3VsdCBvZiBhIEpTIHRyYW5zcGlsYXRpb24uICovXG4gIGlzSnNUcmFuc3BpbGF0aW9uPzogYm9vbGVhbjtcbiAgLyoqIFdoZXRoZXIgdGhlIGVtaXQgdGFyZ2V0cyBFUzUgb3IgRVM2Ky4gKi9cbiAgZXM1TW9kZT86IGJvb2xlYW47XG4gIC8qKiBleHBhbmQgXCJpbXBvcnQgJ2Zvbyc7XCIgdG8gXCJpbXBvcnQgJ2Zvby9pbmRleCc7XCIgaWYgaXQgcG9pbnRzIHRvIGFuIGluZGV4IGZpbGUuICovXG4gIGNvbnZlcnRJbmRleEltcG9ydFNob3J0aGFuZD86IGJvb2xlYW47XG5cbiAgb3B0aW9uczogdHMuQ29tcGlsZXJPcHRpb25zO1xuICBtb2R1bGVSZXNvbHV0aW9uSG9zdDogdHMuTW9kdWxlUmVzb2x1dGlvbkhvc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG5vZGUgaXMgYSBwcm9wZXJ0eSBhY2Nlc3Mgb2YgYGNoaWxkYCBvbiB0aGUgaWRlbnRpZmllciBgcGFyZW50YC5cbiAqL1xuZnVuY3Rpb24gaXNQcm9wZXJ0eUFjY2Vzcyhub2RlOiB0cy5Ob2RlLCBwYXJlbnQ6IHN0cmluZywgY2hpbGQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAoIXRzLmlzUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uKG5vZGUpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cy5pc0lkZW50aWZpZXIobm9kZS5leHByZXNzaW9uKSAmJiBub2RlLmV4cHJlc3Npb24uZXNjYXBlZFRleHQgPT09IHBhcmVudCAmJlxuICAgICAgbm9kZS5uYW1lLmVzY2FwZWRUZXh0ID09PSBjaGlsZDtcbn1cblxuLyoqIFJldHVybnMgdHJ1ZSBpZiBleHByIGlzIFwibW9kdWxlLmV4cG9ydHMgPSAuLi47XCIuICovXG5mdW5jdGlvbiBpc01vZHVsZUV4cG9ydHNBc3NpZ25tZW50KGV4cHI6IHRzLkV4cHJlc3Npb25TdGF0ZW1lbnQpOiBib29sZWFuIHtcbiAgaWYgKCF0cy5pc0JpbmFyeUV4cHJlc3Npb24oZXhwci5leHByZXNzaW9uKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZXhwci5leHByZXNzaW9uLm9wZXJhdG9yVG9rZW4ua2luZCAhPT0gdHMuU3ludGF4S2luZC5FcXVhbHNUb2tlbikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gaXNQcm9wZXJ0eUFjY2VzcyhleHByLmV4cHJlc3Npb24ubGVmdCwgJ21vZHVsZScsICdleHBvcnRzJyk7XG59XG5cbi8qKiBSZXR1cm5zIHRydWUgaWYgZXhwciBpcyBcImV4cG9ydHMgPSAuLi47XCIuICovXG5mdW5jdGlvbiBpc0V4cG9ydHNBc3NpZ25tZW50KGV4cHI6IHRzLkV4cHJlc3Npb25TdGF0ZW1lbnQpOiBib29sZWFuIHtcbiAgaWYgKCF0cy5pc0JpbmFyeUV4cHJlc3Npb24oZXhwci5leHByZXNzaW9uKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZXhwci5leHByZXNzaW9uLm9wZXJhdG9yVG9rZW4ua2luZCAhPT0gdHMuU3ludGF4S2luZC5FcXVhbHNUb2tlbikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHMuaXNJZGVudGlmaWVyKGV4cHIuZXhwcmVzc2lvbi5sZWZ0KSAmJiBleHByLmV4cHJlc3Npb24ubGVmdC50ZXh0ID09PSAnZXhwb3J0cyc7XG59XG5cbi8qKiBpc1VzZVN0cmljdCByZXR1cm5zIHRydWUgaWYgbm9kZSBpcyBhIFwidXNlIHN0cmljdFwiOyBzdGF0ZW1lbnQuICovXG5mdW5jdGlvbiBpc1VzZVN0cmljdChub2RlOiB0cy5Ob2RlKTogYm9vbGVhbiB7XG4gIGlmIChub2RlLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuRXhwcmVzc2lvblN0YXRlbWVudCkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBleHByU3RtdCA9IG5vZGUgYXMgdHMuRXhwcmVzc2lvblN0YXRlbWVudDtcbiAgY29uc3QgZXhwciA9IGV4cHJTdG10LmV4cHJlc3Npb247XG4gIGlmIChleHByLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuU3RyaW5nTGl0ZXJhbCkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBsaXRlcmFsID0gZXhwciBhcyB0cy5TdHJpbmdMaXRlcmFsO1xuICByZXR1cm4gbGl0ZXJhbC50ZXh0ID09PSAndXNlIHN0cmljdCc7XG59XG5cbi8qKlxuICogVHlwZVNjcmlwdCBpbnNlcnRzIHRoZSBmb2xsb3dpbmcgY29kZSB0byBtYXJrIEVTIG1vZHVlbHMgaW4gQ29tbW9uSlM6XG4gKiAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAqIFRoaXMgbWF0Y2hlcyB0aGF0IGNvZGUgc25pcHBldC5cbiAqL1xuZnVuY3Rpb24gaXNFc01vZHVsZVByb3BlcnR5KHN0bXQ6IHRzLkV4cHJlc3Npb25TdGF0ZW1lbnQpOiBib29sZWFuIHtcbiAgLy8gV2UncmUgbWF0Y2hpbmcgdGhlIGV4cGxpY2l0IHNvdXJjZSB0ZXh0IGdlbmVyYXRlZCBieSB0aGUgVFMgY29tcGlsZXIuXG4gIC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgY29uc3QgZXhwciA9IHN0bXQuZXhwcmVzc2lvbjtcbiAgaWYgKCF0cy5pc0NhbGxFeHByZXNzaW9uKGV4cHIpKSByZXR1cm4gZmFsc2U7XG4gIGlmICghaXNQcm9wZXJ0eUFjY2VzcyhleHByLmV4cHJlc3Npb24sICdPYmplY3QnLCAnZGVmaW5lUHJvcGVydHknKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZXhwci5hcmd1bWVudHMubGVuZ3RoICE9PSAzKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IFtleHAsIGVzTSwgdmFsXSA9IGV4cHIuYXJndW1lbnRzO1xuICBpZiAoIXRzLmlzSWRlbnRpZmllcihleHApIHx8IGV4cC5lc2NhcGVkVGV4dCAhPT0gJ2V4cG9ydHMnKSByZXR1cm4gZmFsc2U7XG4gIGlmICghdHMuaXNTdHJpbmdMaXRlcmFsKGVzTSkgfHwgZXNNLnRleHQgIT09ICdfX2VzTW9kdWxlJykgcmV0dXJuIGZhbHNlO1xuICBpZiAoIXRzLmlzT2JqZWN0TGl0ZXJhbEV4cHJlc3Npb24odmFsKSB8fCB2YWwucHJvcGVydGllcy5sZW5ndGggIT09IDEpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcHJvcCA9IHZhbC5wcm9wZXJ0aWVzWzBdO1xuICBpZiAoIXRzLmlzUHJvcGVydHlBc3NpZ25tZW50KHByb3ApKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGlkZW50ID0gcHJvcC5uYW1lO1xuICBpZiAoIWlkZW50IHx8ICF0cy5pc0lkZW50aWZpZXIoaWRlbnQpIHx8IGlkZW50LnRleHQgIT09ICd2YWx1ZScpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHByb3AuaW5pdGlhbGl6ZXIua2luZCA9PT0gdHMuU3ludGF4S2luZC5UcnVlS2V5d29yZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdHJpbmcgYXJndW1lbnQgaWYgY2FsbCBpcyBvZiB0aGUgZm9ybVxuICogICByZXF1aXJlKCdmb28nKVxuICovXG5mdW5jdGlvbiBleHRyYWN0UmVxdWlyZShjYWxsOiB0cy5DYWxsRXhwcmVzc2lvbik6IHN0cmluZ3xudWxsIHtcbiAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNhbGwgaXMgYSBjYWxsIHRvIHJlcXVpcmUoLi4uKS5cbiAgaWYgKGNhbGwuZXhwcmVzc2lvbi5raW5kICE9PSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXIpIHJldHVybiBudWxsO1xuICBjb25zdCBpZGVudCA9IGNhbGwuZXhwcmVzc2lvbiBhcyB0cy5JZGVudGlmaWVyO1xuICBpZiAoaWRlbnQuZXNjYXBlZFRleHQgIT09ICdyZXF1aXJlJykgcmV0dXJuIG51bGw7XG5cbiAgLy8gVmVyaWZ5IHRoZSBjYWxsIHRha2VzIGEgc2luZ2xlIHN0cmluZyBhcmd1bWVudCBhbmQgZ3JhYiBpdC5cbiAgaWYgKGNhbGwuYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGFyZyA9IGNhbGwuYXJndW1lbnRzWzBdO1xuICBpZiAoYXJnLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuU3RyaW5nTGl0ZXJhbCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiAoYXJnIGFzIHRzLlN0cmluZ0xpdGVyYWwpLnRleHQ7XG59XG5cbi8qKiBDcmVhdGVzIGEgY2FsbCBleHByZXNzaW9uIGNvcnJlc3BvbmRpbmcgdG8gYGdvb2cuJHttZXRob2ROYW1lfSgke2xpdGVyYWx9KWAuICovXG5mdW5jdGlvbiBjcmVhdGVHb29nQ2FsbChtZXRob2ROYW1lOiBzdHJpbmcsIGxpdGVyYWw6IHRzLlN0cmluZ0xpdGVyYWwpOiB0cy5DYWxsRXhwcmVzc2lvbiB7XG4gIHJldHVybiB0cy5jcmVhdGVDYWxsKFxuICAgICAgdHMuY3JlYXRlUHJvcGVydHlBY2Nlc3ModHMuY3JlYXRlSWRlbnRpZmllcignZ29vZycpLCBtZXRob2ROYW1lKSwgdW5kZWZpbmVkLCBbbGl0ZXJhbF0pO1xufVxuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBuYW1lc3BhY2UgcGFydCBvZiBhIGdvb2c6IGltcG9ydCBVUkwsIG9yIHJldHVybnMgbnVsbCBpZiB0aGUgZ2l2ZW4gaW1wb3J0IFVSTCBpcyBub3RcbiAqIGEgZ29vZzogaW1wb3J0LlxuICpcbiAqIEZvciBleGFtcGxlLCBmb3IgYGltcG9ydCAnZ29vZzpmb28uQmFyJztgLCByZXR1cm5zIGBmb28uQmFyYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RHb29nTmFtZXNwYWNlSW1wb3J0KHRzSW1wb3J0OiBzdHJpbmcpOiBzdHJpbmd8bnVsbCB7XG4gIGlmICh0c0ltcG9ydC5tYXRjaCgvXmdvb2c6LykpIHJldHVybiB0c0ltcG9ydC5zdWJzdHJpbmcoJ2dvb2c6Jy5sZW5ndGgpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGZyb20gaW1wbGljaXQgYGltcG9ydCB7fSBmcm9tICdwa2cnYCB0byBhIGZ1bGwgcmVzb2x2ZWQgZmlsZSBuYW1lLCBpbmNsdWRpbmcgYW55IGAvaW5kZXhgXG4gKiBzdWZmaXggYW5kIGFsc28gcmVzb2x2aW5nIHBhdGggbWFwcGluZ3MuIFR5cGVTY3JpcHQgYW5kIG1hbnkgbW9kdWxlIGxvYWRlcnMgc3VwcG9ydCB0aGVcbiAqIHNob3J0aGFuZCwgYnV0IGBnb29nLm1vZHVsZWAgZG9lcyBub3QsIHNvIHRzaWNrbGUgbmVlZHMgdG8gcmVzb2x2ZSB0aGUgbW9kdWxlIG5hbWUgc2hvcnRoYW5kXG4gKiBiZWZvcmUgZ2VuZXJhdGluZyBgZ29vZy5tb2R1bGVgIG5hbWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZU1vZHVsZU5hbWUoXG4gICAge29wdGlvbnMsIG1vZHVsZVJlc29sdXRpb25Ib3N0fTpcbiAgICAgICAge29wdGlvbnM6IHRzLkNvbXBpbGVyT3B0aW9ucywgbW9kdWxlUmVzb2x1dGlvbkhvc3Q6IHRzLk1vZHVsZVJlc29sdXRpb25Ib3N0fSxcbiAgICBwYXRoT2ZJbXBvcnRpbmdGaWxlOiBzdHJpbmcsIGltcG9ydGVkOiBzdHJpbmcpOiBzdHJpbmcge1xuICAvLyBUaGUgc3RyYXRlZ3kgdGFrZW4gaGVyZSBpcyB0byB1c2UgdHMucmVzb2x2ZU1vZHVsZU5hbWUoKSB0byByZXNvbHZlIHRoZSBpbXBvcnQgdG9cbiAgLy8gYSBzcGVjaWZpYyBwYXRoLCB3aGljaCByZXNvbHZlcyBhbnkgL2luZGV4IGFuZCBwYXRoIG1hcHBpbmdzLlxuICBjb25zdCByZXNvbHZlZCA9XG4gICAgICB0cy5yZXNvbHZlTW9kdWxlTmFtZShpbXBvcnRlZCwgcGF0aE9mSW1wb3J0aW5nRmlsZSwgb3B0aW9ucywgbW9kdWxlUmVzb2x1dGlvbkhvc3QpO1xuICBpZiAoIXJlc29sdmVkIHx8ICFyZXNvbHZlZC5yZXNvbHZlZE1vZHVsZSkgcmV0dXJuIGltcG9ydGVkO1xuICBjb25zdCByZXNvbHZlZE1vZHVsZSA9IHJlc29sdmVkLnJlc29sdmVkTW9kdWxlLnJlc29sdmVkRmlsZU5hbWU7XG5cbiAgLy8gQ2hlY2sgaWYgdGhlIHJlc29sdXRpb24gd2VudCBpbnRvIG5vZGVfbW9kdWxlcy5cbiAgLy8gTm90ZSB0aGF0IHRoZSBSZXNvbHZlZE1vZHVsZSByZXR1cm5lZCBieSByZXNvbHZlTW9kdWxlTmFtZSgpIGhhcyBhblxuICAvLyBhdHRyaWJ1dGUgaXNFeHRlcm5hbExpYnJhcnlJbXBvcnQgdGhhdCBpcyBkb2N1bWVudGVkIHdpdGhcbiAgLy8gXCJUcnVlIGlmIHJlc29sdmVkRmlsZU5hbWUgY29tZXMgZnJvbSBub2RlX21vZHVsZXNcIiwgYnV0IGFjdHVhbGx5IGl0IGlzIGp1c3RcbiAgLy8gdHJ1ZSBpZiB0aGUgYWJzb2x1dGUgcGF0aCBpbmNsdWRlcyBub2RlX21vZHVsZXMsIGFuZCBpcyBhbHdheXMgdHJ1ZSB3aGVuXG4gIC8vIHRzaWNrbGUgaXRzZWxmIGlzIHVuZGVyIGEgZGlyZWN0b3J5IG5hbWVkIG5vZGVfbW9kdWxlcy5cbiAgY29uc3QgcmVsYXRpdmVSZXNvbHZlZCA9IHBhdGgucmVsYXRpdmUob3B0aW9ucy5yb290RGlyIHx8ICcnLCByZXNvbHZlZE1vZHVsZSk7XG4gIGlmIChyZWxhdGl2ZVJlc29sdmVkLmluZGV4T2YoJ25vZGVfbW9kdWxlcycpICE9PSAtMSkge1xuICAgIC8vIEltcG9ydHMgaW50byBub2RlX21vZHVsZXMgcmVzb2x2ZSB0aHJvdWdoIHBhY2thZ2UuanNvbiBhbmQgbXVzdCBiZVxuICAgIC8vIHNwZWNpYWxseSBoYW5kbGVkIGJ5IHRoZSBsb2FkZXIgYW55d2F5LiAgUmV0dXJuIHRoZSBpbnB1dC5cbiAgICByZXR1cm4gaW1wb3J0ZWQ7XG4gIH1cblxuICAvLyBPdGhlcndpc2UgcmV0dXJuIHRoZSBmdWxsIHJlc29sdmVkIGZpbGUgbmFtZS4gVGhpcyBwYXRoIHdpbGwgYmUgdHVybmVkIGludG8gYSBtb2R1bGUgbmFtZSB1c2luZ1xuICAvLyBBbm5vdGF0b3JIb3N0I3BhdGhUb01vZHVsZU5hbWUsIHdoaWNoIGFsc28gdGFrZXMgY2FyZSBvZiBiYXNlVXJsIGFuZCByb290RGlycy5cbiAgcmV0dXJuIHJlc29sdmVkLnJlc29sdmVkTW9kdWxlLnJlc29sdmVkRmlsZU5hbWU7XG59XG5cbi8qKlxuICogaW1wb3J0UGF0aFRvR29vZ05hbWVzcGFjZSBjb252ZXJ0cyBhIFRTL0VTIG1vZHVsZSAnLi9pbXBvcnQvcGF0aCcgaW50byBhIGdvb2cubW9kdWxlIGNvbXBhdGlibGVcbiAqIG5hbWVzcGFjZSwgaGFuZGxpbmcgcmVndWxhciBpbXBvcnRzIGFuZCBgZ29vZzpgIG5hbWVzcGFjZSBpbXBvcnRzLlxuICovXG5mdW5jdGlvbiBpbXBvcnRQYXRoVG9Hb29nTmFtZXNwYWNlKFxuICAgIGhvc3Q6IEdvb2dNb2R1bGVQcm9jZXNzb3JIb3N0LCBmaWxlOiB0cy5Tb3VyY2VGaWxlLCB0c0ltcG9ydDogc3RyaW5nKTogdHMuU3RyaW5nTGl0ZXJhbCB7XG4gIGxldCBtb2ROYW1lOiBzdHJpbmc7XG4gIGNvbnN0IG5zSW1wb3J0ID0gZXh0cmFjdEdvb2dOYW1lc3BhY2VJbXBvcnQodHNJbXBvcnQpO1xuICBpZiAobnNJbXBvcnQgIT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIGEgbmFtZXNwYWNlIGltcG9ydCwgb2YgdGhlIGZvcm0gXCJnb29nOmZvby5iYXJcIi5cbiAgICAvLyBGaXggaXQgdG8ganVzdCBcImZvby5iYXJcIi5cbiAgICBtb2ROYW1lID0gbnNJbXBvcnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGhvc3QuY29udmVydEluZGV4SW1wb3J0U2hvcnRoYW5kKSB7XG4gICAgICB0c0ltcG9ydCA9IHJlc29sdmVNb2R1bGVOYW1lKGhvc3QsIGZpbGUuZmlsZU5hbWUsIHRzSW1wb3J0KTtcbiAgICB9XG4gICAgbW9kTmFtZSA9IGhvc3QucGF0aFRvTW9kdWxlTmFtZShmaWxlLmZpbGVOYW1lLCB0c0ltcG9ydCk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVNpbmdsZVF1b3RlU3RyaW5nTGl0ZXJhbChtb2ROYW1lKTtcbn1cblxuLyoqXG4gKiBSZXBsYWNlIFwibW9kdWxlLmV4cG9ydHMgPSAuLi5cIiB3aXRoIGp1c3QgXCJleHBvcnRzID0gLi4uXCIuIFJldHVybnMgbnVsbCBpZiBgZXhwcmAgaXMgbm90IGFuXG4gKiBleHBvcnRzIGFzc2lnbm1lbnQuXG4gKi9cbmZ1bmN0aW9uIHJld3JpdGVNb2R1bGVFeHBvcnRzQXNzaWdubWVudChleHByOiB0cy5FeHByZXNzaW9uU3RhdGVtZW50KSB7XG4gIGlmICghdHMuaXNCaW5hcnlFeHByZXNzaW9uKGV4cHIuZXhwcmVzc2lvbikpIHJldHVybiBudWxsO1xuICBpZiAoZXhwci5leHByZXNzaW9uLm9wZXJhdG9yVG9rZW4ua2luZCAhPT0gdHMuU3ludGF4S2luZC5FcXVhbHNUb2tlbikgcmV0dXJuIG51bGw7XG4gIGlmICghaXNQcm9wZXJ0eUFjY2VzcyhleHByLmV4cHJlc3Npb24ubGVmdCwgJ21vZHVsZScsICdleHBvcnRzJykpIHJldHVybiBudWxsO1xuICByZXR1cm4gdHMuc2V0T3JpZ2luYWxOb2RlKFxuICAgICAgdHMuc2V0VGV4dFJhbmdlKFxuICAgICAgICAgIHRzLmNyZWF0ZVN0YXRlbWVudChcbiAgICAgICAgICAgICAgdHMuY3JlYXRlQXNzaWdubWVudCh0cy5jcmVhdGVJZGVudGlmaWVyKCdleHBvcnRzJyksIGV4cHIuZXhwcmVzc2lvbi5yaWdodCkpLFxuICAgICAgICAgIGV4cHIpLFxuICAgICAgZXhwcik7XG59XG5cbi8qKlxuICogQ29udmVydCBhIHNlcmllcyBvZiBjb21tYS1zZXBhcmF0ZWQgZXhwcmVzc2lvbnNcbiAqICAgeCA9IGZvbywgeSgpLCB6LmJhcigpO1xuICogd2l0aCBzdGF0ZW1lbnRzXG4gKiAgIHggPSBmb287IHkoKTsgei5iYXIoKTtcbiAqIFRoaXMgaXMgZm9yIGhhbmRsaW5nIGluIHBhcnRpY3VsYXIgdGhlIGNhc2Ugd2hlcmVcbiAqICAgZXhwb3J0cy54ID0gLi4uLCBleHBvcnRzLnkgPSAuLi47XG4gKiB3aGljaCBDbG9zdXJlIHJlamVjdHMuXG4gKlxuICogQHJldHVybiBBbiBhcnJheSBvZiBzdGF0ZW1lbnRzIGlmIGl0IGNvbnZlcnRlZCwgb3IgbnVsbCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIHJld3JpdGVDb21tYUV4cHJlc3Npb25zKGV4cHI6IHRzLkV4cHJlc3Npb25TdGF0ZW1lbnQpOiB0cy5TdGF0ZW1lbnRbXXxudWxsIHtcbiAgLy8gRWFybHkgZXhpdCBpZiB0aGUgb3V0ZXIgc3RhdGVtZW50IGlzbid0IGEgY29tbWEgc3RhdGVtZW50LlxuICBpZiAoIXRzLmlzQmluYXJ5RXhwcmVzc2lvbihleHByLmV4cHJlc3Npb24pKSByZXR1cm4gbnVsbDtcbiAgaWYgKGV4cHIuZXhwcmVzc2lvbi5vcGVyYXRvclRva2VuLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuQ29tbWFUb2tlbikgcmV0dXJuIG51bGw7XG5cbiAgLy8gUmVjdXJzaXZlbHkgdmlzaXQgY29tbWEtc2VwYXJhdGVkIHN1YmV4cHJlc3Npb25zLCBhbmQgY29sbGVjdCB0aGVtIGFsbCBhc1xuICAvLyBzZXBhcmF0ZSBleHByZXNzaW9uIHN0YXRlbWVudHMuXG4gIHJldHVybiB2aXNpdChleHByLmV4cHJlc3Npb24pO1xuICBmdW5jdGlvbiB2aXNpdChleHByOiB0cy5FeHByZXNzaW9uKTogdHMuU3RhdGVtZW50W10ge1xuICAgIGlmICh0cy5pc0JpbmFyeUV4cHJlc3Npb24oZXhwcikgJiYgZXhwci5vcGVyYXRvclRva2VuLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuQ29tbWFUb2tlbikge1xuICAgICAgcmV0dXJuIHZpc2l0KGV4cHIubGVmdCkuY29uY2F0KHZpc2l0KGV4cHIucmlnaHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIFt0cy5zZXRPcmlnaW5hbE5vZGUodHMuY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudChleHByKSwgZXhwcildO1xuICB9XG59XG5cbi8qKlxuICogY29tbW9uSnNUb0dvb2dtb2R1bGVUcmFuc2Zvcm1lciByZXR1cm5zIGEgdHJhbnNmb3JtZXIgZmFjdG9yeSB0aGF0IGNvbnZlcnRzIFR5cGVTY3JpcHQncyBDb21tb25KU1xuICogbW9kdWxlIGVtaXQgdG8gQ2xvc3VyZSBDb21waWxlciBjb21wYXRpYmxlIGdvb2cubW9kdWxlIGFuZCBnb29nLnJlcXVpcmUgc3RhdGVtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbW1vbkpzVG9Hb29nbW9kdWxlVHJhbnNmb3JtZXIoXG4gICAgaG9zdDogR29vZ01vZHVsZVByb2Nlc3Nvckhvc3QsIG1vZHVsZXNNYW5pZmVzdDogTW9kdWxlc01hbmlmZXN0LCB0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIsXG4gICAgZGlhZ25vc3RpY3M6IHRzLkRpYWdub3N0aWNbXSk6IChjb250ZXh0OiB0cy5UcmFuc2Zvcm1hdGlvbkNvbnRleHQpID0+XG4gICAgdHMuVHJhbnNmb3JtZXI8dHMuU291cmNlRmlsZT4ge1xuICByZXR1cm4gKGNvbnRleHQ6IHRzLlRyYW5zZm9ybWF0aW9uQ29udGV4dCk6IHRzLlRyYW5zZm9ybWVyPHRzLlNvdXJjZUZpbGU+ID0+IHtcbiAgICAvLyBUUycgQ29tbW9uSlMgcHJvY2Vzc2luZyB1c2VzIG9uU3Vic3RpdHV0ZU5vZGUgdG8sIGF0IHRoZSB2ZXJ5IGVuZCBvZiBwcm9jZXNzaW5nLCBzdWJzdGl0dXRlXG4gICAgLy8gXCJtb2R1bGVuYW1lLmRlZmF1bHRcIiBmb3IgZGVmYXVsdCBpbXBvcnRzLiBXZSBpbnRlcmNlcHQgdGhlIHN1YnN0aXR1dGlvbiBoZXJlLCBjaGVjayBpZiBpdCdzIGFcbiAgICAvLyAuZGVmYXVsdCBhY2Nlc3MsIHRoZW4gY2hlY2sgaWYgdGhlIG9yaWdpbmFsIG5vZGUgKGFuZCB0aHVzIG9yaWdpbmFsIGltcG9ydCkgd2FzIGZyb20gYSBnb29nOlxuICAgIC8vIG1vZHVsZSwgYW5kIGlmIHNvLCByZXBsYWNlIHdpdGgganVzdCB0aGUgbW9kdWxlIG5hbWUuXG4gICAgY29uc3QgcHJldmlvdXNPblN1YnN0aXR1dGVOb2RlID0gY29udGV4dC5vblN1YnN0aXR1dGVOb2RlO1xuICAgIGNvbnRleHQuZW5hYmxlU3Vic3RpdHV0aW9uKHRzLlN5bnRheEtpbmQuUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uKTtcbiAgICBjb250ZXh0Lm9uU3Vic3RpdHV0ZU5vZGUgPSAoaGludCwgbm9kZTogdHMuTm9kZSk6IHRzLk5vZGUgPT4ge1xuICAgICAgbm9kZSA9IHByZXZpb3VzT25TdWJzdGl0dXRlTm9kZShoaW50LCBub2RlKTtcbiAgICAgIGlmICghdHMuaXNQcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24obm9kZSkpIHJldHVybiBub2RlO1xuICAgICAgaWYgKG5vZGUubmFtZS50ZXh0ICE9PSAnZGVmYXVsdCcpIHJldHVybiBub2RlO1xuICAgICAgaWYgKCF0cy5pc0lkZW50aWZpZXIobm9kZS5leHByZXNzaW9uKSkgcmV0dXJuIG5vZGU7XG4gICAgICAvLyBGaW5kIHRoZSBpbXBvcnQgZGVjbGFyYXRpb24gdGhpcyBub2RlIGNvbWVzIGZyb20uXG4gICAgICAvLyBUaGlzIG1heSBiZSB0aGUgb3JpZ2luYWwgbm9kZSwgaWYgdGhlIGlkZW50aWZpZXIgd2FzIHRyYW5zZm9ybWVkIGZyb20gaXQuXG4gICAgICBjb25zdCBvcmlnID0gdHMuZ2V0T3JpZ2luYWxOb2RlKG5vZGUuZXhwcmVzc2lvbik7XG4gICAgICBsZXQgaW1wb3J0RXhwb3J0RGVjbDogdHMuSW1wb3J0RGVjbGFyYXRpb258dHMuRXhwb3J0RGVjbGFyYXRpb247XG4gICAgICBpZiAodHMuaXNJbXBvcnREZWNsYXJhdGlvbihvcmlnKSB8fCB0cy5pc0V4cG9ydERlY2xhcmF0aW9uKG9yaWcpKSB7XG4gICAgICAgIGltcG9ydEV4cG9ydERlY2wgPSBvcmlnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWx0ZXJuYXRpdmVseSwgd2UgY2FuIHRyeSB0byBmaW5kIHRoZSBkZWNsYXJhdGlvbiBvZiB0aGUgc3ltYm9sLiBUaGlzIG9ubHkgd29ya3MgZm9yXG4gICAgICAgIC8vIHVzZXItd3JpdHRlbiAuZGVmYXVsdCBhY2Nlc3NlcywgdGhlIGdlbmVyYXRlZCBvbmVzIGRvIG5vdCBoYXZlIGEgc3ltYm9sIGFzc29jaWF0ZWQgYXNcbiAgICAgICAgLy8gdGhleSBhcmUgb25seSBwcm9kdWNlZCBpbiB0aGUgQ29tbW9uSlMgdHJhbnNmb3JtYXRpb24sIGFmdGVyIHR5cGUgY2hlY2tpbmcuXG4gICAgICAgIGNvbnN0IHN5bSA9IHR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24obm9kZS5leHByZXNzaW9uKTtcbiAgICAgICAgaWYgKCFzeW0pIHJldHVybiBub2RlO1xuICAgICAgICBjb25zdCBkZWNscyA9IHN5bS5nZXREZWNsYXJhdGlvbnMoKTtcbiAgICAgICAgaWYgKCFkZWNscyB8fCAhZGVjbHMubGVuZ3RoKSByZXR1cm4gbm9kZTtcbiAgICAgICAgY29uc3QgZGVjbCA9IGRlY2xzWzBdO1xuICAgICAgICBpZiAoZGVjbC5wYXJlbnQgJiYgZGVjbC5wYXJlbnQucGFyZW50ICYmIHRzLmlzSW1wb3J0RGVjbGFyYXRpb24oZGVjbC5wYXJlbnQucGFyZW50KSkge1xuICAgICAgICAgIGltcG9ydEV4cG9ydERlY2wgPSBkZWNsLnBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBpbXBvcnQgZGVjbGFyYXRpb24ncyBVUkwgaXMgYSBcImdvb2c6Li4uXCIgc3R5bGUgbmFtZXNwYWNlLCB0aGVuIGFsbCBcIi5kZWZhdWx0XCJcbiAgICAgIC8vIGFjY2Vzc2VzIG9uIGl0IHNob3VsZCBiZSByZXBsYWNlZCB3aXRoIHRoZSBzeW1ib2wgaXRzZWxmLlxuICAgICAgLy8gVGhpcyBhbGxvd3MgcmVmZXJyaW5nIHRvIHRoZSBtb2R1bGUtbGV2ZWwgZXhwb3J0IG9mIGEgXCJnb29nLm1vZHVsZVwiIG9yIFwiZ29vZy5wcm92aWRlXCIgYXMgaWZcbiAgICAgIC8vIGl0IHdhcyBhbiBFUzYgZGVmYXVsdCBleHBvcnQuXG4gICAgICBpZiAoZXh0cmFjdEdvb2dOYW1lc3BhY2VJbXBvcnQoKGltcG9ydEV4cG9ydERlY2wubW9kdWxlU3BlY2lmaWVyIGFzIHRzLlN0cmluZ0xpdGVyYWwpLnRleHQpKSB7XG4gICAgICAgIC8vIFN1YnN0aXR1dGUgXCJmb28uZGVmYXVsdFwiIHdpdGgganVzdCBcImZvb1wiLlxuICAgICAgICByZXR1cm4gbm9kZS5leHByZXNzaW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIHJldHVybiAoc2Y6IHRzLlNvdXJjZUZpbGUpOiB0cy5Tb3VyY2VGaWxlID0+IHtcbiAgICAgIC8vIEluIFRTMi45LCB0cmFuc2Zvcm1lcnMgY2FuIHJlY2VpdmUgQnVuZGxlIG9iamVjdHMsIHdoaWNoIHRoaXMgY29kZSBjYW5ub3QgaGFuZGxlIChnaXZlblxuICAgICAgLy8gdGhhdCBhIGJ1bmRsZSBieSBkZWZpbml0aW9uIGNhbm5vdCBiZSBhIGdvb2cubW9kdWxlKCkpLiBUaGUgY2FzdCB0aHJvdWdoIGFueSBpcyBuZWNlc3NhcnlcbiAgICAgIC8vIHRvIHJlbWFpbiBjb21wYXRpYmxlIHdpdGggZWFybGllciBUUyB2ZXJzaW9ucy5cbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgIGlmICgoc2YgYXMgYW55KS5raW5kICE9PSB0cy5TeW50YXhLaW5kLlNvdXJjZUZpbGUpIHJldHVybiBzZjtcblxuICAgICAgLy8gSlMgc2NyaXB0cyAoYXMgb3Bwb3NlZCB0byBtb2R1bGVzKSwgbXVzdCBub3QgYmUgcmV3cml0dGVuIHRvXG4gICAgICAvLyBnb29nLm1vZHVsZXMuXG4gICAgICBpZiAoaG9zdC5pc0pzVHJhbnNwaWxhdGlvbiAmJiAhaXNNb2R1bGUoc2YpKSB7XG4gICAgICAgIHJldHVybiBzZjtcbiAgICAgIH1cblxuICAgICAgbGV0IG1vZHVsZVZhckNvdW50ZXIgPSAxO1xuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgbmV3IHVuaXF1ZSB2YXJpYWJsZSB0byBhc3NpZ24gc2lkZSBlZmZlY3QgaW1wb3J0cyBpbnRvLiBUaGlzIGFsbG93cyB1cyB0byByZS11c2VcbiAgICAgICAqIHRoZSB2YXJpYWJsZSBsYXRlciBvbiBmb3Igb3RoZXIgaW1wb3J0cyBvZiB0aGUgc2FtZSBuYW1lc3BhY2UuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIG5leHRNb2R1bGVWYXIoKSB7XG4gICAgICAgIHJldHVybiBgdHNpY2tsZV9tb2R1bGVfJHttb2R1bGVWYXJDb3VudGVyKyt9X2A7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTWFwcyBnb29nLnJlcXVpcmUgbmFtZXNwYWNlcyB0byB0aGUgdmFyaWFibGUgbmFtZSB0aGV5IGFyZSBhc3NpZ25lZCBpbnRvLiBFLmcuOlxuICAgICAgICogICAgIHZhciAkdmFyTmFtZSA9IGdvb2cucmVxdWlyZSgnJG5hbWVzcGFjZScpKTtcbiAgICAgICAqL1xuICAgICAgY29uc3QgbmFtZXNwYWNlVG9Nb2R1bGVWYXJOYW1lID0gbmV3IE1hcDxzdHJpbmcsIHRzLklkZW50aWZpZXI+KCk7XG5cbiAgICAgIC8qKlxuICAgICAgICogbWF5YmVDcmVhdGVHb29nUmVxdWlyZSByZXR1cm5zIGEgYGdvb2cucmVxdWlyZSgpYCBjYWxsIGZvciB0aGUgZ2l2ZW4gQ29tbW9uSlMgYHJlcXVpcmVgXG4gICAgICAgKiBjYWxsLiBSZXR1cm5zIG51bGwgaWYgYGNhbGxgIGlzIG5vdCBhIENvbW1vbkpTIHJlcXVpcmUuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIG1heWJlQ3JlYXRlR29vZ1JlcXVpcmUoXG4gICAgICAgICAgb3JpZ2luYWw6IHRzLlN0YXRlbWVudCwgY2FsbDogdHMuQ2FsbEV4cHJlc3Npb24sIG5ld0lkZW50OiB0cy5JZGVudGlmaWVyKTogdHMuU3RhdGVtZW50fFxuICAgICAgICAgIG51bGwge1xuICAgICAgICBjb25zdCBpbXBvcnRlZFVybCA9IGV4dHJhY3RSZXF1aXJlKGNhbGwpO1xuICAgICAgICBpZiAoIWltcG9ydGVkVXJsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgaW1wID0gaW1wb3J0UGF0aFRvR29vZ05hbWVzcGFjZShob3N0LCBzZiwgaW1wb3J0ZWRVcmwpO1xuICAgICAgICBtb2R1bGVzTWFuaWZlc3QuYWRkUmVmZXJlbmNlZE1vZHVsZShzZi5maWxlTmFtZSwgaW1wLnRleHQpO1xuICAgICAgICBjb25zdCBpZGVudDogdHMuSWRlbnRpZmllcnx1bmRlZmluZWQgPSBuYW1lc3BhY2VUb01vZHVsZVZhck5hbWUuZ2V0KGltcC50ZXh0KTtcbiAgICAgICAgbGV0IGluaXRpYWxpemVyOiB0cy5FeHByZXNzaW9uO1xuICAgICAgICBpZiAoIWlkZW50KSB7XG4gICAgICAgICAgbmFtZXNwYWNlVG9Nb2R1bGVWYXJOYW1lLnNldChpbXAudGV4dCwgbmV3SWRlbnQpO1xuICAgICAgICAgIGluaXRpYWxpemVyID0gY3JlYXRlR29vZ0NhbGwoJ3JlcXVpcmUnLCBpbXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluaXRpYWxpemVyID0gaWRlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbiBKUyBtb2R1bGVzIGl0J3MgcmVjb21tZW5kZWQgdGhhdCB1c2VycyBnZXQgYSBoYW5kbGUgb24gdGhlXG4gICAgICAgIC8vIGdvb2cgbmFtZXNwYWNlIHZpYTpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgaW1wb3J0ICogYXMgZ29vZyBmcm9tICdnb29nbGUzL2phdmFzY3JpcHQvY2xvc3VyZS9nb29nLmpzJztcbiAgICAgICAgLy9cbiAgICAgICAgLy8gSW4gYSBnb29nLm1vZHVsZSB3ZSBqdXN0IHdhbnQgdG8gYWNjZXNzIHRoZSBnbG9iYWwgYGdvb2dgIHZhbHVlLFxuICAgICAgICAvLyBzbyB3ZSBza2lwIGVtaXR0aW5nIHRoYXQgaW1wb3J0IGFzIGEgZ29vZy5yZXF1aXJlLlxuICAgICAgICAvLyBXZSBjaGVjayB0aGUgZ29vZyBtb2R1bGUgbmFtZSBzbyB0aGF0IHdlIGFsc28gY2F0Y2ggcmVsYXRpdmUgaW1wb3J0cy5cbiAgICAgICAgaWYgKG5ld0lkZW50LmVzY2FwZWRUZXh0ID09PSAnZ29vZycgJiYgaW1wLnRleHQgPT09ICdnb29nbGUzLmphdmFzY3JpcHQuY2xvc3VyZS5nb29nJykge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVOb3RFbWl0dGVkU3RhdGVtZW50V2l0aENvbW1lbnRzKHNmLCBvcmlnaW5hbCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YXJEZWNsID0gdHMuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbihuZXdJZGVudCwgLyogdHlwZSAqLyB1bmRlZmluZWQsIGluaXRpYWxpemVyKTtcbiAgICAgICAgY29uc3QgbmV3U3RtdCA9IHRzLmNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50KFxuICAgICAgICAgICAgLyogbW9kaWZpZXJzICovIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRzLmNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KFxuICAgICAgICAgICAgICAgIFt2YXJEZWNsXSxcbiAgICAgICAgICAgICAgICAvLyBVc2UgJ2NvbnN0JyBpbiBFUzYgbW9kZSBzbyBDbG9zdXJlIHByb3Blcmx5IGZvcndhcmRzIHR5cGUgYWxpYXNlcy5cbiAgICAgICAgICAgICAgICBob3N0LmVzNU1vZGUgPyB1bmRlZmluZWQgOiB0cy5Ob2RlRmxhZ3MuQ29uc3QpKTtcbiAgICAgICAgcmV0dXJuIHRzLnNldE9yaWdpbmFsTm9kZSh0cy5zZXRUZXh0UmFuZ2UobmV3U3RtdCwgb3JpZ2luYWwpLCBvcmlnaW5hbCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV3cml0ZSBnb29nLmRlY2xhcmVNb2R1bGVJZCB0byBzb21ldGhpbmcgdGhhdCB3b3JrcyBpbiBhIGdvb2cubW9kdWxlLlxuICAgICAgICpcbiAgICAgICAqIGdvb2cuZGVjbGFyZU1vZHVsZUlkIGV4cG9zZXMgYSBKUyBtb2R1bGUgYXMgYSBnb29nLm1vZHVsZS4gQWZ0ZXIgd2VcbiAgICAgICAqIGNvbnZlcnQgdGhlIEpTIG1vZHVsZSB0byBhIGdvb2cubW9kdWxlLCB3aGF0IHdlIHJlYWxseSB3YW50IGlzIHRvXG4gICAgICAgKiBleHBvc2UgdGhlIGN1cnJlbnQgZ29vZy5tb2R1bGUgYXQgdHdvIGRpZmZlcmVudCBtb2R1bGUgaWRzLiBUaGlzIGlzbid0XG4gICAgICAgKiBwb3NzaWJsZSB3aXRoIHRoZSBwdWJsaWMgQVBJcywgYnV0IHdlIGNhbiBtYWtlIGl0IHdvcmsgYXQgcnVudGltZVxuICAgICAgICogYnkgd3JpdGluZyBhIHJlY29yZCB0byBnb29nLmxvYWRlZE1vZHVsZXNfLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgb25seSB3b3JrcyBhdCBydW50aW1lLCBhbmQgd291bGQgZmFpbCBpZiBjb21waWxlZCBieSBjbG9zdXJlXG4gICAgICAgKiBjb21waWxlciwgYnV0IHRoYXQncyBvayBiZWNhdXNlIHdlIG9ubHkgdHJhbnNwaWxlIEpTIGluIGRldmVsb3BtZW50XG4gICAgICAgKiBtb2RlLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBtYXliZVJld3JpdGVEZWNsYXJlTW9kdWxlSWQoXG4gICAgICAgICAgb3JpZ2luYWw6IHRzLlN0YXRlbWVudCwgY2FsbDogdHMuQ2FsbEV4cHJlc3Npb24pOiB0cy5TdGF0ZW1lbnR8bnVsbCB7XG4gICAgICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjYWxsIGlzIGEgY2FsbCB0byBnb29nLmRlY2xhcmVNb2R1bGVJZCguLi4pLlxuICAgICAgICBpZiAoIXRzLmlzUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uKGNhbGwuZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9wQWNjZXNzID0gY2FsbC5leHByZXNzaW9uO1xuICAgICAgICBpZiAocHJvcEFjY2Vzcy5uYW1lLmVzY2FwZWRUZXh0ICE9PSAnZGVjbGFyZU1vZHVsZUlkJykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdHMuaXNJZGVudGlmaWVyKHByb3BBY2Nlc3MuZXhwcmVzc2lvbikgfHxcbiAgICAgICAgICAgIHByb3BBY2Nlc3MuZXhwcmVzc2lvbi5lc2NhcGVkVGV4dCAhPT0gJ2dvb2cnKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWZXJpZnkgdGhlIGNhbGwgdGFrZXMgYSBzaW5nbGUgc3RyaW5nIGFyZ3VtZW50IGFuZCBncmFiIGl0LlxuICAgICAgICBpZiAoY2FsbC5hcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJnID0gY2FsbC5hcmd1bWVudHNbMF07XG4gICAgICAgIGlmICghdHMuaXNTdHJpbmdMaXRlcmFsKGFyZykpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2R1bGVJZCA9IGFyZy50ZXh0O1xuICAgICAgICAvLyByZXBsYWNlIGdvb2cuZGVjbGFyZU1vZHVsZUlkWydmb28uYmFyJ10gd2l0aDpcbiAgICAgICAgLy8gZ29vZy5sb2FkZWRNb2R1bGVzX1snZm9vLmJhciddID0ge1xuICAgICAgICAvLyAgIGV4cG9ydHM6IGV4cG9ydHMsXG4gICAgICAgIC8vICAgdHlwZTogZ29vZy5Nb2R1bGVUeXBlLkdPT0csXG4gICAgICAgIC8vICAgbW9kdWxlSWQ6ICdmb28uYmFyJ1xuICAgICAgICAvLyB9O1xuICAgICAgICAvL1xuICAgICAgICAvLyBGb3IgbW9yZSBpbmZvLCBzZWUgYGdvb2cubG9hZE1vZHVsZWAgaW5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWxpYnJhcnkvYmxvYi9tYXN0ZXIvY2xvc3VyZS9nb29nL2Jhc2UuanNcbiAgICAgICAgY29uc3QgbmV3U3RtdCA9IHRzLmNyZWF0ZVN0YXRlbWVudCh0cy5jcmVhdGVBc3NpZ25tZW50KFxuICAgICAgICAgICAgdHMuY3JlYXRlRWxlbWVudEFjY2VzcyhcbiAgICAgICAgICAgICAgICB0cy5jcmVhdGVQcm9wZXJ0eUFjY2VzcyhcbiAgICAgICAgICAgICAgICAgICAgdHMuY3JlYXRlSWRlbnRpZmllcignZ29vZycpLCB0cy5jcmVhdGVJZGVudGlmaWVyKCdsb2FkZWRNb2R1bGVzXycpKSxcbiAgICAgICAgICAgICAgICBjcmVhdGVTaW5nbGVRdW90ZVN0cmluZ0xpdGVyYWwobW9kdWxlSWQpKSxcbiAgICAgICAgICAgIHRzLmNyZWF0ZU9iamVjdExpdGVyYWwoW1xuICAgICAgICAgICAgICB0cy5jcmVhdGVQcm9wZXJ0eUFzc2lnbm1lbnQoJ2V4cG9ydHMnLCB0cy5jcmVhdGVJZGVudGlmaWVyKCdleHBvcnRzJykpLFxuICAgICAgICAgICAgICB0cy5jcmVhdGVQcm9wZXJ0eUFzc2lnbm1lbnQoXG4gICAgICAgICAgICAgICAgICAndHlwZScsXG4gICAgICAgICAgICAgICAgICB0cy5jcmVhdGVQcm9wZXJ0eUFjY2VzcyhcbiAgICAgICAgICAgICAgICAgICAgICB0cy5jcmVhdGVQcm9wZXJ0eUFjY2VzcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHMuY3JlYXRlSWRlbnRpZmllcignZ29vZycpLCB0cy5jcmVhdGVJZGVudGlmaWVyKCdNb2R1bGVUeXBlJykpLFxuICAgICAgICAgICAgICAgICAgICAgIHRzLmNyZWF0ZUlkZW50aWZpZXIoJ0dPT0cnKSkpLFxuICAgICAgICAgICAgICB0cy5jcmVhdGVQcm9wZXJ0eUFzc2lnbm1lbnQoJ21vZHVsZUlkJywgY3JlYXRlU2luZ2xlUXVvdGVTdHJpbmdMaXRlcmFsKG1vZHVsZUlkKSksXG4gICAgICAgICAgICBdKSkpO1xuICAgICAgICByZXR1cm4gdHMuc2V0T3JpZ2luYWxOb2RlKHRzLnNldFRleHRSYW5nZShuZXdTdG10LCBvcmlnaW5hbCksIG9yaWdpbmFsKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBtYXliZVJld3JpdGVSZXF1aXJlVHNsaWIgcmV3cml0ZXMgYSByZXF1aXJlKCd0c2xpYicpIGNhbGxzIHRvIGdvb2cucmVxdWlyZSgndHNsaWInKS4gSXRcbiAgICAgICAqIHJldHVybnMgdGhlIGlucHV0IHN0YXRlbWVudCB1bnRvdWNoZWQgaWYgaXQgZG9lcyBub3QgbWF0Y2guXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIG1heWJlUmV3cml0ZVJlcXVpcmVUc2xpYihzdG10OiB0cy5TdGF0ZW1lbnQpOiB0cy5TdGF0ZW1lbnR8bnVsbCB7XG4gICAgICAgIGlmICghdHMuaXNFeHByZXNzaW9uU3RhdGVtZW50KHN0bXQpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCF0cy5pc0NhbGxFeHByZXNzaW9uKHN0bXQuZXhwcmVzc2lvbikpIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBjYWxsRXhwciA9IHN0bXQuZXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKCF0cy5pc0lkZW50aWZpZXIoY2FsbEV4cHIuZXhwcmVzc2lvbikgfHwgY2FsbEV4cHIuZXhwcmVzc2lvbi50ZXh0ICE9PSAncmVxdWlyZScpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbEV4cHIuYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkgcmV0dXJuIHN0bXQ7XG4gICAgICAgIGNvbnN0IGFyZyA9IGNhbGxFeHByLmFyZ3VtZW50c1swXTtcbiAgICAgICAgaWYgKCF0cy5pc1N0cmluZ0xpdGVyYWwoYXJnKSB8fCBhcmcudGV4dCAhPT0gJ3RzbGliJykgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0cy5zZXRPcmlnaW5hbE5vZGUoXG4gICAgICAgICAgICB0cy5zZXRUZXh0UmFuZ2UodHMuY3JlYXRlU3RhdGVtZW50KGNyZWF0ZUdvb2dDYWxsKCdyZXF1aXJlJywgYXJnKSksIHN0bXQpLCBzdG10KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB2aXNpdFRvcExldmVsU3RhdGVtZW50IGltcGxlbWVudHMgdGhlIG1haW4gQ29tbW9uSlMgdG8gZ29vZy5tb2R1bGUgY29udmVyc2lvbi4gSXQgdmlzaXRzIGFcbiAgICAgICAqIFNvdXJjZUZpbGUgbGV2ZWwgc3RhdGVtZW50IGFuZCBhZGRzIGEgKHBvc3NpYmx5KSB0cmFuc2Zvcm1lZCByZXByZXNlbnRhdGlvbiBvZiBpdCBpbnRvXG4gICAgICAgKiBzdGF0ZW1lbnRzLiBJdCBhZGRzIGF0IGxlYXN0IG9uZSBub2RlIHBlciBzdGF0ZW1lbnQgdG8gc3RhdGVtZW50cy5cbiAgICAgICAqXG4gICAgICAgKiB2aXNpdFRvcExldmVsU3RhdGVtZW50OlxuICAgICAgICogLSBjb252ZXJ0cyByZXF1aXJlKCkgY2FsbHMgdG8gZ29vZy5yZXF1aXJlKCkgY2FsbHMsIHdpdGggb3Igdy9vIHZhciBhc3NpZ25tZW50XG4gICAgICAgKiAtIHJlbW92ZXMgXCJ1c2Ugc3RyaWN0XCI7IGFuZCBcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX2VzTW9kdWxlKVwiIHN0YXRlbWVudHNcbiAgICAgICAqIC0gY29udmVydHMgbW9kdWxlLmV4cG9ydHMgYXNzaWdubWVudHMgdG8ganVzdCBleHBvcnRzIGFzc2lnbm1lbnRzXG4gICAgICAgKiAtIHNwbGl0cyBfX2V4cG9ydFN0YXIoKSBjYWxscyBpbnRvIHJlcXVpcmUgYW5kIGV4cG9ydCAodGhpcyBuZWVkcyB0d28gc3RhdGVtZW50cylcbiAgICAgICAqIC0gbWFrZXMgc3VyZSB0byBvbmx5IGltcG9ydCBlYWNoIG5hbWVzcGFjZSBleGFjdGx5IG9uY2UsIGFuZCB1c2UgdmFyaWFibGVzIGxhdGVyIG9uXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHZpc2l0VG9wTGV2ZWxTdGF0ZW1lbnQoXG4gICAgICAgICAgc3RhdGVtZW50czogdHMuU3RhdGVtZW50W10sIHNmOiB0cy5Tb3VyY2VGaWxlLCBub2RlOiB0cy5TdGF0ZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgLy8gSGFuZGxlIGVhY2ggcGFydGljdWxhciBjYXNlIGJ5IGFkZGluZyBub2RlIHRvIHN0YXRlbWVudHMsIHRoZW4gcmV0dXJuLlxuICAgICAgICAvLyBGb3IgdW5oYW5kbGVkIGNhc2VzLCBicmVhayB0byBqdW1wIHRvIHRoZSBkZWZhdWx0IGhhbmRsaW5nIGJlbG93LlxuXG4gICAgICAgIC8vIEluIEpTIHRyYW5zcGlsYXRpb24gbW9kZSwgYWx3YXlzIHJld3JpdGUgYHJlcXVpcmUoJ3RzbGliJylgIHRvXG4gICAgICAgIC8vIGdvb2cucmVxdWlyZSgndHNsaWInKSwgaWdub3Jpbmcgbm9ybWFsIG1vZHVsZSByZXNvbHV0aW9uLlxuICAgICAgICBpZiAoaG9zdC5pc0pzVHJhbnNwaWxhdGlvbikge1xuICAgICAgICAgIGNvbnN0IHJld3JpdHRlblRzTGliID0gbWF5YmVSZXdyaXRlUmVxdWlyZVRzbGliKG5vZGUpO1xuICAgICAgICAgIGlmIChyZXdyaXR0ZW5Uc0xpYikge1xuICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKHJld3JpdHRlblRzTGliKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKG5vZGUua2luZCkge1xuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5FeHByZXNzaW9uU3RhdGVtZW50OiB7XG4gICAgICAgICAgICBjb25zdCBleHByU3RtdCA9IG5vZGUgYXMgdHMuRXhwcmVzc2lvblN0YXRlbWVudDtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBcInVzZSBzdHJpY3RcIiBhbmQgY2VydGFpbiBPYmplY3QuZGVmaW5lUHJvcGVydHkgYW5kIHNraXAgaXQgaWYgbmVjZXNzYXJ5LlxuICAgICAgICAgICAgaWYgKGlzVXNlU3RyaWN0KGV4cHJTdG10KSB8fCBpc0VzTW9kdWxlUHJvcGVydHkoZXhwclN0bXQpKSB7XG4gICAgICAgICAgICAgIHN0bXRzLnB1c2goY3JlYXRlTm90RW1pdHRlZFN0YXRlbWVudFdpdGhDb21tZW50cyhzZiwgZXhwclN0bXQpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yOlxuICAgICAgICAgICAgLy8gICBtb2R1bGUuZXhwb3J0cyA9IC4uLjtcbiAgICAgICAgICAgIGNvbnN0IG1vZEV4cG9ydHMgPSByZXdyaXRlTW9kdWxlRXhwb3J0c0Fzc2lnbm1lbnQoZXhwclN0bXQpO1xuICAgICAgICAgICAgaWYgKG1vZEV4cG9ydHMpIHtcbiAgICAgICAgICAgICAgc3RtdHMucHVzaChtb2RFeHBvcnRzKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHVzZSBvZiB0aGUgY29tbWEgb3BlcmF0b3IuXG4gICAgICAgICAgICAvLyBUaGlzIG9jY3VycyBpbiBjb2RlIGxpa2VcbiAgICAgICAgICAgIC8vICAgZXhwb3J0cy5hID0gLi4uLCBleHBvcnRzLmIgPSAuLi47XG4gICAgICAgICAgICAvLyB3aGljaCB3ZSB3YW50IHRvIGNoYW5nZSBpbnRvIG11bHRpcGxlIHN0YXRlbWVudHMuXG4gICAgICAgICAgICBjb25zdCBjb21tYUV4cGFuZGVkID0gcmV3cml0ZUNvbW1hRXhwcmVzc2lvbnMoZXhwclN0bXQpO1xuICAgICAgICAgICAgaWYgKGNvbW1hRXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgc3RtdHMucHVzaCguLi5jb21tYUV4cGFuZGVkKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yOlxuICAgICAgICAgICAgLy8gICBcInJlcXVpcmUoJ2ZvbycpO1wiIChhIHJlcXVpcmUgZm9yIGl0cyBzaWRlIGVmZmVjdHMpXG4gICAgICAgICAgICBjb25zdCBleHByID0gZXhwclN0bXQuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGlmICghdHMuaXNDYWxsRXhwcmVzc2lvbihleHByKSkgYnJlYWs7XG4gICAgICAgICAgICBsZXQgY2FsbEV4cHIgPSBleHByO1xuICAgICAgICAgICAgY29uc3QgZGVjbGFyZWRNb2R1bGVJZCA9IG1heWJlUmV3cml0ZURlY2xhcmVNb2R1bGVJZChleHByU3RtdCwgY2FsbEV4cHIpO1xuICAgICAgICAgICAgaWYgKGRlY2xhcmVkTW9kdWxlSWQpIHtcbiAgICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKGRlY2xhcmVkTW9kdWxlSWQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIYW5kbGUgZXhwb3J0ICogaW4gRVM1IG1vZGUgKGluIEVTNiBtb2RlLCBleHBvcnQgKiBpcyBkZXJlZmVyZW5jZWQgYWxyZWFkeSkuXG4gICAgICAgICAgICAvLyBleHBvcnQgKiBjcmVhdGVzIGVpdGhlciBhIHB1cmUgdG9wLWxldmVsICdfX2V4cG9ydChyZXF1aXJlKC4uLikpJyBvciB0aGUgaW1wb3J0ZWRcbiAgICAgICAgICAgIC8vIHZlcnNpb24sICd0c2xpYi5fX2V4cG9ydFN0YXIocmVxdWlyZSguLi4pKScuIFRoZSBpbXBvcnRlZCB2ZXJzaW9uIGlzIG9ubHkgc3Vic3RpdHV0ZWRcbiAgICAgICAgICAgIC8vIGxhdGVyIG9uIHRob3VnaCwgc28gYXBwZWFycyBhcyBhIHBsYWluIFwiX19leHBvcnRTdGFyXCIgb24gdGhlIHRvcCBsZXZlbCBoZXJlLlxuICAgICAgICAgICAgY29uc3QgaXNFeHBvcnRTdGFyID1cbiAgICAgICAgICAgICAgICAodHMuaXNJZGVudGlmaWVyKGV4cHIuZXhwcmVzc2lvbikgJiYgZXhwci5leHByZXNzaW9uLnRleHQgPT09ICdfX2V4cG9ydFN0YXInKSB8fFxuICAgICAgICAgICAgICAgICh0cy5pc0lkZW50aWZpZXIoZXhwci5leHByZXNzaW9uKSAmJiBleHByLmV4cHJlc3Npb24udGV4dCA9PT0gJ19fZXhwb3J0Jyk7XG4gICAgICAgICAgICBpZiAoaXNFeHBvcnRTdGFyKSBjYWxsRXhwciA9IGV4cHIuYXJndW1lbnRzWzBdIGFzIHRzLkNhbGxFeHByZXNzaW9uO1xuICAgICAgICAgICAgY29uc3QgaWRlbnQgPSB0cy5jcmVhdGVJZGVudGlmaWVyKG5leHRNb2R1bGVWYXIoKSk7XG4gICAgICAgICAgICBjb25zdCByZXF1aXJlID0gbWF5YmVDcmVhdGVHb29nUmVxdWlyZShleHByU3RtdCwgY2FsbEV4cHIsIGlkZW50KTtcbiAgICAgICAgICAgIGlmICghcmVxdWlyZSkgYnJlYWs7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gocmVxdWlyZSk7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIGV4cG9ydCBzdGFyLCBzcGxpdCBpdCB1cCBpbnRvIHRoZSBpbXBvcnQgKGNyZWF0ZWQgYnkgdGhlIG1heWJlIGNhbGxcbiAgICAgICAgICAgIC8vIGFib3ZlKSwgYW5kIHRoZSBleHBvcnQgb3BlcmF0aW9uLiBUaGlzIGF2b2lkcyBhIENsb3N1cmUgY29tcGxhaW50IGFib3V0IG5vbi10b3AtbGV2ZWxcbiAgICAgICAgICAgIC8vIHJlcXVpcmVzLlxuICAgICAgICAgICAgaWYgKGlzRXhwb3J0U3Rhcikge1xuICAgICAgICAgICAgICBjb25zdCBhcmdzOiB0cy5FeHByZXNzaW9uW10gPSBbaWRlbnRdO1xuICAgICAgICAgICAgICBpZiAoZXhwci5hcmd1bWVudHMubGVuZ3RoID4gMSkgYXJncy5wdXNoKGV4cHIuYXJndW1lbnRzWzFdKTtcbiAgICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKHRzLmNyZWF0ZVN0YXRlbWVudCh0cy5jcmVhdGVDYWxsKGV4cHIuZXhwcmVzc2lvbiwgdW5kZWZpbmVkLCBhcmdzKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuVmFyaWFibGVTdGF0ZW1lbnQ6IHtcbiAgICAgICAgICAgIC8vIEl0J3MgcG9zc2libHkgb2YgdGhlIGZvcm0gXCJ2YXIgeCA9IHJlcXVpcmUoLi4uKTtcIi5cbiAgICAgICAgICAgIGNvbnN0IHZhclN0bXQgPSBub2RlIGFzIHRzLlZhcmlhYmxlU3RhdGVtZW50O1xuICAgICAgICAgICAgLy8gVmVyaWZ5IGl0J3MgYSBzaW5nbGUgZGVjbCAoYW5kIG5vdCBcInZhciB4ID0gLi4uLCB5ID0gLi4uO1wiKS5cbiAgICAgICAgICAgIGlmICh2YXJTdG10LmRlY2xhcmF0aW9uTGlzdC5kZWNsYXJhdGlvbnMubGVuZ3RoICE9PSAxKSBicmVhaztcbiAgICAgICAgICAgIGNvbnN0IGRlY2wgPSB2YXJTdG10LmRlY2xhcmF0aW9uTGlzdC5kZWNsYXJhdGlvbnNbMF07XG5cbiAgICAgICAgICAgIC8vIEdyYWIgdGhlIHZhcmlhYmxlIG5hbWUgKGF2b2lkaW5nIHRoaW5ncyBsaWtlIGRlc3RydWN0dXJpbmcgYmluZHMpLlxuICAgICAgICAgICAgaWYgKGRlY2wubmFtZS5raW5kICE9PSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXIpIGJyZWFrO1xuICAgICAgICAgICAgaWYgKCFkZWNsLmluaXRpYWxpemVyIHx8ICF0cy5pc0NhbGxFeHByZXNzaW9uKGRlY2wuaW5pdGlhbGl6ZXIpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVxdWlyZSA9IG1heWJlQ3JlYXRlR29vZ1JlcXVpcmUodmFyU3RtdCwgZGVjbC5pbml0aWFsaXplciwgZGVjbC5uYW1lKTtcbiAgICAgICAgICAgIGlmICghcmVxdWlyZSkgYnJlYWs7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gocmVxdWlyZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZW1lbnRzLnB1c2gobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1vZHVsZU5hbWUgPSBob3N0LnBhdGhUb01vZHVsZU5hbWUoJycsIHNmLmZpbGVOYW1lKTtcbiAgICAgIC8vIFJlZ2lzdGVyIHRoZSBuYW1lc3BhY2UgdGhpcyBmaWxlIHByb3ZpZGVzLlxuICAgICAgbW9kdWxlc01hbmlmZXN0LmFkZE1vZHVsZShzZi5maWxlTmFtZSwgbW9kdWxlTmFtZSk7XG5cbiAgICAgIC8vIENvbnZlcnQgZWFjaCB0b3AgbGV2ZWwgc3RhdGVtZW50IHRvIGdvb2cubW9kdWxlLlxuICAgICAgY29uc3Qgc3RtdHM6IHRzLlN0YXRlbWVudFtdID0gW107XG4gICAgICBmb3IgKGNvbnN0IHN0bXQgb2Ygc2Yuc3RhdGVtZW50cykge1xuICAgICAgICB2aXNpdFRvcExldmVsU3RhdGVtZW50KHN0bXRzLCBzZiwgc3RtdCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZGl0aW9uYWwgc3RhdGVtZW50cyB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIChnb29nLm1vZHVsZSBjYWxsIGV0YykuXG4gICAgICBjb25zdCBoZWFkZXJTdG10czogdHMuU3RhdGVtZW50W10gPSBbXTtcblxuICAgICAgLy8gRW1pdDogZ29vZy5tb2R1bGUoJ21vZHVsZU5hbWUnKTtcbiAgICAgIGNvbnN0IGdvb2dNb2R1bGUgPVxuICAgICAgICAgIHRzLmNyZWF0ZVN0YXRlbWVudChjcmVhdGVHb29nQ2FsbCgnbW9kdWxlJywgY3JlYXRlU2luZ2xlUXVvdGVTdHJpbmdMaXRlcmFsKG1vZHVsZU5hbWUpKSk7XG4gICAgICBoZWFkZXJTdG10cy5wdXNoKGdvb2dNb2R1bGUpO1xuXG4gICAgICAvLyBBbGxvdyBjb2RlIHRvIHVzZSBgbW9kdWxlLmlkYCB0byBkaXNjb3ZlciBpdHMgbW9kdWxlIFVSTCwgZS5nLiB0byByZXNvbHZlIGEgdGVtcGxhdGUgVVJMXG4gICAgICAvLyBhZ2FpbnN0LiBVc2VzICd2YXInLCBhcyB0aGlzIGNvZGUgaXMgaW5zZXJ0ZWQgaW4gRVM2IGFuZCBFUzUgbW9kZXMuIFRoZSBmb2xsb3dpbmcgcGF0dGVyblxuICAgICAgLy8gZW5zdXJlcyBjbG9zdXJlIGRvZXNuJ3QgdGhyb3cgYW4gZXJyb3IgaW4gYWR2YW5jZWQgb3B0aW1pemF0aW9ucyBtb2RlLlxuICAgICAgLy8gdmFyIG1vZHVsZSA9IG1vZHVsZSB8fCB7aWQ6ICdwYXRoL3RvL21vZHVsZS50cyd9O1xuICAgICAgY29uc3QgbW9kdWxlSWQgPSBob3N0LmZpbGVOYW1lVG9Nb2R1bGVJZChzZi5maWxlTmFtZSk7XG4gICAgICBjb25zdCBtb2R1bGVWYXJJbml0aWFsaXplciA9IHRzLmNyZWF0ZUJpbmFyeShcbiAgICAgICAgICB0cy5jcmVhdGVJZGVudGlmaWVyKCdtb2R1bGUnKSwgdHMuU3ludGF4S2luZC5CYXJCYXJUb2tlbixcbiAgICAgICAgICB0cy5jcmVhdGVPYmplY3RMaXRlcmFsKFxuICAgICAgICAgICAgICBbdHMuY3JlYXRlUHJvcGVydHlBc3NpZ25tZW50KCdpZCcsIGNyZWF0ZVNpbmdsZVF1b3RlU3RyaW5nTGl0ZXJhbChtb2R1bGVJZCkpXSkpO1xuICAgICAgY29uc3QgbW9kQXNzaWduID0gdHMuY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQoXG4gICAgICAgICAgLyogbW9kaWZpZXJzICovIHVuZGVmaW5lZCwgdHMuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoW3RzLmNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtb2R1bGUnLCAvKiB0eXBlICovIHVuZGVmaW5lZCwgbW9kdWxlVmFySW5pdGlhbGl6ZXIpXSkpO1xuICAgICAgaGVhZGVyU3RtdHMucHVzaChtb2RBc3NpZ24pO1xuXG4gICAgICBpZiAoIWhvc3QuZXM1TW9kZSkge1xuICAgICAgICAvLyBUaGUgbW9kdWxlPW1vZHVsZSBhc3NpZ25tZW50IHN1cHByZXNzZXMgYW4gdW51c2VkIHZhcmlhYmxlIHdhcm5pbmcgd2hpY2ggbWF5IHRyaWdnZXJcbiAgICAgICAgLy8gZGVwZW5kaW5nIG9uIHRoZSBwcm9qZWN0J3MgY29tcGlsYXRpb24gZmxhZ3MuXG4gICAgICAgIGhlYWRlclN0bXRzLnB1c2godHMuY3JlYXRlU3RhdGVtZW50KFxuICAgICAgICAgICAgdHMuY3JlYXRlQXNzaWdubWVudCh0cy5jcmVhdGVJZGVudGlmaWVyKCdtb2R1bGUnKSwgdHMuY3JlYXRlSWRlbnRpZmllcignbW9kdWxlJykpKSk7XG5cbiAgICAgICAgLy8gVGhlIGBleHBvcnRzID0ge31gIHNlcnZlcyBhcyBhIGRlZmF1bHQgZXhwb3J0IHRvIGRpc2FibGUgQ2xvc3VyZSBDb21waWxlcidzIGVycm9yXG4gICAgICAgIC8vIGNoZWNraW5nXG4gICAgICAgIC8vIGZvciBtdXRhYmxlIGV4cG9ydHMuIFRoYXQncyBPSyBiZWNhdXNlIFRTIGNvbXBpbGVyIG1ha2VzIHN1cmUgdGhhdCBjb25zdW1pbmcgY29kZSBhbHdheXNcbiAgICAgICAgLy8gYWNjZXNzZXMgZXhwb3J0cyB0aHJvdWdoIHRoZSBtb2R1bGUgb2JqZWN0LCBzbyBtdXRhYmxlIGV4cG9ydHMgd29yay5cbiAgICAgICAgLy8gSXQgaXMgb25seSBpbnNlcnRlZCBpbiBFUzYgYmVjYXVzZSB3ZSBzdHJpcCBgLmRlZmF1bHRgIGFjY2Vzc2VzIGluIEVTNSBtb2RlLCB3aGljaCBicmVha3NcbiAgICAgICAgLy8gd2hlbiBhc3NpZ25pbmcgYW4gYGV4cG9ydHMgPSB7fWAgb2JqZWN0IGFuZCB0aGVuIGxhdGVyIGFjY2Vzc2luZyBpdC5cbiAgICAgICAgLy8gSG93ZXZlciBDbG9zdXJlIGJhaWxzIGlmIGNvZGUgbGF0ZXIgb24gYXNzaWducyBpbnRvIGV4cG9ydHMgZGlyZWN0bHksIGFzIHdlIGRvIGlmIHdlIGhhdmVcbiAgICAgICAgLy8gYW4gXCJleHBvcnRzID0gXCIgYmxvY2ssIHNvIHNraXAgZW1pdCBpZiB0aGF0J3MgdGhlIGNhc2UuXG4gICAgICAgIGlmICghc2Yuc3RhdGVtZW50cy5maW5kKFxuICAgICAgICAgICAgICAgIHMgPT4gdHMuaXNFeHByZXNzaW9uU3RhdGVtZW50KHMpICYmXG4gICAgICAgICAgICAgICAgICAgIChpc01vZHVsZUV4cG9ydHNBc3NpZ25tZW50KHMpIHx8IGlzRXhwb3J0c0Fzc2lnbm1lbnQocykpKSkge1xuICAgICAgICAgIGhlYWRlclN0bXRzLnB1c2godHMuY3JlYXRlU3RhdGVtZW50KFxuICAgICAgICAgICAgICB0cy5jcmVhdGVBc3NpZ25tZW50KHRzLmNyZWF0ZUlkZW50aWZpZXIoJ2V4cG9ydHMnKSwgdHMuY3JlYXRlT2JqZWN0TGl0ZXJhbCgpKSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEluc2VydCBnb29nLm1vZHVsZSgpIGV0YyBhZnRlciBhbnkgbGVhZGluZyBjb21tZW50cyBpbiB0aGUgc291cmNlIGZpbGUuIFRoZSBjb21tZW50cyBoYXZlXG4gICAgICAvLyBiZWVuIGNvbnZlcnRlZCB0byBOb3RFbWl0dGVkU3RhdGVtZW50cyBieSB0cmFuc2Zvcm1lcl91dGlsLCB3aGljaCB0aGlzIGRlcGVuZHMgb24uXG4gICAgICBjb25zdCBpbnNlcnRpb25JZHggPSBzdG10cy5maW5kSW5kZXgocyA9PiBzLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuTm90RW1pdHRlZFN0YXRlbWVudCk7XG4gICAgICBpZiAoaW5zZXJ0aW9uSWR4ID09PSAtMSkge1xuICAgICAgICBzdG10cy5wdXNoKC4uLmhlYWRlclN0bXRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0bXRzLnNwbGljZShpbnNlcnRpb25JZHgsIDAsIC4uLmhlYWRlclN0bXRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRzLnVwZGF0ZVNvdXJjZUZpbGVOb2RlKHNmLCB0cy5zZXRUZXh0UmFuZ2UodHMuY3JlYXRlTm9kZUFycmF5KHN0bXRzKSwgc2Yuc3RhdGVtZW50cykpO1xuICAgIH07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzTW9kdWxlKHNvdXJjZUZpbGU6IHRzLlNvdXJjZUZpbGUpOiBib29sZWFuIHtcbiAgaW50ZXJmYWNlIEludGVybmFsU291cmNlRmlsZSBleHRlbmRzIHRzLlNvdXJjZUZpbGUge1xuICAgIC8vIEFuIGludGVybmFsIHByb3BlcnR5IHRoYXQgd2UgdXNlIGhlcmUgdG8gY2hlY2sgd2hldGhlciBhIGZpbGUgaXNcbiAgICAvLyBzeW50YWN0aWNhbGx5IGEgbW9kdWxlIG9yIGEgc2NyaXB0LlxuICAgIGV4dGVybmFsTW9kdWxlSW5kaWNhdG9yPzogdHMuTm9kZTtcbiAgfVxuICByZXR1cm4gQm9vbGVhbigoc291cmNlRmlsZSBhcyBJbnRlcm5hbFNvdXJjZUZpbGUpLmV4dGVybmFsTW9kdWxlSW5kaWNhdG9yKTtcbn1cbiJdfQ==